[{"path":"index.html","id":"welcome","chapter":"第1章 welcome","heading":"第1章 welcome","text":"欢迎","code":""},{"path":"introduction.html","id":"introduction","chapter":"introduction","heading":"introduction","text":"介绍了数据的编码，获取，清洗，操作。","code":""},{"path":"数据编码与格式.html","id":"数据编码与格式","chapter":"第2章 数据编码与格式","heading":"第2章 数据编码与格式","text":"","code":""},{"path":"数据编码与格式.html","id":"编码","chapter":"第2章 数据编码与格式","heading":"2.1 编码","text":"即让字符跟计算机的存介绍储建立一个对应关系，首先要给字符设定字符集，确定对应字符的编码和编码规则。再根据编码规则在计算机中存储编码，这样就能根据字符串的编码读取到字符了。把字符存储为字节叫编码，把字节以字符串显示叫解码。","code":"str = \"汪\"\nbytes = str.encode(\"utf-8\")\ndecode_bytes = bytes.decode(\"utf-8\")\nprint(\"{}的字节形式为{},字符串形式为{}\".format(str,bytes,decode_bytes))汪的字节形式为b'\\xe6\\xb1\\xaa',字符串形式为汪"},{"path":"数据编码与格式.html","id":"表格","chapter":"第2章 数据编码与格式","heading":"2.1.1 表格","text":"ASCII码 128个字符，用0-127表示, 用一个字节即可存储，可表示28=256个字符，32-126为可见字符，其他到127为控制字符，实际上一个字节只用了七位。其他国家的字符也需要加入进来，一个字节已经不够。gb2312, 设置字符集，让编码与字符进行对应，采用分区管理方式，共设计94个区，每个区含94个位，共8836个码位。10行，10列的表示方法 区位+行位+列位 区位为高位，占一个字节，行位列位为低位，占一个字节，实际表示用16进制表示。为了与ascII码区分（gb2312向下兼容ascII码），即字节的第八位必须从1开始，即至少大于等于128（0x80），而控制字符需要占32个，外加一个空格键，已经占到了0xa0，所以真正的字符编码在字节中的表示位置都要加上0xa0，代表了在字节中的存储形式，因为之前的已经表示了其他的字符。","code":""},{"path":"数据编码与格式.html","id":"图片","chapter":"第2章 数据编码与格式","heading":"2.1.2 图片","text":"\n图 2.1: gb2312分区\n\n图 2.2: gb2312编码\n\n图 2.3: utf-8编码\n","code":""},{"path":"数据编码与格式.html","id":"视频","chapter":"第2章 数据编码与格式","heading":"2.1.3 视频","text":"","code":""},{"path":"数据获取与存储.html","id":"数据获取与存储","chapter":"第3章 数据获取与存储","heading":"第3章 数据获取与存储","text":"严格地说，所有文件都是二进制的。但是，如果文件中的字节都以纯粹的字符形式保存（例如字母、数字，或是换行、回车、制表符这样的控制字符），那么我们就可以说这个文件是文本格式的。相比之下，二进制文件包含的字节则是由大部分非人类可读的字符组成的。爬虫参考","code":""},{"path":"数据获取与存储.html","id":"文本文件","chapter":"第3章 数据获取与存储","heading":"3.1 文本文件","text":"","code":""},{"path":"数据获取与存储.html","id":"分隔文件","chapter":"第3章 数据获取与存储","heading":"3.1.1 分隔文件","text":"","code":""},{"path":"数据获取与存储.html","id":"读取","chapter":"第3章 数据获取与存储","heading":"3.1.1.1 读取","text":"利用pd.read_csv()方法,主要参数为是否包括表头，是否某些行不读取，缺失值如何表示，是否让某些列作为索引，对某些列传递某些函数做某些处理，编码，是否分块读取，日期处理分块读入csv文件使用chunksize参数,生成的对象可迭代，类似于生成器，可以通过next方法获取下一个chunksize数量的,也可以通过.get_chunk(size)方法获得任意行数的数据，再调用next方法会从当前块位置到当前块结束的位置。","code":"student = pd.read_csv(\"data/数据/学生.csv\",chunksize=5)\nstudent.get_chunk(7).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))next(student).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据获取与存储.html","id":"存储csv文件","chapter":"第3章 数据获取与存储","heading":"3.1.1.2 存储csv文件","text":"","code":""},{"path":"数据获取与存储.html","id":"json","chapter":"第3章 数据获取与存储","heading":"3.1.2 json","text":"","code":""},{"path":"数据获取与存储.html","id":"读取-1","chapter":"第3章 数据获取与存储","heading":"3.1.2.1 读取","text":"键名必为字符串，值可以为列表，字符串，bool等.","code":"import json\nwith open(\"data/数据/information.json\",\"r\") as fp:\n    jf = fp.read()\nresult = json.loads(jf) #将json对象转化为python对象，比如对于空值的表示是不一样的,result为python字典\njson.dumps(result)#转回为json对象,为字符串'{\"name\": \"Wes\", \"places_lived\": [\"United States\", \"Spain\", \"Germany\"], \"pet\": null, \"siblings\": [{\"name\": \"Scott\", \"age\": 30, \"pets\": [\"Zeus\", \"Zuko\"]}, {\"name\": \"Katie\", \"age\": 38, \"pets\": [\"Sixes\", \"Stache\", \"Cisco\"]}]}'#使用pandas读取json数据为DataFrame时每个键的内容必须长度一致,默认json数据数组中的每个对象是表里的一行\npd.read_json(\"data/数据/information.json\")ValueError: All arrays must be of the same length"},{"path":"数据获取与存储.html","id":"存储","chapter":"第3章 数据获取与存储","heading":"3.1.2.2 存储","text":"序列和数据框都有to_json方法，存储的每一个键值对存储一个字段","code":""},{"path":"数据获取与存储.html","id":"html","chapter":"第3章 数据获取与存储","heading":"3.1.3 html","text":"","code":""},{"path":"数据获取与存储.html","id":"读取-2","chapter":"第3章 数据获取与存储","heading":"3.1.3.1 读取","text":":1: FutureWarning: Passing literal html ‘read_html’ deprecated removed future version. read literal string, wrap ‘StringIO’ object.pd.read_html()主要从table标签中读取数据,返回的df对象的list","code":"table = pd.read_html(\n\"\"\"\n<table>\n<tr>\n<th>函数<\/th>\n<th>作用<\/th>\n<\/tr> \n<tr>\n<td>pd.read_html()<\/td>\n<td>从html文件中读取表格<\/td>\n<\/tr> \n<\/table>\n\"\"\"\n)table[0].pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据获取与存储.html","id":"存储为html","chapter":"第3章 数据获取与存储","heading":"3.1.3.2 存储为html","text":"DataFrame.to_html(buf=None, columns=None,col_space=None, header=True， index=True,na_rep=‘NaN’,formatters=None, float_format=None, sparsify=None, index_names=True,justify=None,bold_rows=True,classes=None, escape=True, max_rows=None, max_cols=None,show_dimensions=False,notebook=False, decimal=‘.’, border=None)","code":""},{"path":"数据获取与存储.html","id":"二进制","chapter":"第3章 数据获取与存储","heading":"3.2 二进制","text":"","code":""},{"path":"数据获取与存储.html","id":"excel","chapter":"第3章 数据获取与存储","heading":"3.2.1 excel","text":"","code":""},{"path":"数据获取与存储.html","id":"读取-3","chapter":"第3章 数据获取与存储","heading":"3.2.1.1 读取","text":"基本格式和读取csv文件差不多，只不过多了sheet_name参数,存储时也多了一个，可以指定sheet","code":"pd.read_excel(\"data/数据/ex2.xlsx\",\"Sheet1\",index_col=[0]).head(3).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据获取与存储.html","id":"存储-1","chapter":"第3章 数据获取与存储","heading":"3.2.1.2 存储","text":".to_excel()","code":""},{"path":"数据获取与存储.html","id":"hdf5","chapter":"第3章 数据获取与存储","heading":"3.2.2 HDF5","text":"HDF5是一个备受好评的文件格式，用于存储大量的科学数组数据。它以C库的形式提供，并且具有许多其他语言的接口，包括Java、Julia、MATLAB和Python。HDF5中的“HDF”代表分层数据格式。每个HDF5文件可以存储多个数据集并且支持元数据。与更简单的格式相比，HDF5支持多种压缩模式的即时压缩，使得重复模式的数据可以更高效地存储。HDF5适用于处理不适合在内存中存储的超大型数据，可以使你高效读写大型数组的一小块。尽管可以通过使用PyTables或h5py等库直接访问HDF5文件，但pandas提供了一个高阶的接口，可以简化Series和DataFrame的存储。HDFStore类像字典一样工作并处理低级别细节，包含在HDF5文件中的对象可以使用相同的字典型API进行检索。","code":"# frame = pd.DataFrame({\"a\":np.random.randn(10)})\n# store = pd.HDFStore(\"data/数据/mydata.h5\")\n# store['obj1'] = frame\n# store['boj2'] = frame\n# store\n# store = pd.read_hdf(\"data/数据/mydata.h5\",\"obj1\",where=['index<5'])\n#store = pd.read_hdf(\"data/数据/mydata.h5\",\"obj1\")\n#store.head()"},{"path":"数据清洗.html","id":"数据清洗","chapter":"第4章 数据清洗","heading":"第4章 数据清洗","text":"","code":""},{"path":"数据清洗.html","id":"查看数据信息","chapter":"第4章 数据清洗","heading":"4.1 查看数据信息","text":"导入数据后应该了解字段信息，字段的数据类型，哪些字段有缺失值","code":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.rcParams['font.sans-serif']=['Simhei']; #SimHei黑体 \nplt.rcParams['axes.unicode_minus']=False; #正常显示图中负号\ndata = pd.read_csv(\"data/数据/学生.csv\")\ndata.head(5).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))pd.set_option('future.no_silent_downcasting', True)"},{"path":"数据清洗.html","id":"info","chapter":"第4章 数据清洗","heading":"4.1.1 .info()","text":"查看字段名，缺失值和字段类型","code":"data.info()<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1800 entries, 0 to 1799\nData columns (total 6 columns):\n #   Column  Non-Null Count  Dtype \n---  ------  --------------  ----- \n 0   姓名      1800 non-null   object\n 1   性别      1800 non-null   object\n 2   班级      1800 non-null   object\n 3   数学      1800 non-null   int64 \n 4   语文      1800 non-null   int64 \n 5   英语      1800 non-null   int64 \ndtypes: int64(3), object(3)\nmemory usage: 84.5+ KB"},{"path":"数据清洗.html","id":"dtypes","chapter":"第4章 数据清洗","heading":"4.1.2 .dtypes","text":"查看字段类型","code":"data.dtypes姓名    object\n性别    object\n班级    object\n数学     int64\n语文     int64\n英语     int64\ndtype: object"},{"path":"数据清洗.html","id":"describe","chapter":"第4章 数据清洗","heading":"4.1.3 .describe()","text":"`.describe(include/exclude=[])默认只对数值类型进行各种字段的描述,可以设置include和exclude参数对类型进行选择","code":"data.describe().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))data.describe(include=[\"object\"]).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据清洗.html","id":"缺失值","chapter":"第4章 数据清洗","heading":"4.2 缺失值","text":"","code":""},{"path":"数据清洗.html","id":"查看缺失值","chapter":"第4章 数据清洗","heading":"4.2.1 查看缺失值","text":".isnull(axis),.notnull(axis)数据缺失,python的None对象，numpy中的np.nan都被视为缺失,空字符串不被视为缺失。通常对于缺失值的处理，最常用的方法无外乎删除法、替换法和插补法。删除法是指将缺失值所在的观测行删除（前提是缺失行的比例非常低，如5%以内），或者删除缺失值所对应的变量（前提是该变量中包含的缺失值比例非常高，如70%左右）；替换法是指直接利用缺失变量的均值、中位数或众数替换该变量中的缺失值，其好处是缺失值的处理速度快，弊端是易产生有偏估计，导致缺失值替换的准确性下降；插补法则是利用有监督的机器学习方法（如回归模型、树模型、网络模型等）对缺失值作预测，其优势在于预测的准确性高，缺点是需要大量的计算，导致缺失值的处理速度大打折扣。","code":"nadata = pd.DataFrame({'null':[None,np.nan,'','nan',0]*2,\n                      'value':np.random.choice([None,np.nan]+list(range(10)),10,)})\nnadata.head()   null value\n0  None     1\n1   NaN     4\n2           7\n3   nan     0\n4     0     0nadata.isnull().head()    null  value\n0   True  False\n1   True  False\n2  False  False\n3  False  False\n4  False  Falsenadata[nadata['null'].notnull()]# 根据某个字段的未缺失值选取行  null value\n2          7\n3  nan     0\n4    0     0\n7          4\n8  nan  None\n9    0     3nadata.isnull().sum()/len(nadata)#查看各个字段的缺失比例null     0.4\nvalue    0.1\ndtype: float64lack_rate = 0.3\n#选取出所有缺失比例大于0.3的字段名\n(nadata.isnull().sum()/len(nadata)).pipe(lambda df:df[df>lack_rate].index.values)array(['null'], dtype=object)"},{"path":"数据清洗.html","id":"删除缺失值","chapter":"第4章 数据清洗","heading":"4.2.2 删除缺失值","text":".dropna(axis,,subset,thresh)","code":"nadata.dropna(how=\"all\")   null value\n0  None     1\n1   NaN     4\n2           7\n3   nan     0\n4     0     0\n5  None     8\n6   NaN     9\n7           4\n8   nan  None\n9     0     3nadata.dropna(subset=[\"null\"])  null value\n2          7\n3  nan     0\n4    0     0\n7          4\n8  nan  None\n9    0     3nadata.dropna(thresh=1)   null value\n0  None     1\n1   NaN     4\n2           7\n3   nan     0\n4     0     0\n5  None     8\n6   NaN     9\n7           4\n8   nan  None\n9     0     3"},{"path":"数据清洗.html","id":"填补缺失值","chapter":"第4章 数据清洗","heading":"4.2.3 填补缺失值","text":".fillna(value,method,**kwargs)通过给字段传递标量，可以进行均值，最大值，最小值，中值等填补，通过method参数可以进行前向和后向填补。","code":"nadata.fillna(0)  null value\n0    0     1\n1    0     4\n2          7\n3  nan     0\n4    0     0\n5    0     8\n6    0     9\n7          4\n8  nan     0\n9    0     3nadata.fillna({\"null\":0,\"value\":int(np.mean(nadata.value))})#不加int会变成浮点型  null value\n0    0     1\n1    0     4\n2          7\n3  nan     0\n4    0     0\n5    0     8\n6    0     9\n7          4\n8  nan     4\n9    0     3nadata.fillna(method=\"bfill\")<string>:1: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n  null value\n0          1\n1          4\n2          7\n3  nan     0\n4    0     0\n5          8\n6          9\n7          4\n8  nan     3\n9    0     3"},{"path":"数据清洗.html","id":"插补法","chapter":"第4章 数据清洗","heading":"4.2.4 插补法","text":"利用机器学习的方法构建模型，通过模型根据其他字段的值来对缺失值进行预测。","code":""},{"path":"数据清洗.html","id":"类型转换","chapter":"第4章 数据清洗","heading":"4.3 类型转换","text":"读入的数据类型包含object(任何对象都可以用object来存储)，number(数值类型),string(字符串类型),bool(逻辑类型).可以用.select_dtypes(include/exclude=[])选取对应类型的列字符串和日期在刚读入时都是object类型，需要转换为字符串类型，日期类型才能进行.str和.dt操作,各类型转换转化方法见下表.字符串类型的浮点数必须先转为浮点数才能转为int","code":"data.select_dtypes(include=[\"object\"])         姓名 性别       班级\n0        a1  男   高一(1)班\n1        a2  女   高一(2)班\n2        a3  女   高一(3)班\n3        a4  男   高一(4)班\n4        a5  男   高一(5)班\n...     ... ..      ...\n1795  a1796  男  高三(16)班\n1796  a1797  男  高三(17)班\n1797  a1798  女  高三(18)班\n1798  a1799  女  高三(19)班\n1799  a1800  女  高三(20)班\n\n[1800 rows x 3 columns]data.select_dtypes(exclude=[\"object\"])      数学  语文  英语\n0     61  59  70\n1     62  77  74\n2     58  71  83\n3     65  57  71\n4     56  83  72\n...   ..  ..  ..\n1795  65  73  71\n1796  68  66  75\n1797  50  65  72\n1798  64  73  70\n1799  60  81  65\n\n[1800 rows x 3 columns]data.dtypes姓名    object\n性别    object\n班级    object\n数学     int64\n语文     int64\n英语     int64\ndtype: objectts = pd.read_csv(\"data/数据/year-month-day.csv\",index_col=[0]).reset_index().rename(columns={\"index\":\"day\"})\nts.dtypesday       object\nvalue    float64\ndtype: objectdata.astype({\"姓名\":\"string\",\"性别\":\"string\",\"班级\":\"string\"}).dtypes姓名    string[python]\n性别    string[python]\n班级    string[python]\n数学             int64\n语文             int64\n英语             int64\ndtype: objectts.astype({\"day\":\"datetime64[ns]\"}).dtypesday      datetime64[ns]\nvalue           float64\ndtype: objectts[\"day\"] = pd.to_datetime(ts.day)\nts.day.dt.year.head()0    2023\n1    2023\n2    2023\n3    2023\n4    2023\nName: day, dtype: int32"},{"path":"数据清洗.html","id":"重复值","chapter":"第4章 数据清洗","heading":"4.4 重复值","text":"数据的记录是否存在重复值，重复值有无存在意义","code":""},{"path":"数据清洗.html","id":"查看重复值","chapter":"第4章 数据清洗","heading":"4.4.1 查看重复值","text":".duplicated(subset),可以设置subset参数只对某些子集判断","code":"data.duplicated().any()Falsedata[data.duplicated()]Empty DataFrame\nColumns: [姓名, 性别, 班级, 数学, 语文, 英语]\nIndex: []#根据index value来删除重复行\ndata.index.duplicated().sum()0"},{"path":"数据清洗.html","id":"删除重复值","chapter":"第4章 数据清洗","heading":"4.4.2 删除重复值","text":".drop_duplicates(subset)，同样可以设置subset参数","code":"data.drop_duplicates()         姓名 性别       班级  数学  语文  英语\n0        a1  男   高一(1)班  61  59  70\n1        a2  女   高一(2)班  62  77  74\n2        a3  女   高一(3)班  58  71  83\n3        a4  男   高一(4)班  65  57  71\n4        a5  男   高一(5)班  56  83  72\n...     ... ..      ...  ..  ..  ..\n1795  a1796  男  高三(16)班  65  73  71\n1796  a1797  男  高三(17)班  68  66  75\n1797  a1798  女  高三(18)班  50  65  72\n1798  a1799  女  高三(19)班  64  73  70\n1799  a1800  女  高三(20)班  60  81  65\n\n[1800 rows x 6 columns]data[~data.index.duplicated()]         姓名 性别       班级  数学  语文  英语\n0        a1  男   高一(1)班  61  59  70\n1        a2  女   高一(2)班  62  77  74\n2        a3  女   高一(3)班  58  71  83\n3        a4  男   高一(4)班  65  57  71\n4        a5  男   高一(5)班  56  83  72\n...     ... ..      ...  ..  ..  ..\n1795  a1796  男  高三(16)班  65  73  71\n1796  a1797  男  高三(17)班  68  66  75\n1797  a1798  女  高三(18)班  50  65  72\n1798  a1799  女  高三(19)班  64  73  70\n1799  a1800  女  高三(20)班  60  81  65\n\n[1800 rows x 6 columns]"},{"path":"数据清洗.html","id":"异常值","chapter":"第4章 数据清洗","heading":"4.5 异常值","text":"异常值也称为离群点，就是那些远离绝大多数样本点的特殊群体，通常这样的数据点在数据集中都表现出不合理的特性。如果忽视这些异常值，在某些建模场景下就会导致结论的错误（如线性回归模型、K均值聚类等），所以在数据的探索过程中，有必要识别出这些异常值并处理好它们。对于异常的判断和处理要根据实际情况进行相应的判断和处理.","code":""},{"path":"数据清洗.html","id":"查看异常值","chapter":"第4章 数据清洗","heading":"4.5.1 查看异常值","text":"通常，异常值的识别可以借助于图形法（如箱线图、正态分布图）和建模法（如线性回归、聚类算法、K近邻算法）","code":""},{"path":"数据清洗.html","id":"箱线图","chapter":"第4章 数据清洗","heading":"4.5.1.1 箱线图","text":"箱线图技术实际上就是利用数据的分位数识别其中的异常点，该图形属于典型的统计图形，在学术界和工业界都得到广泛的应用。箱线图的形状特征如下图所示：图中的下四分位数指的是数据的25%分位点所对应的值（Q1）；中位数即为数据的50%分位点所对应的值（Q2）；上四分位数则为数据的75%分位点所对应的值（Q3）；上须的计算公式为Q3+1.5(Q3-Q1)；下须的计算公式为Q1-1.5(Q3-Q1)。其中，Q3-Q1表示四分位差。如果采用箱线图识别异常值，其判断标准是，当变量的数据值大于箱线图的上须或者小于箱线图的下须时，就可以认为这样的数据点为异常点。所以，基于上方的箱线图，可以定义某个数值型变量中的异常点和极端异常点，它们的判断表达式如下表所示：这样做只能直观呈现，要想得到异常点，可以手动计算选择","code":"abdata = pd.DataFrame({'value':list(np.random.normal(70,5,100))+[50,57,83,90]})\nabdata.boxplot(\n  whis = 1.5, # 指定1.5倍的四分位差\n  widths = 0.7, # 指定箱线图的宽度为0.8\n  patch_artist = True, # 指定需要填充箱体颜色\n  showmeans = True, # 指定需要显示均值\n  #boxprops = {'facecolor':'steelblue'}, # 指定箱体的填充色为铁蓝色\n  # 指定异常点的填充色、边框色和大小\n  #flierprops = {'markerfacecolor':'red', 'markeredgecolor':'red', 'markersize':4}, # 指定均值点的标记符号（菱形）、填充色和大小\n  #meanprops = {'marker':'D','markerfacecolor':'black', 'markersize':4}, \n  #medianprops = {'linestyle':'--','color':'orange'},#指定中位数的标记符号（虚线）和颜色\n  #labels = [''] # 去除箱线图的x轴刻度值\n  )\n#显示图形\nplt.show()q1,q3 = abdata.value.quantile(q=[0.25,0.75])\nabdata[(abdata.value < q1-1.5*(q3-q1)) | (abdata.value>q3+1.5*(q3-q1))]         value\n99   83.752253\n100  50.000000\n103  90.000000"},{"path":"数据清洗.html","id":"正态分布图","chapter":"第4章 数据清洗","heading":"4.5.1.2 正态分布图","text":"如果数据满足正态分布，还可以通过3\\(\\sigma\\)的准则来进行异常值的判断，根据正态分布的定义可知，数据点落在偏离均值正负1倍标准差（即sigma值）内的概率为68.2%；数据点落在偏离均值正负2倍标准差内的概率为95.4%；数据点落在偏离均值正负3倍标准差内的概率为99.6%。所以，换个角度思考上文提到的概率值，如果数据点落在偏离均值正负2倍标准差之外的概率就不足5%，它属于小概率事件，即认为这样的数据点为异常点。同理，如果数据点落在偏离均值正负3倍标准差之外的概率将会更小，可以认为这些数据点为极端异常点。为使读者直观地理解文中提到的概率值，可以查看标准正态分布的概率密度图，如下图所示：可以按照下表中的判断条件，识别出数值型变量的异常点和极端异常点，如下表所示：","code":"# 绘制单条折线图，并在折线图的基础上添加点图\nabdata.index = pd.date_range(\"2023-01-01\",periods=len(abdata))\nabdata.plot( \n      linestyle = '-', # 设置折线类型\n      linewidth = 2, # 设置线条宽度\n      color = 'steelblue', # 设置折线颜色\n      marker = 'o', # 往折线图中添加圆点\n      markersize = 4, # 设置点的大小\n      markeredgecolor='black', # 设置点的边框色\n      markerfacecolor='black') # 设置点的填充色\n      \n# 添加上下界的水平参考线（便于判断异常点，如下判断极端异常点，只需将2改为3）\nplt.axhline(y = abdata.value.mean() - 2*abdata.value.std(), linestyle = '--', color = 'gray')\nplt.axhline(y = abdata.value.mean() + 2*abdata.value.std(), linestyle = '--', color = 'gray')\n\n# 导入模块，用于日期刻度的修改（因为默认格式下的日期刻度标签并不是很友好）\nimport matplotlib as mpl\n# 获取图的坐标信息\nax = plt.gca()\n# 设置日期的显示格式  \ndate_format = mpl.dates.DateFormatter(\"%m-%d\")  \nax.xaxis.set_major_formatter(date_format) \n\n# 设置x轴每个刻度的间隔天数\nxlocator = mpl.ticker.MultipleLocator(7)\nax.xaxis.set_major_locator(xlocator)\n# 为了避免x轴刻度标签的紧凑，将刻度标签旋转45度\nplt.xticks(rotation=45)(array([19355., 19362., 19369., 19376., 19383., 19390., 19397., 19404.,\n       19411., 19418., 19425., 19432., 19439., 19446., 19453., 19460.,\n       19467.]), [Text(19355.0, 0, '12-29'), Text(19362.0, 0, '01-05'), Text(19369.0, 0, '01-12'), Text(19376.0, 0, '01-19'), Text(19383.0, 0, '01-26'), Text(19390.0, 0, '02-02'), Text(19397.0, 0, '02-09'), Text(19404.0, 0, '02-16'), Text(19411.0, 0, '02-23'), Text(19418.0, 0, '03-02'), Text(19425.0, 0, '03-09'), Text(19432.0, 0, '03-16'), Text(19439.0, 0, '03-23'), Text(19446.0, 0, '03-30'), Text(19453.0, 0, '04-06'), Text(19460.0, 0, '04-13'), Text(19467.0, 0, '04-20')])# 显示图形\nplt.show()"},{"path":"数据清洗.html","id":"处理异常值","chapter":"第4章 数据清洗","heading":"4.5.2 处理异常值","text":"检测到了异常值，我们需要对其进行一定的处理。而一般异常值的处理方法可大致分为以下几种删除含有异常值的记录：直接将含有异常值的记录删除；视为缺失值：将异常值视为缺失值，利用缺失值处理的方法进行处理；平均值修正：可用前后两个观测值的平均值修正该异常值；不处理：直接在具有异常值的数据集上进行数据挖掘；是否要删除异常值可根据实际情况考虑。因为一些模型对异常值不很敏感，即使有异常值也不影响模型效果，但是一些模型比如逻辑回归LR对异常值很敏感，如果不进行处理，可能会出现过拟合等非常差的效果。","code":""},{"path":"数据清洗.html","id":"字段值的处理","chapter":"第4章 数据清洗","heading":"4.6 字段值的处理","text":"","code":""},{"path":"数据清洗.html","id":"map","chapter":"第4章 数据清洗","heading":"4.6.1 .map()","text":".map(func/**kwargs)处理一个字段中每一类元素(如果有类未被指定会被map为np.nan)或每一个元素序列带有.map()方法,数据框没有,所以可以对单个字段进行map操作，若想同时对多个字段进行map操作，可以结合agg函数。可以传递函数或字典","code":"data.性别.map({\"男\":\"male\"}).head()0    male\n1     NaN\n2     NaN\n3    male\n4    male\nName: 性别, dtype: object"},{"path":"数据清洗.html","id":"replace","chapter":"第4章 数据清洗","heading":"4.6.2 .replace()","text":".replace(to_repalce,value,method)对特定的几个值进行替换可以只对某一列的某一类值进行替换，其他种类不变","code":"nadata.null.replace(np.nan,\"replace\")0    replace\n1    replace\n2           \n3        nan\n4          0\n5    replace\n6    replace\n7           \n8        nan\n9          0\nName: null, dtype: objectnadata.replace({\"null\":{0:\"00\"}})   null value\n0  None     1\n1   NaN     4\n2           7\n3   nan     0\n4    00     0\n5  None     8\n6   NaN     9\n7           4\n8   nan  None\n9    00     3"},{"path":"数据清洗.html","id":"str","chapter":"第4章 数据清洗","heading":"4.6.3 .str","text":"对string类型的字段中的元素进行string类型的操作字符串列表的默认类型是object，我们如果想指定类型，可以在生成Series时声明dtype,或者之后使用.astype()方法\ndtype = “string”/pd.StringDtype()\n.astype(“string”)\nNA 将会被转化为< NA >\ndtype = “string”/pd.StringDtype().astype(“string”)NA 将会被转化为< NA >method\n.str.lower(),.str.upper():小写，大写\n.str.len()：字符串长度\n.str.strip():清除两边空格\n.str.split()，.str.rsplit():切分字符串\n.str.get(1)=.str[1]，可以获得split后的每个element的id为1的元素\n.expand =True:自动把每个切分值作为一列\nn=1:切分一次后就不切分\n\n.str.replace(pat,repl):可以使用正则表达式\nregex:是否使用正则表达式,设置为False时，pat,repl必须是字符串\ncase:是否区分大小写\npat:可以是re.compile对象,比如re.compile(r\"^.|dog\", flags=re.IGNORECASE)\nrepl:可以是函数，函数的参数是一个正则表达式对象，比如match对象\n\n.str.cat(sep=““,others=):concatenate，把每个元素以sep为分隔结合到一起\nsep:默认是空\nna_rep:默认空值是不被concatenate，可以为空值设置一个字符串用来连接\nothers:\n\nConcatenating Series something array-like Series:row的数目相同\nConcatenating Series indexed object Series, alignment:可以指定join参数\nConcatenating Series many objects Series：Several array-like items (specifically: Series, Index, 1-dimensional variants np.ndarray) can combined list-like container (including iterators, dict-views, etc.).\n\n\n.str.extract():returns first match\n接受一个正则表达式:至少有一个group，然后一个group为一列，每个字符若无匹配项则为< NA >\n\n.str.extractall():Extract matches subject ,结果通常是一个有着MultiIndex的DataFrame,最后一层level一般是“match”,代表了subject的顺序\nstr.contains(pattern):测试字符串是否包含一个模式\nstr.match(pattern):测试字符串是否匹配一个模式，从字符串开头匹配\nstr.fullmatch(pattern):测试整个字符串是否满足模式\nstr.get_dummies():\nSeries:pd.Series([“”,“|b”,np.nan,“|c”]).str.get_dummies(sep=“|”),返回DataFrame,相当于每个元素是一些特征的集合，我们找到所有的集合作为column，然后赋予0,1\nIndex:MultiIndex\n\n.str.lower(),.str.upper():小写，大写.str.len()：字符串长度.str.strip():清除两边空格.str.split()，.str.rsplit():切分字符串\n.str.get(1)=.str[1]，可以获得split后的每个element的id为1的元素\n.expand =True:自动把每个切分值作为一列\nn=1:切分一次后就不切分\n.str.get(1)=.str[1]，可以获得split后的每个element的id为1的元素.expand =True:自动把每个切分值作为一列n=1:切分一次后就不切分.str.replace(pat,repl):可以使用正则表达式\nregex:是否使用正则表达式,设置为False时，pat,repl必须是字符串\ncase:是否区分大小写\npat:可以是re.compile对象,比如re.compile(r\"^.|dog\", flags=re.IGNORECASE)\nrepl:可以是函数，函数的参数是一个正则表达式对象，比如match对象\nregex:是否使用正则表达式,设置为False时，pat,repl必须是字符串case:是否区分大小写pat:可以是re.compile对象,比如re.compile(r\"^.|dog\", flags=re.IGNORECASE)repl:可以是函数，函数的参数是一个正则表达式对象，比如match对象.str.cat(sep=““,others=):concatenate，把每个元素以sep为分隔结合到一起\nsep:默认是空\nna_rep:默认空值是不被concatenate，可以为空值设置一个字符串用来连接\nothers:\n\nConcatenating Series something array-like Series:row的数目相同\nConcatenating Series indexed object Series, alignment:可以指定join参数\nConcatenating Series many objects Series：Several array-like items (specifically: Series, Index, 1-dimensional variants np.ndarray) can combined list-like container (including iterators, dict-views, etc.).\n\nsep:默认是空na_rep:默认空值是不被concatenate，可以为空值设置一个字符串用来连接others:\n\nConcatenating Series something array-like Series:row的数目相同\nConcatenating Series indexed object Series, alignment:可以指定join参数\nConcatenating Series many objects Series：Several array-like items (specifically: Series, Index, 1-dimensional variants np.ndarray) can combined list-like container (including iterators, dict-views, etc.).\nConcatenating Series something array-like Series:row的数目相同Concatenating Series indexed object Series, alignment:可以指定join参数Concatenating Series many objects Series：Several array-like items (specifically: Series, Index, 1-dimensional variants np.ndarray) can combined list-like container (including iterators, dict-views, etc.)..str.extract():returns first match\n接受一个正则表达式:至少有一个group，然后一个group为一列，每个字符若无匹配项则为< NA >\n接受一个正则表达式:至少有一个group，然后一个group为一列，每个字符若无匹配项则为< NA >.str.extractall():Extract matches subject ,结果通常是一个有着MultiIndex的DataFrame,最后一层level一般是“match”,代表了subject的顺序str.contains(pattern):测试字符串是否包含一个模式str.match(pattern):测试字符串是否匹配一个模式，从字符串开头匹配str.fullmatch(pattern):测试整个字符串是否满足模式str.get_dummies():\nSeries:pd.Series([“”,“|b”,np.nan,“|c”]).str.get_dummies(sep=“|”),返回DataFrame,相当于每个元素是一些特征的集合，我们找到所有的集合作为column，然后赋予0,1\nIndex:MultiIndex\nSeries:pd.Series([“”,“|b”,np.nan,“|c”]).str.get_dummies(sep=“|”),返回DataFrame,相当于每个元素是一些特征的集合，我们找到所有的集合作为column，然后赋予0,1Index:MultiIndex\nMethod\n\nDescription\n\ncat()\n\nConcatenate strings\n\nsplit()\n\nSplit strings delimiter\n\nrsplit()\n\nSplit strings delimiter working end string\n\nget()\n\nIndex element (retrieve -th element)\n\njoin()\n\nJoin strings element Series passed separator\n\nget_dummies()\n\nSplit strings delimiter returning DataFrame dummy variables\n\ncontains()\n\nReturn boolean array string contains pattern/regex\n\nreplace()\n\nReplace occurrences pattern/regex/string string return value callable given occurrence\n\nrepeat()\n\nDuplicate values (s.str.repeat(3) equivalent x * 3)\n\npad()\n\nAdd whitespace left, right, sides strings\n\ncenter()\n\nEquivalent str.center\n\nljust()\n\nEquivalent str.ljust\n\nrjust()\n\nEquivalent str.rjust\n\nzfill()\n\nEquivalent str.zfill\n\nwrap()\n\nSplit long strings lines length less given width\n\nslice()\n\nSlice string Series\n\nslice_replace()\n\nReplace slice string passed value\n\ncount()\n\nCount occurrences pattern\n\nstartswith()\n\nEquivalent str.startswith(pat) element\n\nendswith()\n\nEquivalent str.endswith(pat) element\n\nfindall()\n\nCompute list occurrences pattern/regex string\n\nmatch()\n\nCall re.match element, returning matched groups list\n\nextract()\n\nCall re.search element, returning DataFrame one row element one column regex capture group\n\nextractall()\n\nCall re.findall element, returning DataFrame one row match one column regex capture group\n\nlen()\n\nCompute string lengths\n\nstrip()\n\nEquivalent str.strip\n\nrstrip()\n\nEquivalent str.rstrip\n\nlstrip()\n\nEquivalent str.lstrip\n\npartition()\n\nEquivalent str.partition\n\nrpartition()\n\nEquivalent str.rpartition\n\nlower()\n\nEquivalent str.lower\n\ncasefold()\n\nEquivalent str.casefold\n\nupper()\n\nEquivalent str.upper\n\nfind()\n\nEquivalent str.find\n\nrfind()\n\nEquivalent str.rfind\n\nindex()\n\nEquivalent str.index\n\nrindex()\n\nEquivalent str.rindex\n\ncapitalize()\n\nEquivalent str.capitalize\n\nswapcase()\n\nEquivalent str.swapcase\n\nnormalize()\n\nReturn Unicode normal form. Equivalent unicodedata.normalize\n\ntranslate()\n\nEquivalent str.translate\n\nisalnum()\n\nEquivalent str.isalnum\n\nisalpha()\n\nEquivalent str.isalpha\n\nisdigit()\n\nEquivalent str.isdigit\n\nisspace()\n\nEquivalent str.isspace\n\nislower()\n\nEquivalent str.islower\n\nisupper()\n\nEquivalent str.isupper\n\nistitle()\n\nEquivalent str.istitle\n\nisnumeric()\n\nEquivalent str.isnumeric\n\nisdecimal()\n\nEquivalent str.isdecimal\n","code":""},{"path":"数据清洗.html","id":"dt","chapter":"第4章 数据清洗","heading":"4.6.4 .dt","text":"对日期类型的字段进行操作","code":""},{"path":"数据清洗.html","id":"参考网址","chapter":"第4章 数据清洗","heading":"4.7 参考网址","text":"大数据分析php","code":""},{"path":"数据操作.html","id":"数据操作","chapter":"第5章 数据操作","heading":"第5章 数据操作","text":"","code":"import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\npd.set_option('mode.chained_assignment', None)\nplt.rcParams['font.sans-serif']=['Simhei']; #SimHei黑体 \nplt.rcParams['axes.unicode_minus']=False; #正常显示图中负号\ndata = pd.read_csv(\"data/数据/学生.csv\")\nsd = data.head()\nsd.columns = [\"name\",\"sex\",\"class\",\"math\",\"chinese\",\"english\"]\ndata.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))sd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"列","chapter":"第5章 数据操作","heading":"5.1 列","text":"","code":"(\npd.DataFrame(\n  [\n   [\"返回列名\",\"sd.columns<br/>{}\".format(sd.columns)],\n   [\"非列表\",\"type(sd.columns):{}\".format(type(sd.columns))]\n],columns=[\"特性\",\"操作\"]\n)\n.set_index(\"特性\")\n.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n)"},{"path":"数据操作.html","id":"选取列","chapter":"第5章 数据操作","heading":"5.1.1 选取列","text":"","code":""},{"path":"数据操作.html","id":"选取一列","chapter":"第5章 数据操作","heading":"5.1.1.1 选取一列","text":"","code":"(\npd.DataFrame(\n  [\n    [\"sd.sex\",\"返回序列,列名不能存在空格<br/>{}\".format(sd.sex).replace(\"\\n\",\"<br/>\")],\n    ['sd[\"sex\"]',\"返回序列<br/>{}\".format(sd[\"sex\"]).replace(\"\\n\",\"<br/>\")],\n    ['sd[[\"sex\"]]',\"返回数据框，数据框的任何切片返回的都是数据框<br/>{}\".format(sd[[\"sex\"]]).replace(\"\\n\",\"<br/>\")]\n],columns=[\"方法\",\"解释\"]\n)\n.set_index(\"方法\")\n.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n)"},{"path":"数据操作.html","id":"选取多列","chapter":"第5章 数据操作","heading":"5.1.1.2 选取多列","text":"","code":"(\n  pd.DataFrame(\n    [\n      ['sd[[\"name\",\"sex\"]]',\"{}\".format(sd[[\"name\",\"sex\"]]).replace(\"\\n\",\"<\/br>\")],\n],columns=[\"方法\",\"解释\"]\n)\n.set_index(\"方法\")\n.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n)"},{"path":"数据操作.html","id":"根据类型选取列","chapter":"第5章 数据操作","heading":"5.1.1.3 根据类型选取列","text":"","code":"(\nsd.select_dtypes(include=[int])\n.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n)"},{"path":"数据操作.html","id":"增加列","chapter":"第5章 数据操作","heading":"5.1.2 增加列","text":"","code":""},{"path":"数据操作.html","id":"增加一列","chapter":"第5章 数据操作","heading":"5.1.2.1 增加一列","text":"本质上是增加相同长度的序列,例外情况是当添加序列时存在对齐的情况会存在SettingWithCopyWarning, 关闭命令:pd.set_option('mode.chained_assignment', None)","code":"# 增加相同长度的序列\n# sd.newcol1 = np.random.randn(5)不允许属性方式\n# 通过计算\nsd[\"total\"] = sd.math + sd.english + sd.chinese\nsd[\"newcol2\"] = np.random.randn(5)\n# 通过序列的index对齐,最好不要这样做\nage = pd.Series([12,13,14,15],index=[1,3,5,7])\nsd[\"age\"] = age\nsd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"增加多列","chapter":"第5章 数据操作","heading":"5.1.2.2 增加多列","text":"","code":"# 直接赋值\nsd[[\"newcol3\",\"newcol4\"]] = np.ones((5,2))\nsd.iloc[:,-5:].pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"assign","chapter":"第5章 数据操作","heading":"5.1.2.3 assign","text":"assign函数的优点在于当我们并没有DataFrame的引用时，我们只需传递一个可调用对象定义一个操作链即可返回副本参数是**kwargs，既可以是等式也可以是lambda 函数（x是assigned to的数据框），函数名和表达式名是列名，（python>=3.6）,后面的参数可以引用前面的参数创造出来的列","code":"dfa = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\ndfa.assign(C=lambda x: x[\"A\"] + x[\"B\"], D=lambda x: x[\"A\"] + x[\"C\"])sd.assign(newcol5 = sd.newcol3+sd.newcol4).iloc[:,-5:].pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))sd.assign(newcol6 = lambda df:df.newcol2*df.newcol4).iloc[:,-5:].pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))#df代表操作的df"},{"path":"数据操作.html","id":"insert","chapter":"第5章 数据操作","heading":"5.1.2.4 insert","text":"可以选择位置添加列，操作原数据","code":"sd.insert(1,\"newcol1\",sd.sex)#location,name,data\nsd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"merge","chapter":"第5章 数据操作","heading":"5.1.2.5 merge","text":"pandas provides single function, merge(), entry point standard database join operations DataFrame named Series objects:howvalidate:当不满足validate设置的参数时，会发生报错\n“one_to_one” “1:1”: checks merge keys unique left right datasets.\n“one_to_many” “1:m”: checks merge keys unique left dataset.\n“many_to_one” “m:1”: checks merge keys unique right dataset.\n“many_to_many” “m:m”: allowed, result checks.\n“one_to_one” “1:1”: checks merge keys unique left right datasets.“one_to_many” “1:m”: checks merge keys unique left dataset.“many_to_one” “m:1”: checks merge keys unique right dataset.“many_to_many” “m:m”: allowed, result checks.indicator\n当设置为True时，可以添加一列表明该行的key存在于left还是right还是both都有\n当设置为字符串时，该列的名则为该字符串\n当设置为True时，可以添加一列表明该行的key存在于left还是right还是both都有当设置为字符串时，该列的名则为该字符串","code":"pd.merge(\nleft,#DataFrame or named Series\nright,#DataFrame or named Series\nhow=\"inner\",# 'left','right','outer','inner','cross'\non=None,#当left与right的关系列同名时，使用on,如果没有被传递且left_index和right_index都是False,he intersection of the columns in the DataFrames and/or Series will be inferred to be the join keys.\nleft_on=None,#left中被用作key的列名\nright_on=None,#right中被用作key的列名\nleft_index=False,#if True,index被用作key\nright_index=False,# if True,index被用作key\nsort=True,#sort by tht join key\nsuffixes=(\"_x\", \"_y\"),#当合并过后的对象仍然存在着来自两个不同对象的相同列名，可以加后缀\ncopy=True,\nindicator=False,\nvalidate=None,#检查是一对多等等\n)df1 = pd.DataFrame({\"col1\": [0, 1], \"col_left\": [\"a\", \"b\"]})\ndf2 = pd.DataFrame({\"col1\": [1, 2, 2], \"col_right\": [2, 2, 2]})\npd.merge(df1, df2, on=\"col1\", how=\"outer\", indicator=True)   col1 col_left  col_right      _merge\n0     0        a        NaN   left_only\n1     1        b        2.0        both\n2     2      NaN        2.0  right_only\n3     2      NaN        2.0  right_only"},{"path":"数据操作.html","id":"join","chapter":"第5章 数据操作","heading":"5.1.2.6 join","text":"","code":"DataFrame.join():\nleft.join(right)#按照index，how='left'的方式来join，join后索引依然是索引\n左右一个MultiIndex,一个singly-indexed，将会匹配两个index中的同名的level，所以传入的index应该有name,最后所有level都会被保存\n两边都是MultiIndex,则右边的所有level的index都会被匹配，且必须是左边的index的子集\n当两边是MultiIndex，但是只需要匹配一个时，可以result = pd.merge(left.reset_index(), right.reset_index(), on=[\"key\"], how=\"inner\").set_index([\"key\", \"X\", \"Y\"])\nleft.join(right,on=key_or_Keys)，左边的列和右边的index，保留左边的index         pd.merge(left,right,left_on=key_or_keys, right_index=True, how=\"left\", sort=False)\nleft.join(right,on=keys) 则right必须是Multiindex\nleft.join(right,lsuffix=\"_x\",rsuffix=\"_r\")#可以给两个同名列加后缀\nleft.join([right1,right2]):可以根据index合并多个DataFrame"},{"path":"数据操作.html","id":"替换列","chapter":"第5章 数据操作","heading":"5.1.3 替换列","text":"利用增加同名列替换列","code":"sd[\"sex\"] = sd.sex.map({\"男\":\"men\",\"女\":\"women\"})\nsd.iloc[:,:5].pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"删除列","chapter":"第5章 数据操作","heading":"5.1.4 删除列","text":"","code":""},{"path":"数据操作.html","id":"del","chapter":"第5章 数据操作","heading":"5.1.4.1 del","text":"","code":"del sd[\"newcol4\"]#直接删除\n# del sd.newcol3 不支持属性"},{"path":"数据操作.html","id":"dropaxis","chapter":"第5章 数据操作","heading":"5.1.4.2 .drop(axis)","text":"使用drop方法一定要指定axis，返回副本","code":"sd.drop([\"newcol2\",\"newcol3\"],axis=1).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))#返回副本"},{"path":"数据操作.html","id":"pop","chapter":"第5章 数据操作","heading":"5.1.4.3 .pop()","text":"删除列，并且返回列，0 1.0\n1 1.0\n2 1.0\n3 1.0\n4 1.0\nName: newcol3, dtype: float64","code":"sd.pop(\"newcol3\")sd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))del sd[\"newcol2\"]\ndel sd[\"newcol1\"]"},{"path":"数据操作.html","id":"行","chapter":"第5章 数据操作","heading":"5.2 行","text":"","code":""},{"path":"数据操作.html","id":"选取行","chapter":"第5章 数据操作","heading":"5.2.1 选取行","text":"选取的行的索引就是原数据的索引，不会重新自然排列.","code":""},{"path":"数据操作.html","id":"直接选取","chapter":"第5章 数据操作","heading":"5.2.1.1 直接选取","text":"可以直接利用切片选择行","code":"sd[:1]#选取第一行  name  sex   class  math  chinese  english  total  age\n0   a1  men  高一(1)班    61       59       70    190  NaNsd.loc[0]#根据行标签name           a1\nsex           men\nclass      高一(1)班\nmath           61\nchinese        59\nenglish        70\ntotal         190\nage           NaN\nName: 0, dtype: objectsd.iloc[0]#根据行位置name           a1\nsex           men\nclass      高一(1)班\nmath           61\nchinese        59\nenglish        70\ntotal         190\nage           NaN\nName: 0, dtype: objectsd.iloc[0:3]  name    sex   class  math  chinese  english  total   age\n0   a1    men  高一(1)班    61       59       70    190   NaN\n1   a2  women  高一(2)班    62       77       74    213  12.0\n2   a3  women  高一(3)班    58       71       83    212   NaN"},{"path":"数据操作.html","id":"take","chapter":"第5章 数据操作","heading":"5.2.1.2 .take()","text":"","code":"s.take([[0,1,3]])\ndf.take([1,4,3])\nfrm.take([0,2],axis=1)\n不支持Boolean indicessd.take([0,1]).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"逻辑选取","chapter":"第5章 数据操作","heading":"5.2.1.3 逻辑选取","text":"注意逻辑选取后的索引不会编程自然索引，依然保持原索引","code":"sd[sd.math > 80]Empty DataFrame\nColumns: [name, sex, class, math, chinese, english, total, age]\nIndex: []sd[[True,False,True,False,True]]  name    sex   class  math  chinese  english  total  age\n0   a1    men  高一(1)班    61       59       70    190  NaN\n2   a3  women  高一(3)班    58       71       83    212  NaN\n4   a5    men  高一(5)班    56       83       72    211  NaN"},{"path":"数据操作.html","id":"query","chapter":"第5章 数据操作","heading":"5.2.1.4 .query()","text":"query也是逻辑选取，但是可以用简便的语言操作比较复杂的逻辑，以字符串的形式设置条件使用query()的情况:当有很多个表格有着相同的列名，需要进行相同的操作，则可以map(lambda frame: frame.query(expr), [df, df2])","code":"df.query('a<b and b<c')\ndf.query('index_name<column_name')#当index_name与column name重名时，优先考虑index_name\ndf.query('index < column_name')\ndf.query('ilevel_0 == ')#means “index level 0” for the 0th level of the index\ndf.query('a in b') == df[df['a'].isin(df['b')]\ndf.query('a == ['a','b','c']') == df[df['a'].isin(['a','b','c])]# !=\ndf.query('~bools')"},{"path":"数据操作.html","id":"增加行","chapter":"第5章 数据操作","heading":"5.2.2 增加行","text":"append方法不能用了，主要就是为了增加数据集。","code":""},{"path":"数据操作.html","id":"concat","chapter":"第5章 数据操作","heading":"5.2.2.1 .concat()","text":"根据列名或行名触发对齐机制,返回副本.concat():沿着某条轴，合并DataFrame或Series，默认沿着行合并，index合并，轴标签取union\naxis:{0,1,…}\njoin:{‘inner’,‘outer’}\ndefault:outer union；inner:intersection\nignore_index:default False ,设置为真时，原有concatenation axis上的value不被使用，重设为0,…,n-1\nkeys:Construct hierarchical index using passed keys outermost level.可以标识数据是从那个原数据合并过来的\nlevels:list sequences, default None. Specific levels (unique values) use constructing MultiIndex. Otherwise inferred keys.\nnames:names levels resulting hirechical index\naxis:{0,1,…}join:{‘inner’,‘outer’}default:outer union；inner:intersectionignore_index:default False ,设置为真时，原有concatenation axis上的value不被使用，重设为0,…,n-1keys:Construct hierarchical index using passed keys outermost level.可以标识数据是从那个原数据合并过来的levels:list sequences, default None. Specific levels (unique values) use constructing MultiIndex. Otherwise inferred keys.names:names levels resulting hirechical index","code":"pd.concat(\n  [sd,pd.DataFrame([[\"a6\",\"add\"]],columns=[\"name\",\"notexist\"])],\n  axis =0\n).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"替换行","chapter":"第5章 数据操作","heading":"5.2.3 替换行","text":"","code":"sd[4:5] = sd[3:4]\nsd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"删除行","chapter":"第5章 数据操作","heading":"5.2.4 删除行","text":"","code":"sd.drop(4,axis=0)  name    sex   class  math  chinese  english  total   age\n0   a1    men  高一(1)班    61       59       70    190   NaN\n1   a2  women  高一(2)班    62       77       74    213  12.0\n2   a3  women  高一(3)班    58       71       83    212   NaN\n3   a4    men  高一(4)班    65       57       71    193  13.0"},{"path":"数据操作.html","id":"任意值scalar","chapter":"第5章 数据操作","heading":"5.3 任意值/scalar","text":"也就是行索引和列索引的组合","code":""},{"path":"数据操作.html","id":"ilocloc","chapter":"第5章 数据操作","heading":"5.3.1 .iloc/loc","text":".loc\n.loc[‘’]\n.loc[[‘’,‘b’,‘c’]]:至少有一个不存在时，报错，即必须全部是标签\n.loc[‘’:‘f’]\n当’’和’f’标签都存在时，返回二者之间的elements\n当’’和’f’中有一个存在，且按照规则排序好，则返回排序在二者之间的\n当至少有一个不存在，且index没有排序好，则会报错\n当有duplicate labels,且“”,’f’中有duplicate label，则报错\n\n.loc[boolean array]：df.loc[:,df.loc[‘’]>0],NA算作False\n.loc[func]:df.loc[:,lambda df:['','B']],df.loc[lambda df:df[\"\"]>0,:]\nlambda中的df代表新创建出来的df，这样我们就可以使用链式的方法\n  bb = pd.read_csv('data/baseball.csv', index_col='id')\n  (bb.groupby(['year', 'team']).sum()\n     .loc[lambda df: df['r'] > 100])#df指代新创建出来的df\n\n.loc[‘’].loc[[‘’,‘b’,‘c’]]:至少有一个不存在时，报错，即必须全部是标签.loc[‘’:‘f’]\n当’’和’f’标签都存在时，返回二者之间的elements\n当’’和’f’中有一个存在，且按照规则排序好，则返回排序在二者之间的\n当至少有一个不存在，且index没有排序好，则会报错\n当有duplicate labels,且“”,’f’中有duplicate label，则报错\n当’’和’f’标签都存在时，返回二者之间的elements当’’和’f’中有一个存在，且按照规则排序好，则返回排序在二者之间的当至少有一个不存在，且index没有排序好，则会报错当有duplicate labels,且“”,’f’中有duplicate label，则报错.loc[boolean array]：df.loc[:,df.loc[‘’]>0],NA算作False.loc[func]:df.loc[:,lambda df:['','B']],df.loc[lambda df:df[\"\"]>0,:]\nlambda中的df代表新创建出来的df，这样我们就可以使用链式的方法\n  bb = pd.read_csv('data/baseball.csv', index_col='id')\n  (bb.groupby(['year', 'team']).sum()\n     .loc[lambda df: df['r'] > 100])#df指代新创建出来的df\nlambda中的df代表新创建出来的df，这样我们就可以使用链式的方法\n  bb = pd.read_csv('data/baseball.csv', index_col='id')\n  (bb.groupby(['year', 'team']).sum()\n     .loc[lambda df: df['r'] > 100])#df指代新创建出来的dflambda中的df代表新创建出来的df，这样我们就可以使用链式的方法.iloc:不可以超出索引值\n.iloc[1]\n.iloc[[1,3,5]\n.iloc[1:3]\n.iloc[boolean array]\n.iloc[func]\n.iloc[1].iloc[[1,3,5].iloc[1:3].iloc[boolean array].iloc[func]Note:\npandas aligns AXES setting Series DataFrame .loc, .iloc.modify df column alignment value assignment.\npandas aligns AXES setting Series DataFrame .loc, .iloc.modify df column alignment value assignment.","code":"  bb = pd.read_csv('data/baseball.csv', index_col='id')\n  (bb.groupby(['year', 'team']).sum()\n     .loc[lambda df: df['r'] > 100])#df指代新创建出来的df"},{"path":"数据操作.html","id":"iatat","chapter":"第5章 数据操作","heading":"5.3.2 .iat/at","text":"快速取标量值","code":"s = pd.Series([0, 1, 2, 3, 4, 5])\ns.iat[5]\ndf.at[2,'b']\ndf.iat[2,1]"},{"path":"数据操作.html","id":"wheremask","chapter":"第5章 数据操作","heading":"5.3.3 where/mask","text":".()方法与boolean array方法不同点在于where返回的对象形状与 原对象相同，条件不满足的地方用NaN填补\n.mask()方法是.()的逆方法，满足条件的被maskSeries:s,(s>0)DataFrame:df.(df<0,-df)-df当条件不满足时用-df中相应位置的值填补，== np.(df>0,df,-df)\ninplace=True:直接修改原数据，默认不修改\naxis,level:df2.(df2>0,df2[‘’],axis=‘index’) == df2.apply(lambda x,y:x.(x>0,y),y=df2[‘’])\naccept callable condition arguments:df3.(lambda x: x > 4, lambda x: x + 10) x代表df3\ninplace=True:直接修改原数据，默认不修改axis,level:df2.(df2>0,df2[‘’],axis=‘index’) == df2.apply(lambda x,y:x.(x>0,y),y=df2[‘’])accept callable condition arguments:df3.(lambda x: x > 4, lambda x: x + 10) x代表df3","code":""},{"path":"数据操作.html","id":"索引","chapter":"第5章 数据操作","heading":"5.4 索引","text":"pandas对象的轴标签有着很多作用identifies data(比如，metadata元数据)自动和明确的数据对齐可以直观的获取和设置数据集的子集","code":""},{"path":"数据操作.html","id":"索引name","chapter":"第5章 数据操作","heading":"5.4.1 索引name","text":"","code":""},{"path":"数据操作.html","id":"通过indexcolumns属性","chapter":"第5章 数据操作","heading":"5.4.1.1 通过index/columns属性","text":"","code":"sd.indexRangeIndex(start=0, stop=5, step=1)sd.index.name = \"ind\"\nsd.indexRangeIndex(start=0, stop=5, step=1, name='ind')"},{"path":"数据操作.html","id":"rename_axis","chapter":"第5章 数据操作","heading":"5.4.1.2 .rename_axis()","text":"返回副本","code":"sd.rename_axis(index={\"ind\":\"newind\"})       name    sex   class  math  chinese  english  total   age\nnewind                                                         \n0        a1    men  高一(1)班    61       59       70    190   NaN\n1        a2  women  高一(2)班    62       77       74    213  12.0\n2        a3  women  高一(3)班    58       71       83    212   NaN\n3        a4    men  高一(4)班    65       57       71    193  13.0\n4        a4    men  高一(4)班    65       57       71    193  13.0"},{"path":"数据操作.html","id":"重排序","chapter":"第5章 数据操作","heading":"5.4.2 重排序","text":".reindex(),可同时对index和columns进行重排序.reindex()\n重新排序\n当新标签不是已有标签时，插入空值\nSeries.reindex()\ndf.reindex(index=,columns=)\n重新排序当新标签不是已有标签时，插入空值Series.reindex()df.reindex(index=,columns=)shared index:df1.reindex(df2.index,axis=“index”)#两个DataFrame的index是同一个对象.reindex_like()\ndf.reindex_like(df2)#把index和column设置的和df2一样\ndf.reindex_like(df2)#把index和column设置的和df2一样","code":"sd.reindex([0,4,2,3,1]).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"重命名","chapter":"第5章 数据操作","heading":"5.4.3 重命名","text":"","code":""},{"path":"数据操作.html","id":"index.columns","chapter":"第5章 数据操作","heading":"5.4.3.1 .index/.columns","text":"必须全体重新命名，直接对原函数操作，传递同等长度的序列","code":"source_col = sd.columns\nsd.index = range(5)\nsd.columns = range(sd.shape[1])\nsd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"rename","chapter":"第5章 数据操作","heading":"5.4.3.2 .rename()","text":"返回副本，可以设置inplace=True修改原数据，可以对单个索引名称更改，要指定对应关系.rename:对原有的名称改名，被map的原有名称改名，非原有名称的map不会报错，没有被map的原有名称不变\n可以把column map（dict Series）\n或者传递任意函数，但是要返回一系列唯一值\n数据框要指定index,columns\n可以把column map（dict Series）或者传递任意函数，但是要返回一系列唯一值数据框要指定index,columns","code":"sd.rename(index=lambda x:x+1,\ncolumns={0:\"zero\",6:\"six\"},inplace=True)\nsd.pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"数据操作.html","id":"map-1","chapter":"第5章 数据操作","heading":"5.4.3.3 .map()","text":"sd.index = sd.index.map()","code":"sd.index = range(5)\nsd.columns = source_col"},{"path":"数据操作.html","id":"设置列为索引","chapter":"第5章 数据操作","heading":"5.4.4 设置列为索引","text":".set_index(),默认返回副本,默认替代原索引，默认删除原列","code":"sd.set_index(\"sex\")      name   class  math  chinese  english  total   age\nsex                                                    \nmen     a1  高一(1)班    61       59       70    190   NaN\nwomen   a2  高一(2)班    62       77       74    213  12.0\nwomen   a3  高一(3)班    58       71       83    212   NaN\nmen     a4  高一(4)班    65       57       71    193  13.0\nmen     a4  高一(4)班    65       57       71    193  13.0"},{"path":"数据操作.html","id":"重置索引","chapter":"第5章 数据操作","heading":"5.4.5 重置索引","text":"默认将原索引变为列，设置drop=True不变成列","code":"sd.set_index(\"sex\").reset_index(drop=True)  name   class  math  chinese  english  total   age\n0   a1  高一(1)班    61       59       70    190   NaN\n1   a2  高一(2)班    62       77       74    213  12.0\n2   a3  高一(3)班    58       71       83    212   NaN\n3   a4  高一(4)班    65       57       71    193  13.0\n4   a4  高一(4)班    65       57       71    193  13.0"},{"path":"数据操作.html","id":"多层索引","chapter":"第5章 数据操作","heading":"5.4.6 多层索引","text":"rename,reset_index,reindex都可以根据level参数指定对那层的索引操作。","code":"import itertools\nhindex = pd.MultiIndex.from_tuples(itertools.product([\"one\",\"two\"],[1,2]))\nhcolumns = pd.MultiIndex.from_tuples(itertools.product([\"A\",\"B\"],[\"a\",\"b\"]))\nmulti_index = pd.DataFrame(np.random.randn(16).reshape(4,4),\nindex = hindex,\ncolumns = hcolumns\n) \nmulti_index              A                   B          \n              a         b         a         b\none 1  0.590097 -0.354386  1.005761 -0.231100\n    2  0.601155  0.971925  0.333989 -0.070636\ntwo 1  0.832014 -1.078967 -1.278030  0.014034\n    2  0.673027 -0.324423  1.158443  0.568625"},{"path":"数据操作.html","id":"轴name","chapter":"第5章 数据操作","heading":"5.4.6.1 轴name","text":"","code":"multi_index.index.names = [\"font\",\"number\"]\nmulti_index.columns.names = [\"upper\",\"lower\"]\nmulti_indexupper               A                   B          \nlower               a         b         a         b\nfont number                                        \none  1       0.590097 -0.354386  1.005761 -0.231100\n     2       0.601155  0.971925  0.333989 -0.070636\ntwo  1       0.832014 -1.078967 -1.278030  0.014034\n     2       0.673027 -0.324423  1.158443  0.568625multi_index.rename_axis(columns = {\"upper\":\"UPPER\"})UPPER               A                   B          \nlower               a         b         a         b\nfont number                                        \none  1       0.590097 -0.354386  1.005761 -0.231100\n     2       0.601155  0.971925  0.333989 -0.070636\ntwo  1       0.832014 -1.078967 -1.278030  0.014034\n     2       0.673027 -0.324423  1.158443  0.568625"},{"path":"数据操作.html","id":"获取轴","chapter":"第5章 数据操作","heading":"5.4.6.2 获取轴","text":"MultiIndex.get_level_values","code":"multi_index.indexMultiIndex([('one', 1),\n            ('one', 2),\n            ('two', 1),\n            ('two', 2)],\n           names=['font', 'number'])multi_index.columnsMultiIndex([('A', 'a'),\n            ('A', 'b'),\n            ('B', 'a'),\n            ('B', 'b')],\n           names=['upper', 'lower'])multi_index.index.get_level_values(0)Index(['one', 'one', 'two', 'two'], dtype='object', name='font')"},{"path":"数据操作.html","id":"选取多层索引","chapter":"第5章 数据操作","heading":"5.4.7 选取多层索引","text":"","code":""},{"path":"数据操作.html","id":"xs","chapter":"第5章 数据操作","heading":"5.4.7.1 .xs","text":"选取行或列","code":".xs(\n  key:label or tuple of label\n  axis: 默认0，行\n  level: first n levels n=1 or len(key)\n)multi_index.xs(\"one\")#可以直接选取最外层的keyupper          A                   B          \nlower          a         b         a         b\nnumber                                        \n1       0.590097 -0.354386  1.005761 -0.231100\n2       0.601155  0.971925  0.333989 -0.070636multi_index.xs((\"one\",1))#用tuple，不要用listupper  lower\nA      a        0.590097\n       b       -0.354386\nB      a        1.005761\n       b       -0.231100\nName: (one, 1), dtype: float64multi_index.xs(1,level=1)#直接选取内层的需要指定levelupper         A                   B          \nlower         a         b         a         b\nfont                                         \none    0.590097 -0.354386  1.005761 -0.231100\ntwo    0.832014 -1.078967 -1.278030  0.014034"},{"path":"数据操作.html","id":"loc","chapter":"第5章 数据操作","heading":"5.4.7.2 .loc","text":"任意选取行列","code":"multi_index.loc[\"one\"]upper          A                   B          \nlower          a         b         a         b\nnumber                                        \n1       0.590097 -0.354386  1.005761 -0.231100\n2       0.601155  0.971925  0.333989 -0.070636multi_index.loc[\"one\",1]upper  lower\nA      a        0.590097\n       b       -0.354386\nB      a        1.005761\n       b       -0.231100\nName: (one, 1), dtype: float64multi_index.loc[[\"one\"]]upper               A                   B          \nlower               a         b         a         b\nfont number                                        \none  1       0.590097 -0.354386  1.005761 -0.231100\n     2       0.601155  0.971925  0.333989 -0.070636multi_index.loc[(\"one\",1),\"A\"]lower\na    0.590097\nb   -0.354386\nName: (one, 1), dtype: float64"},{"path":"数据操作.html","id":"section","chapter":"第5章 数据操作","heading":"5.4.7.3 ","text":"只能选取列","code":"multi_index[\"A\"]lower               a         b\nfont number                    \none  1       0.590097 -0.354386\n     2       0.601155  0.971925\ntwo  1       0.832014 -1.078967\n     2       0.673027 -0.324423multi_index[\"A\",\"a\"]font  number\none   1         0.590097\n      2         0.601155\ntwo   1         0.832014\n      2         0.673027\nName: (A, a), dtype: float64multi_index[[\"A\"]]upper               A          \nlower               a         b\nfont number                    \none  1       0.590097 -0.354386\n     2       0.601155  0.971925\ntwo  1       0.832014 -1.078967\n     2       0.673027 -0.324423"},{"path":"数据操作.html","id":"同时选取行和列","chapter":"第5章 数据操作","heading":"5.4.7.4 同时选取行和列","text":"除了.loc方法,可以进行组合","code":"multi_index.loc[\"one\"][\"A\"]lower          a         b\nnumber                    \n1       0.590097 -0.354386\n2       0.601155  0.971925"},{"path":"数据操作.html","id":"调换多个index的顺序","chapter":"第5章 数据操作","heading":"5.4.8 调换多个index的顺序","text":"返回副本，可以指定axis","code":"multi_index.swaplevel()#调换最内层的两个indexupper               A                   B          \nlower               a         b         a         b\nnumber font                                        \n1      one   0.590097 -0.354386  1.005761 -0.231100\n2      one   0.601155  0.971925  0.333989 -0.070636\n1      two   0.832014 -1.078967 -1.278030  0.014034\n2      two   0.673027 -0.324423  1.158443  0.568625multi_index.swaplevel(0)#直接调换到最内层upper               A                   B          \nlower               a         b         a         b\nnumber font                                        \n1      one   0.590097 -0.354386  1.005761 -0.231100\n2      one   0.601155  0.971925  0.333989 -0.070636\n1      two   0.832014 -1.078967 -1.278030  0.014034\n2      two   0.673027 -0.324423  1.158443  0.568625multi_index.swaplevel(\"upper\",axis=1)lower               a         b         a         b\nupper               A         A         B         B\nfont number                                        \none  1       0.590097 -0.354386  1.005761 -0.231100\n     2       0.601155  0.971925  0.333989 -0.070636\ntwo  1       0.832014 -1.078967 -1.278030  0.014034\n     2       0.673027 -0.324423  1.158443  0.568625multi_index.swaplevel(0,1)#调换这两个level的indexupper               A                   B          \nlower               a         b         a         b\nnumber font                                        \n1      one   0.590097 -0.354386  1.005761 -0.231100\n2      one   0.601155  0.971925  0.333989 -0.070636\n1      two   0.832014 -1.078967 -1.278030  0.014034\n2      two   0.673027 -0.324423  1.158443  0.568625"},{"path":"数据操作.html","id":"index和column的互换","chapter":"第5章 数据操作","heading":"5.4.9 index和column的互换","text":"","code":""},{"path":"数据操作.html","id":"stack","chapter":"第5章 数据操作","heading":"5.4.9.1 .stack()","text":"堆叠，堆叠以常识理解肯定指的上下结构，但是这里指的是左右的堆叠,或者我们可以理解为该index自己变成了列形式，所以较stack","code":"multi_index.stack(0)<string>:1: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.\nlower                     a         b\nfont number upper                    \none  1      A      0.590097 -0.354386\n            B      1.005761 -0.231100\n     2      A      0.601155  0.971925\n            B      0.333989 -0.070636\ntwo  1      A      0.832014 -1.078967\n            B     -1.278030  0.014034\n     2      A      0.673027 -0.324423\n            B      1.158443  0.568625multi_index.stack(\"upper\")<string>:1: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.\nlower                     a         b\nfont number upper                    \none  1      A      0.590097 -0.354386\n            B      1.005761 -0.231100\n     2      A      0.601155  0.971925\n            B      0.333989 -0.070636\ntwo  1      A      0.832014 -1.078967\n            B     -1.278030  0.014034\n     2      A      0.673027 -0.324423\n            B      1.158443  0.568625multi_index.stack([\"upper\",\"lower\"])<string>:1: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.\nfont  number  upper  lower\none   1       A      a        0.590097\n                     b       -0.354386\n              B      a        1.005761\n                     b       -0.231100\n      2       A      a        0.601155\n                     b        0.971925\n              B      a        0.333989\n                     b       -0.070636\ntwo   1       A      a        0.832014\n                     b       -1.078967\n              B      a       -1.278030\n                     b        0.014034\n      2       A      a        0.673027\n                     b       -0.324423\n              B      a        1.158443\n                     b        0.568625\ndtype: float64"},{"path":"数据操作.html","id":"unstack","chapter":"第5章 数据操作","heading":"5.4.9.2 .unstack()","text":"取消堆叠，即将行索引变成列索引","code":"multi_index.unstack(-1)upper          A                      ...         B                    \nlower          a                   b  ...         a         b          \nnumber         1         2         1  ...         2         1         2\nfont                                  ...                              \none     0.590097  0.601155 -0.354386  ...  0.333989 -0.231100 -0.070636\ntwo     0.832014  0.673027 -1.078967  ...  1.158443  0.014034  0.568625\n\n[2 rows x 8 columns]"},{"path":"数据操作.html","id":"排序","chapter":"第5章 数据操作","heading":"5.5 排序","text":"","code":""},{"path":"数据操作.html","id":"sort_index根据标签排序","chapter":"第5章 数据操作","heading":"5.5.1 .sort_index():根据标签排序","text":"axis:对于df来说,默认为0ascending:默认升序，值为Truekey:根据作用于每一个元素的函数返回值来排序，lambda x:x,x指代每一个元素level:对于MultiIndex objects，可以设置level属性,level=“”:索引名","code":""},{"path":"数据操作.html","id":"sort_values根据值排序","chapter":"第5章 数据操作","heading":"5.5.2 .sort_values():根据值排序","text":"Series:\nkey:\nkey:DataFrame:\n:scalar ,确定用于排序的一个或多个列\nkey:\n:scalar ,确定用于排序的一个或多个列key:index values:\n对于一个多层索引，我们按索引和值同时排序,比如先按索引排序，然后对每个索引的内部值再按值排序\n对于一个多层索引，我们按索引和值同时排序,比如先按索引排序，然后对每个索引的内部值再按值排序sorting MultiIndex column\n.sort_values(=(“”,“two”)\n.sort_values(=(“”,“two”)","code":""},{"path":"数据操作.html","id":"nlargest.nsmallest","chapter":"第5章 数据操作","heading":"5.5.3 .nlargest(),.nsmallest()","text":"","code":"* df.nlargest(5,[\"a\",\"c\"])#先按照a排序，在按照c排序"},{"path":"数据操作.html","id":"数学运算","chapter":"第5章 数据操作","heading":"5.6 数学运算","text":"","code":""},{"path":"数据操作.html","id":"序列或数据框","chapter":"第5章 数据操作","heading":"5.6.1 序列或数据框","text":"直接使用numpy函数对整体进行操作","code":"np.floor(sd.math)0    61.0\n1    62.0\n2    58.0\n3    65.0\n4    65.0\nName: math, dtype: float64np.round(sd[[\"math\"]])   math\n0    61\n1    62\n2    58\n3    65\n4    65"},{"path":"数据操作.html","id":"同维度的序列","chapter":"第5章 数据操作","heading":"5.6.2 同维度的序列","text":"依照对齐机制进行算数运算和比较","code":""},{"path":"数据操作.html","id":"数学运算-1","chapter":"第5章 数据操作","heading":"5.6.2.1 数学运算","text":"加减乘除,取负值","code":"sd.math + sd.english0    131\n1    136\n2    141\n3    136\n4    136\ndtype: int64-sd.math0   -61\n1   -62\n2   -58\n3   -65\n4   -65\nName: math, dtype: int64"},{"path":"数据操作.html","id":"逻辑运算","chapter":"第5章 数据操作","heading":"5.6.2.2 逻辑运算","text":"","code":"sd.math > sd.english0    False\n1    False\n2    False\n3    False\n4    False\ndtype: bool(sd.math > sd.english) & (sd.math < sd.chinese)0    False\n1    False\n2    False\n3    False\n4    False\ndtype: bool"},{"path":"数据操作.html","id":"序列和标量","chapter":"第5章 数据操作","heading":"5.6.3 序列和标量","text":"","code":""},{"path":"数据操作.html","id":"数学运算-2","chapter":"第5章 数据操作","heading":"5.6.3.1 数学运算","text":"加减乘除","code":"sd.math + 30    64\n1    65\n2    61\n3    68\n4    68\nName: math, dtype: int64"},{"path":"数据操作.html","id":"逻辑运算-1","chapter":"第5章 数据操作","heading":"5.6.3.2 逻辑运算","text":"","code":"sd.math > 800    False\n1    False\n2    False\n3    False\n4    False\nName: math, dtype: bool(sd.math > 80) & (sd.math < 90)0    False\n1    False\n2    False\n3    False\n4    False\nName: math, dtype: bool"},{"path":"数据操作.html","id":"同维度的数据框","chapter":"第5章 数据操作","heading":"5.6.4 同维度的数据框","text":"数学运算和逻辑运算都按照列名对齐","code":""},{"path":"数据操作.html","id":"数学运算-3","chapter":"第5章 数据操作","heading":"5.6.4.1 数学运算","text":"加减乘除,取负值","code":"sd[[\"math\",\"english\"]] + sd[[\"math\",\"english\"]]   math  english\n0   122      140\n1   124      148\n2   116      166\n3   130      142\n4   130      142"},{"path":"数据操作.html","id":"逻辑运算-2","chapter":"第5章 数据操作","heading":"5.6.4.2 逻辑运算","text":"","code":"sd[[\"math\",\"english\"]] > 80    math  english\n0  False    False\n1  False    False\n2  False     True\n3  False    False\n4  False    False(sd[[\"math\",\"english\"]] > 80) & (sd[[\"math\",\"chinese\"]] < 90)   chinese  english   math\n0      NaN      NaN  False\n1      NaN      NaN  False\n2      NaN      NaN  False\n3      NaN      NaN  False\n4      NaN      NaN  False"},{"path":"数据操作.html","id":"使用numpy","chapter":"第5章 数据操作","heading":"5.6.4.3 使用numpy","text":"","code":"np.power(sd[[\"english\",\"math\",\"chinese\"]],np.random.randint(5,size=(sd.shape[0],3)))   english      math   chinese\n0       70  13845841  12117361\n1       74         1    456533\n2        1    195112        71\n3   357911        65  10556001\n4        1  17850625        57"},{"path":"数据操作.html","id":"数据框和标量","chapter":"第5章 数据操作","heading":"5.6.5 数据框和标量","text":"和序列同样","code":""},{"path":"数据操作.html","id":"数据框和序列","chapter":"第5章 数据操作","heading":"5.6.6 数据框和序列","text":"默认按照列名对齐，可以进行算数操作和逻辑操作","code":"sd[[\"math\",\"english\"]] - sd[[\"math\",\"english\"]].iloc[-1]   math  english\n0    -4       -1\n1    -3        3\n2    -7       12\n3     0        0\n4     0        0sd[[\"math\",\"english\"]] > sd[[\"math\",\"english\"]].iloc[-1]    math  english\n0  False    False\n1  False     True\n2  False     True\n3  False    False\n4  False    False"},{"path":"数据操作.html","id":"统计方法","chapter":"第5章 数据操作","heading":"5.7 统计方法","text":"对于数据框来说，它的sum，min等聚合函数可以选择axis，甚至可以选择index来聚合,但是不能再指定level了。value_counts如果传递多列，则返回多列的组合值的value_counts(),多列以multi_index展示.","code":"multi_index.sum(axis=0)upper  lower\nA      a        2.696292\n       b       -0.785851\nB      a        1.220162\n       b        0.280924\ndtype: float64"},{"path":"数据操作.html","id":"相关和协方差","chapter":"第5章 数据操作","heading":"5.7.1 相关和协方差","text":"","code":""},{"path":"数据操作.html","id":"函数","chapter":"第5章 数据操作","heading":"5.8 函数","text":"对行或者列或者整体或者每个元素进行函数应用。","code":""},{"path":"数据操作.html","id":"apply","chapter":"第5章 数据操作","heading":"5.8.1 .apply()","text":"对行或列操作，操作对象默认为序列,但是不能应用多个函数,不能指定对象，长度变不变都可以。.apply(func,axis):\narg\nfunc:可以是函数，也可以是字符串形式的名称，如“mean”,也可以是一些Series方法，如pd.Series.interpolate，\naxis:确定沿着那条轴应用函数\nargs:iterable,func中的参数，以形参形式给出\n**kwargs：func中的参数，以关键字形式给出\nraw:默认False，会在应用函数之前把每row或column转换成Series，设置为True，则当成ndarray处理\n\nreturn:\nfunc返回Series，则最终输出是一个DataFrame\nfunc返回其他任何类型，最终输出是一个Series\n\narg\nfunc:可以是函数，也可以是字符串形式的名称，如“mean”,也可以是一些Series方法，如pd.Series.interpolate，\naxis:确定沿着那条轴应用函数\nargs:iterable,func中的参数，以形参形式给出\n**kwargs：func中的参数，以关键字形式给出\nraw:默认False，会在应用函数之前把每row或column转换成Series，设置为True，则当成ndarray处理\nfunc:可以是函数，也可以是字符串形式的名称，如“mean”,也可以是一些Series方法，如pd.Series.interpolate，axis:确定沿着那条轴应用函数args:iterable,func中的参数，以形参形式给出**kwargs：func中的参数，以关键字形式给出raw:默认False，会在应用函数之前把每row或column转换成Series，设置为True，则当成ndarray处理return:\nfunc返回Series，则最终输出是一个DataFrame\nfunc返回其他任何类型，最终输出是一个Series\nfunc返回Series，则最终输出是一个DataFramefunc返回其他任何类型，最终输出是一个Series","code":""},{"path":"数据操作.html","id":"agg","chapter":"第5章 数据操作","heading":"5.8.2 .agg()","text":"只对列起作用,可以指定对象，可以指定多个函数,只能执行聚合操作，操作对象为序列，长度会发生变化.agg([“sum”])#对每一列作用函数.agg([“sum”,“mean”])#对每一列作用多个函数\n.agg([“sum”,lambda x:x.mean()])#lambda函数的名lambda\n.agg([“sum”,func])#自定义函数的名为该函数名\n.agg({“”:[“sum”,“mean”],“B”:[“median”]})#为不同的列定义不同的函数,顺序不被确定，可以用OrderedDict类\n当混合类型中的某些列不能作用函数时，将不会作用\n.agg([“sum”,lambda x:x.mean()])#lambda函数的名lambda.agg([“sum”,func])#自定义函数的名为该函数名.agg({“”:[“sum”,“mean”],“B”:[“median”]})#为不同的列定义不同的函数,顺序不被确定，可以用OrderedDict类当混合类型中的某些列不能作用函数时，将不会作用","code":""},{"path":"数据操作.html","id":"transform","chapter":"第5章 数据操作","heading":"5.8.3 .transform()","text":"应用于所有元素，也可以传递字典对不同的列的每个元素应用不同的函数,操作对象为数据框。长度必须保持不变。\n.transform() allows input functions : NumPy function, string function name user defined function.\nPassing multiple functions yield column MultiIndexed DataFrame. first level original frame column names; second level names transforming functions.\nPassing multiple functions Series yield DataFrame. resulting column names transforming functions.\n.transform() allows input functions : NumPy function, string function name user defined function.Passing multiple functions yield column MultiIndexed DataFrame. first level original frame column names; second level names transforming functions.Passing multiple functions Series yield DataFrame. resulting column names transforming functions.","code":""},{"path":"数据操作.html","id":"applymap","chapter":"第5章 数据操作","heading":"5.8.4 .applymap()","text":"应用于每个单元格,只能定义一个函数","code":""},{"path":"数据操作.html","id":"pipe","chapter":"第5章 数据操作","heading":"5.8.5 .pipe()","text":"对整个数据框进行任意操作DataFrames和Series是可以传递给函数的，但是如果函数是在一个链式中，考虑使用pipe()方法function(df,arg1) 则df.pipe(func,arg1) df默认以第一参数传递给funcfunction(arg1,data) 则需要把func和代表data的关键字写在一起形成关键字对,如df.pipe((func,“data”),agr1)","code":""},{"path":"数据操作.html","id":"透视表","chapter":"第5章 数据操作","heading":"5.9 透视表","text":"透视表","code":""},{"path":"数据操作.html","id":"pivot","chapter":"第5章 数据操作","heading":"5.9.1 .pivot()","text":"index.columns,value 都可以是列名或列名的列表，当value为列表时，会形成column的stack，相当于分别计算每个列的pivot，然后再左右concat。","code":"df = pd.DataFrame({'foo': ['one', 'one', 'one', 'two', 'two',\n                      'two'],\n                  'bar': ['A', 'B', 'C', 'A', 'B', 'C'],\n                   'baz': [1, 2, 3, 4, 5, 6],\n                 'zoo': ['x', 'y', 'z', 'q', 'w', 't']})\npivot_df = df.pivot(index='foo', columns='bar', values=['baz', 'zoo'])\npivot_df    baz       zoo      \nbar   A  B  C   A  B  C\nfoo                    \none   1  2  3   x  y  z\ntwo   4  5  6   q  w  t"},{"path":"数据操作.html","id":"pivot_table","chapter":"第5章 数据操作","heading":"5.9.2 .pivot_table()","text":".pivot_table()/DataFrame().pivot_table():唯一的特点是可以应用函数\ndata:\nvalues:column list columns ，如果不给，则剩下的所有非index和column的列都被视作value\nindex:column, Grouper, array length data, list . Keys group pivot table index. array passed, used manner column values.\ncolumns:同index\naggfunc: function use aggregation, defaulting numpy.mean.\nmargins:pass margins=True pivot_table, special columns rows added partial group aggregates across categories rows columns:\nmargins_name\nfill_value: scalar\ndata:values:column list columns ，如果不给，则剩下的所有非index和column的列都被视作valueindex:column, Grouper, array length data, list . Keys group pivot table index. array passed, used manner column values.columns:同indexaggfunc: function use aggregation, defaulting numpy.mean.margins:pass margins=True pivot_table, special columns rows added partial group aggregates across categories rows columns:margins_namefill_value: scalar","code":""},{"path":"数据操作.html","id":"pd.crosstab","chapter":"第5章 数据操作","heading":"5.9.3 pd.crosstab()","text":"和pivot_table()没有太大区别,但是传递的是序列,并不是dataframe方法.默认返回频次.","code":""},{"path":"数据操作.html","id":"melt","chapter":"第5章 数据操作","heading":"5.9.4 melt","text":"pivot的逆操作,相当于把一列的各个种类再次归为一列，对于有多层column的，要把column的组合值作为一类，有几层就还原为几列。但是对于unpivot，stack和unstack明显更方便，只能说这个函数的意义不是unpivot，而是把几个列组合成一个列，其他几个id列保持不变，剩下的舍弃。","code":"pivot_df.stack(level=1).reset_index()<string>:1: FutureWarning: The previous implementation of stack is deprecated and will be removed in a future version of pandas. See the What's New notes for pandas 2.1.0 for details. Specify future_stack=True to adopt the new implementation and silence this warning.\n   foo bar baz zoo\n0  one   A   1   x\n1  one   B   2   y\n2  one   C   3   z\n3  two   A   4   q\n4  two   B   5   w\n5  two   C   6   t"},{"path":"数据操作.html","id":"分组.groupby","chapter":"第5章 数据操作","heading":"5.10 分组.groupby()","text":"split-apply-combinegrouped = df.groupby(,axis=,sort=True，dropna=True,as_index=True):\n用来分组的不一定要是某个列，可以是很多种\n可以是一个python函数作用于每个轴标签, 返回相同值的为一个group,axis labels，但是原索引依然是保存的\n也可以是一个和df等长的list或array\n也可以是一个字典或Series，提供了轴标签到group name 的映射，只对提供了的轴标签进行映射\n一个index level的名字，通过传递level参数\n上面几种形式的任意组合的列表\n\n也可以是level和column的混合\n.groupby(pd.Grouper(level=level_name/level_id),column_name)\n.groupby([level_name,column_name])#会自动去找index和column中满足的name\n\n不仅可以对index聚合，也可以对column聚合，通过axis=1\n默认会按照聚合的key来排序，设置为False可以加快速度\n默认去除key中的缺失值，不作为一类，dropna=True\n默认用来聚合的类是作为index的，设置as_index为False可以变为列\n用来分组的不一定要是某个列，可以是很多种\n可以是一个python函数作用于每个轴标签, 返回相同值的为一个group,axis labels，但是原索引依然是保存的\n也可以是一个和df等长的list或array\n也可以是一个字典或Series，提供了轴标签到group name 的映射，只对提供了的轴标签进行映射\n一个index level的名字，通过传递level参数\n上面几种形式的任意组合的列表\n可以是一个python函数作用于每个轴标签, 返回相同值的为一个group,axis labels，但是原索引依然是保存的也可以是一个和df等长的list或array也可以是一个字典或Series，提供了轴标签到group name 的映射，只对提供了的轴标签进行映射一个index level的名字，通过传递level参数上面几种形式的任意组合的列表也可以是level和column的混合\n.groupby(pd.Grouper(level=level_name/level_id),column_name)\n.groupby([level_name,column_name])#会自动去找index和column中满足的name\n.groupby(pd.Grouper(level=level_name/level_id),column_name).groupby([level_name,column_name])#会自动去找index和column中满足的name不仅可以对index聚合，也可以对column聚合，通过axis=1默认会按照聚合的key来排序，设置为False可以加快速度默认去除key中的缺失值，不作为一类，dropna=True默认用来聚合的类是作为index的，设置as_index为False可以变为列","code":"gd = pd.DataFrame(\n  {\n    \"number\":[\"A\",\"B\"]*3,\n    \"font\":[\"one\",\"two\",\"three\"]*2,\n    \"score1\":np.random.randn(6),\n    \"score2\":np.random.randn(6)\n}\n)\ngd  number   font    score1    score2\n0      A    one -1.774007 -1.164342\n1      B    two  2.339670 -0.208385\n2      A  three  1.157775  0.309045\n3      B    one  0.296689  1.236961\n4      A    two  0.158378  1.227828\n5      B  three -1.123796  0.776552gd.groupby([\"number\"])<pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000022DBA39A150>gdn = gd.groupby([\"number\"])\ngdn.groups #{index,row_label}{'A': [0, 2, 4], 'B': [1, 3, 5]}gdn.get_group(\"A\")<string>:1: FutureWarning: When grouping with a length-1 list-like, you will need to pass a length-1 tuple to get_group in a future version of pandas. Pass `(name,)` instead of `name` to silence this warning.\n  number   font    score1    score2\n0      A    one -1.774007 -1.164342\n2      A  three  1.157775  0.309045\n4      A    two  0.158378  1.227828gdn.ngroup() #以数字代表种类，反映每行属于哪一类0    0\n1    1\n2    0\n3    1\n4    0\n5    1\ndtype: int64gdn.ngroups  #返回种类的个数2"},{"path":"数据操作.html","id":"选取","chapter":"第5章 数据操作","heading":"5.10.1 选取","text":"从split的角度，我们无法选择行，可以选择列。","code":""},{"path":"数据操作.html","id":"选取列-1","chapter":"第5章 数据操作","heading":"5.10.1.1 选取列","text":"","code":"gdn[\"font\"]<pandas.core.groupby.generic.SeriesGroupBy object at 0x0000022DB9EDE8D0>gdn[[\"font\"]]<pandas.core.groupby.generic.DataFrameGroupBy object at 0x0000022DBA47B020>"},{"path":"数据操作.html","id":"filter","chapter":"第5章 数据操作","heading":"5.10.1.2 .filter()","text":"","code":">>> df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),\n...                   index=['mouse', 'rabbit'],\n...                   columns=['one', 'two', 'three'])\n>>> df\n        one  two  three\nmouse     1    2      3\nrabbit    4    5      6\n\n>>> # select columns by name\n>>> df.filter(items=['one', 'three'])\n         one  three\nmouse     1      3\nrabbit    4      6\n\n>>> # select columns by regular expression\n>>> df.filter(regex='e$', axis=1)\n         one  three\nmouse     1      3\nrabbit    4      6\n\n>>> # select rows containing 'bbi'\n>>> df.filter(like='bbi', axis=0)\n         one  two  three\nrabbit    4    5      6"},{"path":"数据操作.html","id":"head.tail","chapter":"第5章 数据操作","heading":"5.10.1.3 .head()/.tail()","text":"没啥意义，相当于没有groupby，返回原数据框样式.","code":"gdn.head()  number   font    score1    score2\n0      A    one -1.774007 -1.164342\n1      B    two  2.339670 -0.208385\n2      A  three  1.157775  0.309045\n3      B    one  0.296689  1.236961\n4      A    two  0.158378  1.227828\n5      B  three -1.123796  0.776552"},{"path":"数据操作.html","id":"take-1","chapter":"第5章 数据操作","heading":"5.10.1.4 .take()","text":"给与行号，返回每个组相应位置的行。行索引保留。不可超过","code":"gdn.take([0,1])           font    score1    score2\nnumber                             \nA      0    one -1.774007 -1.164342\n       2  three  1.157775  0.309045\nB      1    two  2.339670 -0.208385\n       3    one  0.296689  1.236961"},{"path":"数据操作.html","id":"应用聚合函数","chapter":"第5章 数据操作","heading":"5.10.2 应用聚合函数","text":"如果是对数值列操作的聚合函数，要选出相应的聚合函数.().().count().idxmax().idxmin().max().min().mean().median().nunique()返会非重复行个数，对于单列就是返回种类数.var().std().quantile().sum().prod()","code":""},{"path":"数据操作.html","id":"应用统计函数","chapter":"第5章 数据操作","heading":"5.10.3 应用统计函数","text":".cov().corr().corrwith()#传递同等长度的序列.value_counts()#返回每个组的value_counts().describe() # 就是原数据框的describe.sample()","code":""},{"path":"数据操作.html","id":"应用窗口函数","chapter":"第5章 数据操作","heading":"5.10.4 应用窗口函数","text":".bfill().ffill().shift(n) n阶滞后.rolling().cumsum().cummax().cummin().cumprod().cumcount()返回每一组的各个row的出现顺序，从零开始计数.diff().first().last().nth().rank().expand()将会对每个组中的每个成员进行累计的函数操作，比如sum函数会变成累加.resample()重新定义频率","code":""},{"path":"数据操作.html","id":"应用自定义函数","chapter":"第5章 数据操作","heading":"5.10.5 应用自定义函数","text":"将每个组视为一个dataframe,然后对每个组应用函数。如果想对整个组进行聚合操作，可以利用dataframe的values属性获取array数组，通过numpy函数对数组进行整体聚合操作.比如lambda x:np.sum(x.values).pipe().apply().agg().transform()","code":""},{"path":"数据操作.html","id":"迭代每个组","chapter":"第5章 数据操作","heading":"5.10.6 迭代每个组","text":"","code":"for name,group in grouped:\n    print(name)\n    print(group)"},{"path":"数据操作.html","id":"方法链","chapter":"第5章 数据操作","heading":"5.11 方法链","text":"以括号包裹，多行书写,避免中间变量的定义","code":"df = (pd.melt(df)\n.rename(columns={'variable':'var','value':'val'})\n.query('val >= 200')\n)"},{"path":"数据操作.html","id":"采样","chapter":"第5章 数据操作","heading":"5.12 采样","text":"","code":""},{"path":"数据操作.html","id":"随机重排序","chapter":"第5章 数据操作","heading":"5.12.1 随机重排序","text":"","code":"#生成新序列\nnp.random.permutation(range(5))array([4, 2, 0, 3, 1])import random\n#打乱原序列，不生成新序列\nrandom.shuffle(list(range(6)))"},{"path":"数据操作.html","id":"随机采样","chapter":"第5章 数据操作","heading":"5.12.2 随机采样","text":"","code":""},{"path":"数据操作.html","id":"random.sample","chapter":"第5章 数据操作","heading":"5.12.2.1 random.sample()","text":"不能超过序列个数sample(population,k,*,counts)","code":"random.sample(range(5),3)[0, 3, 2]random.sample(['a','b'],counts=[4,2],k=5)['a', 'a', 'b', 'a', 'a']"},{"path":"数据操作.html","id":"random.choices","chapter":"第5章 数据操作","heading":"5.12.2.2 random.choice(s)()","text":"","code":"random.choices(population,weights=None,*,cum_weights=None,k=1)\n给定weights或cum_weights,不能同时给，最终都会转为cum_weight来进行计算，长度必须和population的长度相同，对应的各个值的概率。\nk决定了生成样本的个数\n大样本下各个值的概率应该与给定的weights相符random.choice(range(5))1random.choices(['a','b'],weights=[2,1],k=12)['a', 'b', 'b', 'a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'a']"},{"path":"数据操作.html","id":"df.sample","chapter":"第5章 数据操作","heading":"5.12.2.3 df.sample()","text":"","code":"ts = pd.DataFrame(np.random.randn(8),index=pd.date_range(\"2022\",\"2030\",freq=\"Y\"))<string>:1: FutureWarning: 'Y' is deprecated and will be removed in a future version, please use 'YE' instead.ts.sample(3)                   0\n2023-12-31  1.259061\n2028-12-31  0.325197\n2026-12-31 -0.661192ts.sample(5,replace=True)                   0\n2027-12-31 -0.604302\n2022-12-31  0.131528\n2023-12-31  1.259061\n2028-12-31  0.325197\n2025-12-31 -0.577860"},{"path":"时间序列.html","id":"时间序列","chapter":"第6章 时间序列","heading":"第6章 时间序列","text":"时间序列数据在很多领域都是重要的结构化数据形式，例如金融、经济、生态学、神经科学和物理学。在多个时间点观测或测量的数据形成了时间序列。许多时间序列是固定频率的，也就是说数据是根据相同的规则定期出现的，例如每15秒、每5分钟或每月1次。时间序列也可以是不规则的，没有固定的时间单位或单位间的偏移量。如何标记和引用时间序列数据取决于应用程序，并且您可能有以下其中一项：·时间戳，具体的时刻。固定的时间区间，例如2007的1月或整个2010年。时间间隔，由开始和结束时间戳表示。时间区间可以被认为是间隔的特殊情况。实验时间或消耗时间。每个时间戳是相对于特定开始时间的时间的量度（例如，自从被放置在烤箱中每秒烘烤的饼干的直径）。python有很多和时间相关的模块,如datetime,pandas,time,calendar","code":""},{"path":"时间序列.html","id":"datetime","chapter":"第6章 时间序列","heading":"6.1 datetime","text":"","code":"import datetime\nfrom datetime import timedelta, timezone\nimport pandas as pd\nimport numpy as np"},{"path":"时间序列.html","id":"时间的类型","chapter":"第6章 时间序列","heading":"6.1.1 时间的类型","text":"","code":""},{"path":"时间序列.html","id":"datetime主要类","chapter":"第6章 时间序列","heading":"6.1.2 datetime主要类","text":"","code":""},{"path":"时间序列.html","id":"date","chapter":"第6章 时间序列","heading":"6.1.2.1 .date()","text":"","code":"datetime.date(year,month,day)"},{"path":"时间序列.html","id":"time","chapter":"第6章 时间序列","heading":"6.1.2.2 .time()","text":"","code":"datetime.time(\\[hour[, minute[, second[, microsecond[, tzinfo]]]]\\])def time_atr_and_met(hour,minute,second):\n    import datetime\n    time1=datetime.time(hour,minute,second)\n    atr=[i for i in dir(time1) if i[0]!='_']\n    l=[]\n    for i in atr:\n        try:\n            a=eval('time1.'+i+'()')\n        except:\n            try:\n                a=eval('time1.'+i)\n            except:\n                a=\"pass\"\n        l.append(['.'+i,a])\n    return l\npd.DataFrame(time_atr_and_met(15,42,30),columns=['方法或属性','实例']).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))  "},{"path":"时间序列.html","id":"datetime-1","chapter":"第6章 时间序列","heading":"6.1.2.3 .datetime()","text":":1: DeprecationWarning: datetime.datetime.utcfromtimestamp() deprecated scheduled removal future version. Use timezone-aware objects represent datetimes UTC: datetime.datetime.fromtimestamp(timestamp, datetime.UTC).\n:1: DeprecationWarning: datetime.datetime.utcnow() deprecated scheduled removal future version. Use timezone-aware objects represent datetimes UTC: datetime.datetime.now(datetime.UTC).","code":"datetime(year, month, day\\[, hour[, minute[, second[, microsecond[,tzinfo]]]]\\])def datetime_atr_and_met(year,month,day,hour,minute,second):\n    import datetime\n    datetime1=datetime.datetime(year,month,day,hour,minute,second)\n    atr=[i for i in dir(datetime1) if i[0]!='_']\n    l=[]\n    for i in atr:\n        try:\n            a=eval('datetime1.'+i+'()')\n        except:\n            try:\n                a=eval('datetime1.'+i)\n            except:\n                a=\"pass\"\n        l.append(['.'+i,a])\n    return l\ndt=datetime_atr_and_met(2021,11,26,16,0,0) ndt=[i+j for i,j in zip(dt[20:39],dt[:19])]+[dt[19]+['']+['']]\npd.DataFrame(ndt,columns=['方法或属性','实例','方法或属性','实例']).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"时间序列.html","id":"timedelta","chapter":"第6章 时间序列","heading":"6.1.2.4 .timedelta()","text":"timedelta类是用来计算二个datetime对象的差值的。创建对象:datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)使用timedelta你可以很容易地算出前几天和后几天的时刻。","code":"def timedelta_atr_and_met(days,seconds,microseconds):\n    import datetime\n    timedelta=datetime.timedelta(days,seconds,microseconds)\n    atr=[i for i in dir(timedelta) if i[0]!='_']\n    l=[]\n    for i in atr:\n        try:\n            a=eval('timedelta.'+i+'()')\n        except:\n            try:\n                a=eval('timedelta.'+i)\n            except:\n                a=\"pass\"\n        l.append(['.'+i,a])\n    return l\npd.DataFrame(timedelta_atr_and_met(2,42,300),columns=['方法或属性','实例']).pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))t1 = datetime.date(2023,3,15)\nt2 = datetime.date(2023,3,16)\ntd = t2-t1\nt2+3*tddatetime.date(2023, 3, 19)"},{"path":"时间序列.html","id":"timezone","chapter":"第6章 时间序列","heading":"6.1.2.5 .timezone()","text":"创建时区","code":"datetime.timezone(offset, name=None)\noffset必须是一个timedelta对象，代表了与utc时间的偏移，范围为-timedelta(hours=24) 到 timedelta(hours=24)\nname可以不给，给了话必须是datetime.tzname()生成的对象dt=datetime.datetime.now()\ntz=timezone(timedelta(hours=6))\ntzdatetime.timezone(datetime.timedelta(seconds=21600))tz.tzname(dt)'UTC+06:00'tz.utcdatetime.timezone.utctz.utcoffset(dt)datetime.timedelta(seconds=21600)"},{"path":"时间序列.html","id":"时间类型的转换","chapter":"第6章 时间序列","heading":"6.1.3 时间类型的转换","text":"","code":""},{"path":"时间序列.html","id":"str与datetime","chapter":"第6章 时间序列","heading":"6.1.3.1 str与datetime","text":"","code":"* 字符串形式转化为datetime `datetime.datetime.strptime('2015-6-1 18:19:59', '%Y-%m-%d %H:%M:%S')`\n    * 只有datetime对象有该方法\n    * 注意转换后的datetime是没有时区信息的。\n* datetime对象转化为字符串 `datetime.datetime().strftime('%a, %b %d %H:%M')`\n    * date对象和time对象也有该方法\n    * 如果你想将时间对象转化为字符串对象的话，可以用到__format__(...)方法以指定格式进行时间输出："},{"path":"时间序列.html","id":"timestamp与datetime","chapter":"第6章 时间序列","heading":"6.1.3.2 timestamp与datetime","text":"datetime 转化为timestamp datetime.datetime.timestamp()timestamp 转化为 datetime\n本地时间的datetime: datetime.datetime.fromtimestamp(t)\nUTC时间的datetime: datetime.datetime.utcfromtimestamp(t)\n本地时间的datetime: datetime.datetime.fromtimestamp(t)UTC时间的datetime: datetime.datetime.utcfromtimestamp(t)","code":""},{"path":"时间序列.html","id":"本地时间与utc时间","chapter":"第6章 时间序列","heading":"6.1.3.3 本地时间与utc时间","text":"本地时间转换为utc时间:一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区.需要自己创建时区对象，然后赋值给datetime对象","code":"tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00\nnow = datetime.datetime.now()\nnowdatetime.datetime(2024, 4, 29, 0, 34, 46, 313544)dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00\ndtdatetime.datetime(2024, 4, 29, 0, 34, 46, 313544, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))#datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))\n#如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。"},{"path":"时间序列.html","id":"比较","chapter":"第6章 时间序列","heading":"6.1.4 比较","text":"","code":"##加减\na=datetime.datetime.now()\nb=datetime.datetime(2021,12,3,15,43,20)\na-bdatetime.timedelta(days=877, seconds=31886, microseconds=436933)##比较大小\na > bTruea < bFalse"},{"path":"时间序列.html","id":"dateutil","chapter":"第6章 时间序列","heading":"6.2 dateutil","text":"datetime.strptime是在已知格式的情况下转换日期的好方式。然而，每次都必须编写一个格式代码可能有点烦人，特别是对于通用日期格式。在这种情况下，你可以使用第三方dateutil包的parser.parse方法（这个包在安装pandas时已经自动安装）：dateutil.parser是一个有用但并不完美的工具。值得注意的是，它会将一些字符串识别为\n你并不想要的日期——例如，’42’将被解析为2042年的当前日期。","code":"from dateutil.parser import parse\nparse('2011-01-03')datetime.datetime(2011, 1, 3, 0, 0)"},{"path":"时间序列.html","id":"pandas时间日期操作","chapter":"第6章 时间序列","heading":"6.3 pandas时间日期操作","text":"pd.to_datetime()可以将缺失值转为NaT","code":""},{"path":"时间序列.html","id":"pandas时间类","chapter":"第6章 时间序列","heading":"6.3.1 pandas时间类","text":"","code":""},{"path":"时间序列.html","id":"datetime-2","chapter":"第6章 时间序列","heading":"6.3.1.1 datetime","text":"属性方法\nProperty\n\nDescription\n\nyear\n\nyear datetime\n\nmonth\n\nmonth datetime\n\nday\n\ndays datetime\n\nhour\n\nhour datetime\n\nminute\n\nminutes datetime\n\nsecond\n\nseconds datetime\n\nmicrosecond\n\nmicroseconds datetime\n\nnanosecond\n\nnanoseconds datetime\n\ndate\n\nReturns datetime.date (contain timezone information)\n\ntime\n\nReturns datetime.time (contain timezone information)\n\ntimetz\n\nReturns datetime.time local time timezone information\n\ndayofyear\n\nordinal day year\n\nday_of_year\n\nordinal day year\n\nweekofyear\n\nweek ordinal year\n\nweek\n\nweek ordinal year\n\ndayofweek\n\nnumber day week Monday=0, Sunday=6\n\nday_of_week\n\nnumber day week Monday=0, Sunday=6\n\nweekday\n\nnumber day week Monday=0, Sunday=6\n\nquarter\n\nQuarter date: Jan-Mar = 1, Apr-Jun = 2, etc.\n\ndays_in_month\n\nnumber days month datetime\n\nis_month_start\n\nLogical indicating first day month (defined frequency)\n\nis_month_end\n\nLogical indicating last day month (defined frequency)\n\nis_quarter_start\n\nLogical indicating first day quarter (defined frequency)\n\nis_quarter_end\n\nLogical indicating last day quarter (defined frequency)\n\nis_year_start\n\nLogical indicating first day year (defined frequency)\n\nis_year_end\n\nLogical indicating last day year (defined frequency)\n\nis_leap_year\n\nLogical indicating date belongs leap year\n","code":"pd.to_datetime(format=)\npd.date_range(start_time,ends_time,periods=)\npd.date_range(start_time,ends_time,freq=)\npd.date_range(start_time,periods=,freq=)"},{"path":"时间序列.html","id":"timedelta-1","chapter":"第6章 时间序列","heading":"6.3.1.2 timedelta","text":"","code":"pd.to_timedelta()\npd.timedelta_range()"},{"path":"时间序列.html","id":"timespans","chapter":"第6章 时间序列","heading":"6.3.1.3 timespans","text":"","code":"pd.period_range()\npd.period_range(start_time,end_time,freq)\n生成一个periodIndex对象\n每一个索引值是一个Period对象"},{"path":"时间序列.html","id":"dateoffsets","chapter":"第6章 时间序列","heading":"6.3.1.4 dateoffsets","text":"pandas.tseries.offset import BMonthEndDateOffset代表规则的频率增量。 在具有DateOffset各种子类的 Pandas 中，可以表示特定的日期偏移逻辑，例如“月”，“工作日”或“小时”可以将它们相加或相减以获得转换后的日期 可以将它们乘以整数（正数或负数），以便多次应用增量 它们具有rollforward和rollback方法，可以将日期向前或向后移动到下一个或上一个“偏移日期”可以通过向datetime对象传递代表固定时间段的datetime对象或使用多个关键字参数来创建DateOffset对象。 关键字参数分为两大类。 第一类是代表绝对日期的关键字：年，月，日，小时，分钟，秒和微秒。 第二类代表相对持续时间，可以是负值：年，月，周，日，小时，分钟，秒和微秒。特定DateOffset的多个单位可以通过乘法表示，时间加上偏移量可以实现时间的改变，或者使用这些对象的实例方法rollforward等实现时间的改变","code":"t = datetime.datetime.now()\nt + pd.offsets.BMonthEnd()Timestamp('2024-04-30 00:34:46.620385')t - pd.offsets.BMonthEnd(2)Timestamp('2024-02-29 00:34:46.620385')"},{"path":"时间序列.html","id":"indexing","chapter":"第6章 时间序列","heading":"6.3.2 indexing","text":"","code":"import numpy as np\nrng = pd.date_range('2011/1/31', '2011/12/31', freq=\"BM\")<string>:1: FutureWarning: 'BM' is deprecated and will be removed in a future version, please use 'BME' instead.ts = pd.Series(np.random.randn(len(rng)), index=rng)\nts[\"1/31/2011\"]-0.5061677483723529ts[\"10/31/2011\":\"12/31/2011\"]2011-10-31    0.329107\n2011-11-30    0.733076\n2011-12-30   -1.845578\nFreq: BME, dtype: float64ts[\"2011-6\"]2011-06-30   -1.062127\nFreq: BME, dtype: float64ts.loc[\"2011\"]2011-01-31   -0.506168\n2011-02-28    0.754779\n2011-03-31   -0.273464\n2011-04-29   -0.199650\n2011-05-31   -1.022645\n2011-06-30   -1.062127\n2011-07-29   -0.307864\n2011-08-31    1.877916\n2011-09-30   -3.059956\n2011-10-31    0.329107\n2011-11-30    0.733076\n2011-12-30   -1.845578\nFreq: BME, dtype: float64"},{"path":"时间序列.html","id":"时区处理","chapter":"第6章 时间序列","heading":"6.3.3 时区处理","text":"","code":"`.tz` 获取时区\n`rng = pd.date_range('3/9/2012 9:30', periods=6, freq='D',tz=\"utc\")` 设置utc时区\n`.tz_localize()` 方法将utc时区转为本地utc时区,单纯改了时区，没有换时间，所以可能时间不对\n`.tz.convert()` 一旦时间序列被本地化为某个特定的时区，则可以通过tz_convert将其转换为另一个时区：rng = pd.date_range('3/9/2012 9:30', periods=6, freq='D',tz=\"utc\")\nts = pd.Series(np.random.randn(len(rng)), index=rng)\nprint(ts.index.tz)UTCts.tz_convert('America/New_York')2012-03-09 04:30:00-05:00    0.559909\n2012-03-10 04:30:00-05:00    0.680295\n2012-03-11 05:30:00-04:00    0.829914\n2012-03-12 05:30:00-04:00   -1.550127\n2012-03-13 05:30:00-04:00    1.315035\n2012-03-14 05:30:00-04:00    1.655262\nFreq: D, dtype: float64"},{"path":"时间序列.html","id":"类型转换-1","chapter":"第6章 时间序列","heading":"6.3.4 类型转换","text":"period.to_timestamp(=“start”)\ntimestamp.to_period(freq)","code":""},{"path":"时间序列.html","id":"频率和频率转换","chapter":"第6章 时间序列","heading":"6.3.5 频率和频率转换","text":"p.asfreq(freq,=“start”)从小间隔转到大间隔默认保留第一个值从大间隔到小间隔可能会有缺失值，默认NAN，可以使用.asfreq()方法的method参数更改此默认行为。 该值可用于正向填充，反向填充或填充NaN值ffill方法将向前填充最后一个已知值（pad也这样做）bfill方法将从下一个已知值回填值：","code":""},{"path":"时间序列.html","id":"resample","chapter":"第6章 时间序列","heading":"6.3.6 resample","text":"一天”1D”的级别比”1W”的级别要高pandas对象都配有resample方法，该方法是所有频率转换的工具函数。resample拥有类似于groupby的API；你调用resample对数据分组，之后再调用聚合函数：","code":"rng = pd.date_range('2000-01-01', periods=100, freq='D')\nts = pd.Series(np.random.randn(len(rng)), index=rng)\nts.resample('M').mean()<string>:1: FutureWarning: 'M' is deprecated and will be removed in a future version, please use 'ME' instead.\n2000-01-31    0.198931\n2000-02-29    0.151074\n2000-03-31   -0.190714\n2000-04-30   -0.542959\nFreq: ME, dtype: float64ts.resample('M', kind='period').mean()<string>:1: FutureWarning: The 'kind' keyword in Series.resample is deprecated and will be removed in a future version. Explicitly cast the index to the desired type instead\n2000-01    0.198931\n2000-02    0.151074\n2000-03   -0.190714\n2000-04   -0.542959\nFreq: M, dtype: float64"},{"path":"时间序列.html","id":"向下采样","chapter":"第6章 时间序列","heading":"6.3.6.1 向下采样","text":"将数据聚合到一个规则的低频率上是一个常见的时间序列任务。你要聚合的数据不必是固定频率的。期望的频率定义了用于对时间序列切片以聚合的箱体边界。例如，要将时间转换为每月，‘M’或’BM’，你需要将数据分成一个月的时间间隔。每个间隔是半闭合的，一个数据点只能属于一个时间间隔，时间间隔的并集必须是整个时间帧。在使用resample进行向下采样数据时有些事情需要考虑：每段间隔的哪一边是闭合的如何在间隔的起始或结束位置标记每个已聚合的箱体","code":""},{"path":"时间序列.html","id":"向上采样","chapter":"第6章 时间序列","heading":"6.3.6.2 向上采样","text":"会多出时间，会出现空值，可以采用.ffill()或.reindex()方法填补空值ts.resample(\"D\").ffill(limit=2)","code":""},{"path":"时间序列.html","id":"窗口函数","chapter":"第6章 时间序列","heading":"6.3.7 窗口函数","text":"统计和其他通过移动窗口或指数衰减而运行的函数是用于时间序列操作的数组变换的一个重要类别。这对平滑噪声或粗糙的数据非常有用。我称这些函数为移动窗口函数，尽管它也包含了一些没有固定长度窗口的函数，比如指数加权移动平均。与其他的统计函数类似，这些函数会自动排除缺失数据。","code":""},{"path":"时间序列.html","id":"rolling","chapter":"第6章 时间序列","heading":"6.3.7.1 .rolling()","text":"确定窗口大小,对窗口内所有值进行操作`.rolling()data.rolling(\"20D\").mean(window,min_periods,closed)center : bool, default False","code":"If False, set the window labels as the right edge of the window index.\n\nIf True, set the window labels as the center of the window indextind = pd.date_range(\"2023-01-01\",\"2023-03-31\")\nts = pd.Series(np.random.randint(1,101,len(tind)),index=tind)\nts.rolling(\"10D\",min_periods=5).mean()2023-01-01     NaN\n2023-01-02     NaN\n2023-01-03     NaN\n2023-01-04     NaN\n2023-01-05    27.8\n              ... \n2023-03-27    43.7\n2023-03-28    48.3\n2023-03-29    40.6\n2023-03-30    37.5\n2023-03-31    38.5\nFreq: D, Length: 90, dtype: float64ts.rolling(\"10D\",min_periods=3).mean()2023-01-01          NaN\n2023-01-02          NaN\n2023-01-03    22.666667\n2023-01-04    33.750000\n2023-01-05    27.800000\n                ...    \n2023-03-27    43.700000\n2023-03-28    48.300000\n2023-03-29    40.600000\n2023-03-30    37.500000\n2023-03-31    38.500000\nFreq: D, Length: 90, dtype: float64ts.rolling(\"10D\",min_periods=5,center=True).mean()2023-01-01    34.666667\n2023-01-02    38.285714\n2023-01-03    40.500000\n2023-01-04    42.000000\n2023-01-05    41.900000\n                ...    \n2023-03-27    41.111111\n2023-03-28    42.250000\n2023-03-29    46.000000\n2023-03-30    48.000000\n2023-03-31    55.600000\nFreq: D, Length: 90, dtype: float64"},{"path":"时间序列.html","id":"shift","chapter":"第6章 时间序列","heading":"6.3.7.2 .shift()","text":".shift(n,periods,freq,fill_value)滞后n期，并不会改变原索引","code":"ts.shift(1)2023-01-01     NaN\n2023-01-02    13.0\n2023-01-03    20.0\n2023-01-04    35.0\n2023-01-05    67.0\n              ... \n2023-03-27    10.0\n2023-03-28    55.0\n2023-03-29    57.0\n2023-03-30     5.0\n2023-03-31    66.0\nFreq: D, Length: 90, dtype: float64ts.shift(1).ffill()2023-01-01     NaN\n2023-01-02    13.0\n2023-01-03    20.0\n2023-01-04    35.0\n2023-01-05    67.0\n              ... \n2023-03-27    10.0\n2023-03-28    55.0\n2023-03-29    57.0\n2023-03-30     5.0\n2023-03-31    66.0\nFreq: D, Length: 90, dtype: float64ts.shift(1).bfill()2023-01-01    13.0\n2023-01-02    13.0\n2023-01-03    20.0\n2023-01-04    35.0\n2023-01-05    67.0\n              ... \n2023-03-27    10.0\n2023-03-28    55.0\n2023-03-29    57.0\n2023-03-30     5.0\n2023-03-31    66.0\nFreq: D, Length: 90, dtype: float64"},{"path":"时间序列.html","id":"diff","chapter":"第6章 时间序列","heading":"6.3.7.3 .diff()","text":"","code":"ts.diff()2023-01-01     NaN\n2023-01-02     7.0\n2023-01-03    15.0\n2023-01-04    32.0\n2023-01-05   -63.0\n              ... \n2023-03-27    45.0\n2023-03-28     2.0\n2023-03-29   -52.0\n2023-03-30    61.0\n2023-03-31    29.0\nFreq: D, Length: 90, dtype: float64"},{"path":"时间序列.html","id":"first","chapter":"第6章 时间序列","heading":"6.3.7.4 .first()","text":"返回时间的索引值之间的极差是offsetoffset:str,dateoffset","code":"ts.first('10D')#1-1到1-10<string>:1: FutureWarning: first is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead\n2023-01-01    13\n2023-01-02    20\n2023-01-03    35\n2023-01-04    67\n2023-01-05     4\n2023-01-06    69\n2023-01-07    60\n2023-01-08    56\n2023-01-09    54\n2023-01-10    41\nFreq: D, dtype: int32"},{"path":"时间序列.html","id":"last","chapter":"第6章 时间序列","heading":"6.3.7.5 .last()","text":"","code":"ts.last(\"20D\")<string>:1: FutureWarning: last is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead\n2023-03-12    99\n2023-03-13    12\n2023-03-14    48\n2023-03-15    68\n2023-03-16    94\n2023-03-17    62\n2023-03-18    11\n2023-03-19    82\n2023-03-20    97\n2023-03-21    85\n2023-03-22    15\n2023-03-23    32\n2023-03-24    16\n2023-03-25    34\n2023-03-26    10\n2023-03-27    55\n2023-03-28    57\n2023-03-29     5\n2023-03-30    66\n2023-03-31    95\nFreq: D, dtype: int32"},{"path":"时间序列.html","id":"expandind","chapter":"第6章 时间序列","heading":"6.3.7.6 .expandind()","text":"","code":"ts.expanding(3).sum()2023-01-01       NaN\n2023-01-02       NaN\n2023-01-03      68.0\n2023-01-04     135.0\n2023-01-05     139.0\n               ...  \n2023-03-27    4309.0\n2023-03-28    4366.0\n2023-03-29    4371.0\n2023-03-30    4437.0\n2023-03-31    4532.0\nFreq: D, Length: 90, dtype: float64"},{"path":"introduction-1.html","id":"introduction-1","chapter":"introduction","heading":"introduction","text":"matplotlib","code":""},{"path":"matplotlib.html","id":"matplotlib","chapter":"第7章 matplotlib","heading":"第7章 matplotlib","text":"原文","code":"import pandas as pd\nimport numpy as np\nimport re\nimport datetime\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib.lines import Line2D   \nfrom matplotlib.patches import Circle, Wedge\nfrom matplotlib.collections import PatchCollection\nimport matplotlib.dates as mdates\nplt.rcParams['font.sans-serif']=['Simhei']; #SimHei黑体 \nplt.rcParams['axes.unicode_minus']=False; #正常显示图中负号"},{"path":"matplotlib.html","id":"认识matplotlib","chapter":"第7章 matplotlib","heading":"7.1 认识matplotlib","text":"Matplotlib是一个Python 2D绘图库，能够以多种硬拷贝格式和跨平台的交互式环境生成出版物质量的图形，用来绘制各种静态，动态，交互式的图表。Matplotlib可用于Python脚本，Python和IPython Shell、Jupyter notebook，Web应用程序服务器和各种图形用户界面工具包等。Matplotlib是Python数据可视化库中的泰斗，它已经成为python中公认的数据可视化工具，我们所熟知的pandas和seaborn的绘图接口其实也是基于matplotlib所作的高级封装。为了对matplotlib有更好的理解，让我们从一些最基本的概念开始认识它，再逐渐过渡到一些高级技巧中。","code":""},{"path":"matplotlib.html","id":"一个最简单的绘图例子","chapter":"第7章 matplotlib","heading":"7.2 一个最简单的绘图例子","text":"Matplotlib的图像是画在figure（如windows，jupyter窗体）上的，每一个figure又包含了一个或多个axes（一个可以指定坐标系的子区域）。最简单的创建figure以及axes的方式是通过pyplot.subplots命令，创建axes以后，可以使用Axes.plot绘制最简易的折线图。Trick：\n在jupyter notebook中使用matplotlib时会发现，代码运行后自动打印出类似<matplotlib.lines.Line2D 0x23155916dc0>这样一段话，这是因为matplotlib的绘图代码默认打印出最后一个对象。如果不想显示这句话，有以下三种方法，在本章节的代码示例中你能找到这三种方法的使用。在代码块最后加一个分号;在代码块最后加一句plt.show()在绘图时将绘图对象显式赋值给一个变量，如将plt.plot([1, 2, 3, 4]) 改成line =plt.plot([1, 2, 3, 4])和MATLAB命令类似，你还可以通过一种更简单的方式绘制图像，matplotlib.pyplot方法能够直接在当前axes上绘制图像，如果用户未指定axes，matplotlib会帮你自动创建一个。所以上面的例子也可以简化为以下这一行代码。","code":"fig,ax = plt.subplots()  # 创建一个包含一个axes的figure\nax.plot([1, 2, 3, 4], [1, 4, 2, 3]);  # 绘制图像line =plt.plot([1, 2, 3, 4], [1, 4, 2, 3]) "},{"path":"matplotlib.html","id":"figure的组成","chapter":"第7章 matplotlib","heading":"7.3 Figure的组成","text":"现在我们来深入看一下figure的组成。通过一张figure解剖图，我们可以看到一个完整的matplotlib图像通常会包括以下四个层级，这些层级也被称为容器（container），下一节会详细介绍。在matplotlib的世界中，我们将通过各种命令方法来操纵图像中的每一个部分，从而达到数据可视化的最终效果，一副完整的图像实际上是各类子元素的集合。Figure：顶层级，用来容纳所有绘图元素Figure：顶层级，用来容纳所有绘图元素Axes：matplotlib宇宙的核心，容纳了大量元素用来构造一幅幅子图，一个figure可以由一个或多个子图组成Axes：matplotlib宇宙的核心，容纳了大量元素用来构造一幅幅子图，一个figure可以由一个或多个子图组成Axis：axes的下属层级，用于处理所有和坐标轴，网格有关的元素Axis：axes的下属层级，用于处理所有和坐标轴，网格有关的元素Tick：axis的下属层级，用来处理所有和刻度有关的元素Tick：axis的下属层级，用来处理所有和刻度有关的元素","code":""},{"path":"matplotlib.html","id":"两种绘图接口","chapter":"第7章 matplotlib","heading":"7.4 两种绘图接口","text":"matplotlib提供了两种最常用的绘图接口显式创建figure和axes，在上面调用绘图方法，也被称为OO模式（object-oriented style)显式创建figure和axes，在上面调用绘图方法，也被称为OO模式（object-oriented style)依赖pyplot自动创建figure和axes，并绘图依赖pyplot自动创建figure和axes，并绘图使用第一种绘图接口，是这样的：而如果采用第二种绘图接口，绘制同样的图，代码是这样的：","code":"x = np.linspace(0, 2, 100)\n\nfig, ax = plt.subplots()  \nax.plot(x, x, label='linear')  \nax.plot(x, x**2, label='quadratic')  \nax.plot(x, x**3, label='cubic')  \nax.set_xlabel('x label') \nax.set_ylabel('y label') \nax.set_title(\"Simple Plot\")  \nax.legend() \nplt.show()x = np.linspace(0, 2, 100)\n\nplt.plot(x, x, label='linear') \nplt.plot(x, x**2, label='quadratic')  \nplt.plot(x, x**3, label='cubic')\nplt.xlabel('x label')\nplt.ylabel('y label')\nplt.title(\"Simple Plot\")\nplt.legend()\nplt.show()"},{"path":"matplotlib.html","id":"通用绘图模板","chapter":"第7章 matplotlib","heading":"7.5 通用绘图模板","text":"由于matplotlib的知识点非常繁杂，在实际使用过程中也不可能将全部API都记住，很多时候都是边用边查。因此这里提供一个通用的绘图基础模板，任何复杂的图表几乎都可以基于这个模板骨架填充内容而成。初学者刚开始学习时只需要牢记这一模板就足以应对大部分简单图表的绘制，在学习过程中可以将这个模板模块化，了解每个模块在做什么，在绘制复杂图表时如何修改，填充对应的模块。","code":"# step1 准备数据\nx = np.linspace(0, 2, 100)\ny = x**2\n\n# step2 设置绘图样式，这一模块的扩展参考第五章进一步学习，这一步不是必须的，样式也可以在绘制图像是进行设置\nmpl.rc('lines', linewidth=4, linestyle='-.')\n\n# step3 定义布局， 这一模块的扩展参考第三章进一步学习\nfig, ax = plt.subplots()  \n\n# step4 绘制图像， 这一模块的扩展参考第二章进一步学习\nax.plot(x, y, label='linear')  \n\n# step5 添加标签，文字和图例，这一模块的扩展参考第四章进一步学习\nax.set_xlabel('x label') \nax.set_ylabel('y label') \nax.set_title(\"Simple Plot\")  \nax.legend()\nplt.show()"},{"path":"matplotlib.html","id":"思考题","chapter":"第7章 matplotlib","heading":"7.6 思考题","text":"请思考两种绘图模式的优缺点和各自适合的使用场景在第五节绘图模板中我们是以OO模式作为例子展示的，请思考并写一个pyplot绘图模式的简单模板","code":""},{"path":"matplotlib.html","id":"概述","chapter":"第7章 matplotlib","heading":"7.7 概述","text":"","code":""},{"path":"matplotlib.html","id":"matplotlib的三层api","chapter":"第7章 matplotlib","heading":"7.7.1 matplotlib的三层api","text":"matplotlib的原理或者说基础逻辑是，用Artist对象在画布(canvas)上绘制(Render)图形。\n就和人作画的步骤类似：准备一块画布或画纸准备好颜料、画笔等制图工具作画所以matplotlib有三个层次的API：matplotlib.backend_bases.FigureCanvas 代表了绘图区，所有的图像都是在绘图区完成的matplotlib.backend_bases.Renderer 代表了渲染器，可以近似理解为画笔，控制如何在 FigureCanvas 上画图。matplotlib.artist.Artist 代表了具体的图表组件，即调用了Renderer的接口在Canvas上作图。\n前两者处理程序和计算机的底层交互的事项，第三项Artist就是具体的调用接口来做出我们想要的图，比如图形、文本、线条的设定。所以通常来说，我们95%的时间，都是用来和matplotlib.artist.Artist类打交道的。","code":""},{"path":"matplotlib.html","id":"artist的分类","chapter":"第7章 matplotlib","heading":"7.7.2 Artist的分类","text":"Artist有两种类型：primitives 和containers。primitive是基本要素，它包含一些我们要在绘图区作图用到的标准图形对象，如曲线Line2D，文字text，矩形Rectangle，图像image等。container是容器，即用来装基本要素的地方，包括图形figure、坐标系Axes和坐标轴Axis。他们之间的关系如下图所示：可视化中常见的artist类可以参考下图这张表格，解释下每一列的含义。\n第一列表示matplotlib中子图上的辅助方法，可以理解为可视化中不同种类的图表类型，如柱状图，折线图，直方图等，这些图表都可以用这些辅助方法直接画出来，属于更高层级的抽象。第二列表示不同图表背后的artist类，比如折线图方法plot在底层用到的就是Line2D这一artist类。第三列是第二列的列表容器，例如所有在子图中创建的Line2D对象都会被自动收集到ax.lines返回的列表中。下一节的具体案例更清楚地阐释了这三者的关系，其实在很多时候，我们只用记住第一列的辅助方法进行绘图即可，而无需关注具体底层使用了哪些类，但是了解底层类有助于我们绘制一些复杂的图表，因此也很有必要了解。","code":""},{"path":"matplotlib.html","id":"基本元素---primitives","chapter":"第7章 matplotlib","heading":"7.8 基本元素 - primitives","text":"各容器中可能会包含多种基本要素-primitives, 所以先介绍下primitives，再介绍容器。本章重点介绍下 primitives 的几种类型：曲线-Line2D，矩形-Rectangle，多边形-Polygon，图像-image","code":""},{"path":"matplotlib.html","id":"dlines","chapter":"第7章 matplotlib","heading":"7.8.1 2DLines","text":"在matplotlib中曲线的绘制，主要是通过类 matplotlib.lines.Line2D 来完成的。matplotlib中线-line的含义：它表示的可以是连接所有顶点的实线样式，也可以是每个顶点的标记。此外，这条线也会受到绘画风格的影响，比如，我们可以创建虚线种类的线。它的构造函数：class matplotlib.lines.Line2D(xdata, ydata, linewidth=None, linestyle=None, color=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, markerfacecoloralt=‘none’, fillstyle=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, markevery=None, **kwargs)其中常用的的参数有：xdata:需要绘制的line中点的在x轴上的取值，若忽略，则默认为range(1,len(ydata)+1)ydata:需要绘制的line中点的在y轴上的取值linewidth:线条的宽度linestyle:线型color:线条的颜色marker:点的标记，详细可参考markers APImarkersize:标记的size其他详细参数可参考Line2D官方文档","code":""},{"path":"matplotlib.html","id":"如何设置line2d的属性","chapter":"第7章 matplotlib","heading":"7.8.2 如何设置Line2D的属性","text":"有三种方法可以用设置线的属性。直接在plot()函数中设置通过获得线对象，对线对象进行设置获得线属性，使用setp()函数设置","code":"# 1) 直接在plot()函数中设置\nx = range(0,5)\ny = [2,5,7,8,10]\nplt.plot(x,y, linewidth=10) # 设置线的粗细参数为10\nplt.show()# 2) 通过获得线对象，对线对象进行设置\nx = range(0,5)\ny = [2,5,7,8,10]\nline, = plt.plot(x, y, '-') # 这里等号坐标的line,是一个列表解包的操作，目的是获取plt.plot返回列表中的Line2D对象\nline.set_antialiased(False)\nplt.show() # 关闭抗锯齿功能# 3) 获得线属性，使用setp()函数设置\nx = range(0,5)\ny = [2,5,7,8,10]\nlines = plt.plot(x, y)\nplt.setp(lines, color='r', linewidth=10)[None, None]plt.show()"},{"path":"matplotlib.html","id":"如何绘制lines","chapter":"第7章 matplotlib","heading":"7.8.3 如何绘制lines","text":"绘制直线lineerrorbar绘制误差折线图介绍两种绘制直线line常用的方法:\n+ plot方法绘制\n+ Line2D对象绘制2) errorbar绘制误差折线图pyplot里有个专门绘制误差线的功能，通过errorbar类实现，它的构造函数：matplotlib.pyplot.errorbar(x, y, yerr=None, xerr=None, fmt=’’, ecolor=None, elinewidth=None, capsize=None, barsabove=False, lolims=False, uplims=False, xlolims=False, xuplims=False, errorevery=1, capthick=None, *, data=None, **kwargs)其中最主要的参数是前几个:x：需要绘制的line中点的在x轴上的取值y：需要绘制的line中点的在y轴上的取值yerr：指定y轴水平的误差xerr：指定x轴水平的误差fmt：指定折线图中某个点的颜色，形状，线条风格，例如‘co–’ecolor：指定error bar的颜色elinewidth：指定error bar的线条宽度绘制errorbar","code":"# 1. plot方法绘制\nx = range(0,5)\ny1 = [2,5,7,8,10]\ny2= [3,6,8,9,11]\n\nfig,ax= plt.subplots()\nax.plot(x,y1)\nax.plot(x,y2)\nprint(ax.lines)<Axes.ArtistList of 2 lines>plt.show() # 通过直接使用辅助方法画线，打印ax.lines后可以看到在matplotlib在底层创建了两个Line2D对象# 2. Line2D对象绘制\n\nx = range(0,5)\ny1 = [2,5,7,8,10]\ny2= [3,6,8,9,11]\nfig,ax= plt.subplots()\nlines = [Line2D(x, y1), Line2D(x, y2,color='orange')]  # 显式创建Line2D对象\nfor line in lines:\n    ax.add_line(line) # 使用add_line方法将创建的Line2D添加到子图中\nax.set_xlim(0,4)(0.0, 4.0)ax.set_ylim(2, 11)(2.0, 11.0)plt.show()fig = plt.figure()\nx = np.arange(10)\ny = 2.5 * np.sin(x / 20 * np.pi)\nyerr = np.linspace(0.05, 0.2, 10)\nplt.errorbar(x,y+3,yerr=yerr,fmt='o-',ecolor='r',elinewidth=2)\nplt.show()"},{"path":"matplotlib.html","id":"patches","chapter":"第7章 matplotlib","heading":"7.8.4 patches","text":"matplotlib.patches.Patch类是二维图形类，并且它是众多二维图形的父类，它的所有子类见matplotlib.patches API ，\nPatch类的构造函数：Patch(edgecolor=None, facecolor=None, color=None,\nlinewidth=None, linestyle=None, antialiased=None,\nhatch=None, fill=True, capstyle=None, joinstyle=None,\n**kwargs)本小节重点讲述三种最常见的子类，矩形，多边形和楔形。","code":""},{"path":"matplotlib.html","id":"rectangle-矩形","chapter":"第7章 matplotlib","heading":"7.8.4.1 Rectangle-矩形","text":"Rectangle矩形类在官网中的定义是： 通过锚点xy及其宽度和高度生成。\nRectangle本身的主要比较简单，即xy控制锚点，width和height分别控制宽和高。它的构造函数：class matplotlib.patches.Rectangle(xy, width, height, angle=0.0, **kwargs)在实际中最常见的矩形图是hist直方图和bar条形图。1) hist-直方图matplotlib.pyplot.hist(x,bins=None,range=None, density=None, bottom=None, histtype=‘bar’, align=‘mid’, log=False, color=None, label=None, stacked=False, normed=None)下面是一些常用的参数：x: 数据集，最终的直方图将对数据集进行统计bins: 统计的区间分布range: tuple, 显示的区间，range在没有给出bins时生效density: bool，默认为false，显示的是频数统计结果，为True则显示频率统计结果，这里需要注意，频率统计结果=区间数目/(总数*区间宽度)，和normed效果一致，官方推荐使用densityhisttype: 可选{‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’}之一，默认为bar，推荐使用默认配置，step使用的是梯状，stepfilled则会对梯状内部进行填充，效果与bar类似align: 可选{‘left’, ‘mid’, ‘right’}之一，默认为’mid’，控制柱状图的水平分布，left或者right，会有部分空白区域，推荐使用默认log: bool，默认False,即y坐标轴是否选择指数刻度stacked: bool，默认为False，是否为堆积状图2) bar-柱状图matplotlib.pyplot.bar(left, height, alpha=1, width=0.8, color=, edgecolor=, label=, lw=3)下面是一些常用的参数：left：x轴的位置序列，一般采用range函数产生一个序列，但是有时候可以是字符串height：y轴的数值序列，也就是柱形图的高度，一般就是我们需要展示的数据；alpha：透明度，值越小越透明width：为柱形图的宽度，一般这是为0.8即可；color或facecolor：柱形图填充的颜色；edgecolor：图形边缘颜色label：解释每个图像代表的含义，这个参数是为legend()函数做铺垫的，表示该次bar的标签有两种方式绘制柱状图bar绘制柱状图Rectangle矩形类绘制柱状图","code":"# hist绘制直方图\nx=np.random.randint(0,100,100) #生成[0-100)之间的100个数据,即 数据集 \nbins=np.arange(0,101,10) #设置连续的边界值，即直方图的分布区间[0,10),[10,20)... \nplt.hist(x,bins,color='fuchsia',alpha=0.5)#alpha设置透明度，0为完全透明 \nplt.xlabel('scores') \nplt.ylabel('count') \nplt.xlim(0,100)(0.0, 100.0)plt.show() #设置x轴分布范围 plt.show()# Rectangle矩形类绘制直方图\n#df = pd.DataFrame(columns = ['data'])\n#df.loc[:,'data'] = x\n#df['fenzu'] = pd.cut(df['data'], bins=bins, right = False,include_lowest=True)\n\n#df_cnt = df['fenzu'].value_counts().reset_index()\n#df_cnt.loc[:,'mini'] = df_cnt['index'].astype(str).map(lambda x:re.findall('\\[(.*)\\,',x)[0]).astype(int)\n#df_cnt.loc[:,'maxi'] = df_cnt['index'].astype(str).map(lambda x:re.findall('\\,(.*)\\)',x)[0]).astype(int)\n#df_cnt.loc[:,'width'] = df_cnt['maxi']- df_cnt['mini']\n#df_cnt.sort_values('mini',ascending = True,inplace = True)\n#df_cnt.reset_index(inplace = True,drop = True)\n\n#用Rectangle把hist绘制出来\n\n#fig = plt.figure()\n#ax1 = fig.add_subplot(111)\n\n#for i in df_cnt.index:\n#    rect =  plt.Rectangle((df_cnt.loc[i,'mini'],0),df_cnt.loc[i,'width'],df_cnt.loc[i,'fenzu'])\n#    ax1.add_patch(rect)\n\n#ax1.set_xlim(0, 100)\n#ax1.set_ylim(0, 16)\n#plt.show()# bar绘制柱状图\ny = range(1,17)\nplt.bar(np.arange(16), y, alpha=0.5, width=0.5, color='yellow', edgecolor='red', label='The First Bar', lw=3)\nplt.show()# Rectangle矩形类绘制柱状图\nfig = plt.figure()\nax1 = fig.add_subplot(111)\n\nfor i in range(1,17):\n    rect =  plt.Rectangle((i+0.25,0),0.5,i)\n    ax1.add_patch(rect)\nax1.set_xlim(0, 16)(0.0, 16.0)ax1.set_ylim(0, 16)(0.0, 16.0)plt.show()"},{"path":"matplotlib.html","id":"polygon-多边形","chapter":"第7章 matplotlib","heading":"7.8.4.2 Polygon-多边形","text":"matplotlib.patches.Polygon类是多边形类。它的构造函数：class matplotlib.patches.Polygon(xy, closed=True, **kwargs)xy是一个N×2的numpy array，为多边形的顶点。\nclosed为True则指定多边形将起点和终点重合从而显式关闭多边形。matplotlib.patches.Polygon类中常用的是fill类，它是基于xy绘制一个填充的多边形，它的定义：matplotlib.pyplot.fill(*args, data=None, **kwargs)参数说明 : 关于x、y和color的序列，其中color是可选的参数，每个多边形都是由其节点的x和y位置列表定义的，后面可以选择一个颜色说明符。您可以通过提供多个x、y、颜色组来绘制多个多边形。","code":"# 用fill来绘制图形\nx = np.linspace(0, 5 * np.pi, 1000) \ny1 = np.sin(x)\ny2 = np.sin(2 * x) \nplt.fill(x, y1, color = \"g\", alpha = 0.3)\nplt.show()"},{"path":"matplotlib.html","id":"wedge-契形","chapter":"第7章 matplotlib","heading":"7.8.4.3 Wedge-契形","text":"matplotlib.patches.Wedge类是楔型类。其基类是matplotlib.patches.Patch，它的构造函数：class matplotlib.patches.Wedge(center, r, theta1, theta2, width=None, **kwargs)一个Wedge-楔型 是以坐标x,y为中心，半径为r，从θ1扫到θ2(单位是度)。\n如果宽度给定，则从内半径r -宽度到外半径r画出部分楔形。wedge中比较常见的是绘制饼状图。matplotlib.pyplot.pie语法：matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=0, radius=1, counterclock=True, wedgeprops=None, textprops=None, center=0, 0, frame=False, rotatelabels=False, *, normalize=None, data=None)制作数据x的饼图，每个楔子的面积用x/sum(x)表示。\n其中最主要的参数是前4个：x：楔型的形状，一维数组。explode：如果不是等于None，则是一个len(x)数组，它指定用于偏移每个楔形块的半径的分数。labels：用于指定每个楔型块的标记，取值是列表或为None。colors：饼图循环使用的颜色序列。如果取值为None，将使用当前活动循环中的颜色。startangle：饼状图开始的绘制的角度。","code":"# pie绘制饼状图\nlabels = 'Frogs', 'Hogs', 'Dogs', 'Logs'\nsizes = [15, 30, 45, 10] \nexplode = (0, 0.1, 0, 0) \nfig1, ax1 = plt.subplots() \nax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90) ([<matplotlib.patches.Wedge object at 0x000001D086F5D3D0>, <matplotlib.patches.Wedge object at 0x000001D0832055E0>, <matplotlib.patches.Wedge object at 0x000001D086729970>, <matplotlib.patches.Wedge object at 0x000001D086729490>], [Text(-0.4993895680663527, 0.9801071672559598, 'Frogs'), Text(-1.1412677917792124, -0.3708204787324995, 'Hogs'), Text(0.9801072140121813, -0.4993894763020948, 'Dogs'), Text(0.33991864973549485, 1.0461621822461364, 'Logs')], [Text(-0.2723943098543742, 0.5346039094123416, '15.0%'), Text(-0.6657395452045406, -0.2163119459272914, '30.0%'), Text(0.5346039349157352, -0.27239425980114257, '45.0%'), Text(0.1854101725829972, 0.5706339175888016, '10.0%')])ax1.axis('equal')(-1.1998593997207165, 1.1047438740833693, -1.0999843660947275, 1.0999992555283205)plt.show() # Equal aspect ratio ensures that pie is drawn as a circle. # wedge绘制饼图\nfig = plt.figure(figsize=(5,5))\nax1 = fig.add_subplot(111)\ntheta1 = 0\nsizes = [15, 30, 45, 10] \npatches = []\npatches += [\n    Wedge((0.5, 0.5), .4, 0, 54),           \n    Wedge((0.5, 0.5), .4, 54, 162),  \n    Wedge((0.5, 0.5), .4, 162, 324),           \n    Wedge((0.5, 0.5), .4, 324, 360),  \n]\ncolors = 100 * np.random.rand(len(patches))\np = PatchCollection(patches, alpha=0.8)\np.set_array(colors)\nax1.add_collection(p)\nplt.show()"},{"path":"matplotlib.html","id":"collections","chapter":"第7章 matplotlib","heading":"7.8.5 collections","text":"collections类是用来绘制一组对象的集合，collections有许多不同的子类，如RegularPolyCollection, CircleCollection, Pathcollection, 分别对应不同的集合子类型。其中比较常用的就是散点图，它是属于PathCollection子类，scatter方法提供了该类的封装，根据x与y绘制不同大小或颜色标记的散点图。 它的构造方法：Axes.scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=, edgecolors=None, *, plotnonfinite=False, data=None, **kwargs)其中最主要的参数是前5个：x：数据点x轴的位置y：数据点y轴的位置s：尺寸大小c：可以是单个颜色格式的字符串，也可以是一系列颜色marker: 标记的类型","code":"# 用scatter绘制散点图\nx = [0,2,4,6,8,10] \ny = [10]*len(x) \ns = [20*2**n for n in range(len(x))] \nplt.scatter(x,y,s=s) \nplt.show()"},{"path":"matplotlib.html","id":"images","chapter":"第7章 matplotlib","heading":"7.8.6 images","text":"images是matplotlib中绘制image图像的类，其中最常用的imshow可以根据数组绘制成图像，它的构造函数：class matplotlib.image.AxesImage(ax, cmap=None, norm=None, interpolation=None, origin=None, extent=None, filternorm=True, filterrad=4.0, resample=False, **kwargs)imshow根据数组绘制图像matplotlib.pyplot.imshow(X, cmap=None, norm=None, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, shape=, filternorm=1, filterrad=4.0, imlim=, resample=None, url=None, *, data=None, **kwargs）使用imshow画图时首先需要传入一个数组，数组对应的是空间内的像素位置和像素点的值，interpolation参数可以设置不同的差值方法，具体效果如下。","code":"methods = [None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16',\n           'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',\n           'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']\n\ngrid = np.random.rand(4, 4)\n\nfig, axs = plt.subplots(nrows=3, ncols=6, figsize=(9, 6),\n                        subplot_kw={'xticks': [], 'yticks': []})\n\nfor ax, interp_method in zip(axs.flat, methods):\n    ax.imshow(grid, interpolation=interp_method, cmap='viridis')\n    ax.set_title(str(interp_method))\n\nplt.tight_layout()\nplt.show()"},{"path":"matplotlib.html","id":"对象容器---object-container","chapter":"第7章 matplotlib","heading":"7.9 对象容器 - Object container","text":"容器会包含一些primitives，并且容器还有它自身的属性。\n比如Axes Artist，它是一种容器，它包含了很多primitives，比如Line2D，Text；同时，它也有自身的属性，比如xscal，用来控制X轴是linear还是log的。","code":""},{"path":"matplotlib.html","id":"figure容器","chapter":"第7章 matplotlib","heading":"7.9.1 Figure容器","text":"matplotlib.figure.Figure是Artist最顶层的container对象容器，它包含了图表中的所有元素。一张图表的背景就是在Figure.patch的一个矩形Rectangle。\n当我们向图表添加Figure.add_subplot()或者Figure.add_axes()元素时，这些都会被添加到Figure.axes列表中。由于Figure维持了current axes，因此你不应该手动的从Figure.axes列表中添加删除元素，而是要通过Figure.add_subplot()、Figure.add_axes()来添加元素，通过Figure.delaxes()来删除元素。但是你可以迭代或者访问Figure.axes中的Axes，然后修改这个Axes的属性。比如下面的遍历axes里的内容，并且添加网格线：Figure也有它自己的text、line、patch、image。你可以直接通过add primitive语句直接添加。但是注意Figure默认的坐标系是以像素为单位，你可能需要转换成figure坐标系：(0,0)表示左下点，(1,1)表示右上点。Figure容器的常见属性：Figure.patch属性：Figure的背景矩形Figure.axes属性：一个Axes实例的列表（包括Subplot)Figure.images属性：一个FigureImages patch列表Figure.lines属性：一个Line2D实例的列表（很少使用）Figure.legends属性：一个Figure Legend实例列表（不同于Axes.legends)Figure.texts属性：一个Figure Text实例列表","code":"fig = plt.figure()\nax1 = fig.add_subplot(211) # 作一幅2*1的图，选择第1个子图\nax2 = fig.add_axes([0.1, 0.1, 0.7, 0.3]) # 位置参数，四个数分别代表了(left,bottom,width,height)\nprint(ax1) Axes(0.125,0.53;0.775x0.35)print(fig.axes) # fig.axes 中包含了subplot和axes两个实例, 刚刚添加的[<Axes: >, <Axes: >]fig = plt.figure()\nax1 = fig.add_subplot(211)\n\nfor ax in fig.axes:\n    ax.grid(True)"},{"path":"matplotlib.html","id":"axes容器","chapter":"第7章 matplotlib","heading":"7.9.2 Axes容器","text":"matplotlib.axes.Axes是matplotlib的核心。大量的用于绘图的Artist存放在它内部，并且它有许多辅助方法来创建和添加Artist给它自己，而且它也有许多赋值方法来访问和修改这些Artist。和Figure容器类似，Axes包含了一个patch属性，对于笛卡尔坐标系而言，它是一个Rectangle；对于极坐标而言，它是一个Circle。这个patch属性决定了绘图区域的形状、背景和边框。Axes有许多方法用于绘图，如.plot()、.text()、.hist()、.imshow()等方法用于创建大多数常见的primitive(如Line2D，Rectangle，Text，Image等等）。在primitives中已经涉及，不再赘述。Subplot就是一个特殊的Axes，其实例是位于网格中某个区域的Subplot实例。其实你也可以在任意区域创建Axes，通过Figure.add_axes([left,bottom,width,height])来创建一个任意区域的Axes，其中left,bottom,width,height都是[0—1]之间的浮点数，他们代表了相对于Figure的坐标。你不应该直接通过Axes.lines和Axes.patches列表来添加图表。因为当创建或添加一个对象到图表中时，Axes会做许多自动化的工作:\n它会设置Artist中figure和axes的属性，同时默认Axes的转换；\n它也会检视Artist中的数据，来更新数据结构，这样数据范围和呈现方式可以根据作图范围自动调整。你也可以使用Axes的辅助方法.add_line()和.add_patch()方法来直接添加。另外Axes还包含两个最重要的Artist container：ax.xaxis：XAxis对象的实例，用于处理x轴tick以及label的绘制ax.yaxis：YAxis对象的实例，用于处理y轴tick以及label的绘制Axes容器的常见属性有：artists: Artist实例列表patch: Axes所在的矩形实例collections: Collection实例images: Axes图像legends: Legend 实例lines: Line2D 实例patches: Patch 实例texts: Text 实例xaxis: matplotlib.axis.XAxis 实例yaxis: matplotlib.axis.YAxis 实例","code":"fig = plt.figure()\nax = fig.add_subplot(111)\nrect = ax.patch  # axes的patch是一个Rectangle实例\nrect.set_facecolor('green')"},{"path":"matplotlib.html","id":"axis容器","chapter":"第7章 matplotlib","heading":"7.9.3 Axis容器","text":"matplotlib.axis.Axis实例处理tick line、grid line、tick label以及axis label的绘制，它包括坐标轴上的刻度线、刻度label、坐标网格、坐标轴标题。通常你可以独立的配置y轴的左边刻度以及右边的刻度，也可以独立地配置x轴的上边刻度以及下边的刻度。刻度包括主刻度和次刻度，它们都是Tick刻度对象。Axis也存储了用于自适应，平移以及缩放的data_interval和view_interval。它还有Locator实例和Formatter实例用于控制刻度线的位置以及刻度label。每个Axis都有一个label属性，也有主刻度列表和次刻度列表。这些ticks是axis.XTick和axis.YTick实例，它们包含着line primitive以及text primitive用来渲染刻度线以及刻度文本。刻度是动态创建的，只有在需要创建的时候才创建（比如缩放的时候）。Axis也提供了一些辅助方法来获取刻度文本、刻度线位置等等：\n常见的如下：下面的例子展示了如何调整一些轴和刻度的属性(忽略美观度，仅作调整参考)：","code":"# 不用print，直接显示结果\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\nfig, ax = plt.subplots()\nx = range(0,5)\ny = [2,5,7,8,10]\nplt.plot(x, y, '-')\n\naxis = ax.xaxis # axis为X轴对象\naxis.get_ticklocs()     # 获取刻度线位置array([-0.5,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5])axis.get_ticklabels()   # 获取刻度label列表(一个Text实例的列表）。 可以通过minor=True|False关键字参数控制输出minor还是major的tick label。\naxis.get_ticklines()    # 获取刻度线列表(一个Line2D实例的列表）。 可以通过minor=True|False关键字参数控制输出minor还是major的tick line。\naxis.get_data_interval()# 获取轴刻度间隔array([0., 4.])axis.get_view_interval()# 获取轴视角（位置）的间隔array([-0.2,  4.2])fig = plt.figure() # 创建一个新图表\nrect = fig.patch   # 矩形实例并将其设为黄色\nrect.set_facecolor('lightgoldenrodyellow')\n\nax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4]) # 创一个axes对象，从(0.1,0.3)的位置开始，宽和高都为0.4，\nrect = ax1.patch   # ax1的矩形设为灰色\nrect.set_facecolor('lightslategray')\n\nfor label in ax1.xaxis.get_ticklabels(): \n    # 调用x轴刻度标签实例，是一个text实例\n    label.set_color('red') # 颜色\n    label.set_rotation(45) # 旋转角度\n    label.set_fontsize(16) # 字体大小\n\nfor line in ax1.yaxis.get_ticklines():\n    # 调用y轴刻度线条实例, 是一个Line2D实例\n    line.set_markeredgecolor('green')    # 颜色\n    line.set_markersize(25)    # marker大小\n    line.set_markeredgewidth(2)# marker粗细"},{"path":"matplotlib.html","id":"tick容器","chapter":"第7章 matplotlib","heading":"7.9.4 Tick容器","text":"matplotlib.axis.Tick是从Figure到Axes到Axis到Tick中最末端的容器对象。Tick包含了tick、grid line实例以及对应的label。所有的这些都可以通过Tick的属性获取，常见的tick属性有Tick.tick1line：Line2D实例Tick.tick2line：Line2D实例Tick.gridline：Line2D实例Tick.label1：Text实例Tick.label2：Text实例y轴分为左右两个，因此tick1对应左侧的轴；tick2对应右侧的轴。\nx轴分为上下两个，因此tick1对应下侧的轴；tick2对应上侧的轴。下面的例子展示了，如何将Y轴右边轴设为主轴，并将标签设置为美元符号且为绿色：","code":"fig, ax = plt.subplots()\nax.plot(100*np.random.rand(20))\n\n# 设置ticker的显示格式\nformatter = mpl.ticker.FormatStrFormatter('$%1.2f')\nax.yaxis.set_major_formatter(formatter)\n\n# 设置ticker的参数，右侧为主轴，颜色为绿色\nax.yaxis.set_tick_params(which='major', labelcolor='green',\n                         labelleft=False, labelright=True)\nplt.show()"},{"path":"matplotlib.html","id":"思考题-1","chapter":"第7章 matplotlib","heading":"7.10 思考题","text":"primitives 和 container的区别和联系是什么，分别用于控制可视化图表中的哪些要素primitives 和 container的区别和联系是什么，分别用于控制可视化图表中的哪些要素使用提供的drug数据集，对第一列yyyy和第二列state分组求和，画出下面折线图。PA加粗标黄，其他为灰色。\n图标题和横纵坐标轴标题，以及线的文本暂不做要求。使用提供的drug数据集，对第一列yyyy和第二列state分组求和，画出下面折线图。PA加粗标黄，其他为灰色。\n图标题和横纵坐标轴标题，以及线的文本暂不做要求。分别用一组长方形柱和填充面积的方式模仿画出下图，函数 y = -1 * (x - 2) * (x - 8) +10 在区间[2,9]的积分面积","code":""},{"path":"matplotlib.html","id":"参考资料","chapter":"第7章 matplotlib","heading":"7.11 参考资料","text":"1. matplotlib设计的基本逻辑2. AI算法工程师手册","code":""},{"path":"matplotlib.html","id":"子图","chapter":"第7章 matplotlib","heading":"7.12 子图","text":"","code":""},{"path":"matplotlib.html","id":"使用-plt.subplots-绘制均匀状态下的子图","chapter":"第7章 matplotlib","heading":"7.12.1 使用 plt.subplots 绘制均匀状态下的子图","text":"返回元素分别是画布和子图构成的列表，第一个数字为行，第二个为列，不传入时默认值都为1figsize 参数可以指定整个画布的大小sharex 和 sharey 分别表示是否共享横轴和纵轴刻度tight_layout 函数可以调整子图的相对大小使字符不会重叠subplots是基于OO模式的写法，显式创建一个或多个axes对象，然后在对应的子图对象上进行绘图操作。\n还有种方式是使用subplot这样基于pyplot模式的写法，每次在指定位置新建一个子图，并且之后的绘图操作都会指向当前子图，本质上subplot也是Figure.add_subplot的一种封装。在调用subplot时一般需要传入三位数字，分别代表总行数，总列数，当前子图的index除了常规的直角坐标系，也可以通过projection方法创建极坐标系下的图表\n请思考如何用极坐标系画出类似的玫瑰图\n","code":"fig, axs = plt.subplots(2, 5, figsize=(10, 4), sharex=True, sharey=True)\nfig.suptitle('样例1', size=20)\nfor i in range(2):\n    for j in range(5):\n        axs[i][j].scatter(np.random.randn(10), np.random.randn(10))\n        axs[i][j].set_title('第%d行，第%d列'%(i+1,j+1))\n        axs[i][j].set_xlim(-5,5)\n        axs[i][j].set_ylim(-5,5)\n        if i==1: axs[i][j].set_xlabel('横坐标')\n        if j==0: axs[i][j].set_ylabel('纵坐标')\nfig.tight_layout()plt.figure()\n# 子图1\nplt.subplot(2,2,1) \nplt.plot([1,2], 'r')\n# 子图2\nplt.subplot(2,2,2)\nplt.plot([1,2], 'b')\n#子图3\nplt.subplot(224)  # 当三位数都小于10时，可以省略中间的逗号，这行命令等价于plt.subplot(2,2,4) \nplt.plot([1,2], 'g')\nplt.show()N = 150\nr = 2 * np.random.rand(N)\ntheta = 2 * np.pi * np.random.rand(N)\narea = 200 * r**2\ncolors = theta\n\nplt.subplot(projection='polar')\nplt.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)\nplt.show()"},{"path":"matplotlib.html","id":"使用-gridspec-绘制非均匀子图","chapter":"第7章 matplotlib","heading":"7.12.2 使用 GridSpec 绘制非均匀子图","text":"所谓非均匀包含两层含义，第一是指图的比例大小不同但没有跨行或跨列，第二是指图为跨列或跨行状态利用 add_gridspec 可以指定相对宽度比例 width_ratios 和相对高度比例参数 height_ratios在上面的例子中出现了 spec[, j] 的用法，事实上通过切片就可以实现子图的合并而达到跨图的共能","code":"fig = plt.figure(figsize=(10, 4))\nspec = fig.add_gridspec(nrows=2, ncols=5, width_ratios=[1,2,3,4,5], height_ratios=[1,3])\nfig.suptitle('样例2', size=20)\nfor i in range(2):\n    for j in range(5):\n        ax = fig.add_subplot(spec[i, j])\n        ax.scatter(np.random.randn(10), np.random.randn(10))\n        ax.set_title('第%d行，第%d列'%(i+1,j+1))\n        if i==1: ax.set_xlabel('横坐标')\n        if j==0: ax.set_ylabel('纵坐标')\nfig.tight_layout()\nplt.show()fig = plt.figure(figsize=(10, 4))\nspec = fig.add_gridspec(nrows=2, ncols=6, width_ratios=[2,2.5,3,1,1.5,2], height_ratios=[1,2])\nfig.suptitle('样例3', size=20)\n# sub1\nax = fig.add_subplot(spec[0, :3])\nax.scatter(np.random.randn(10), np.random.randn(10))\n# sub2\nax = fig.add_subplot(spec[0, 3:5])\nax.scatter(np.random.randn(10), np.random.randn(10))\n# sub3\nax = fig.add_subplot(spec[:, 5])\nax.scatter(np.random.randn(10), np.random.randn(10))\n# sub4\nax = fig.add_subplot(spec[1, 0])\nax.scatter(np.random.randn(10), np.random.randn(10))\n# sub5\nax = fig.add_subplot(spec[1, 1:5])\nax.scatter(np.random.randn(10), np.random.randn(10))\nfig.tight_layout()\nplt.show()"},{"path":"matplotlib.html","id":"子图上的方法","chapter":"第7章 matplotlib","heading":"7.13 子图上的方法","text":"补充介绍一些子图上的方法常用直线的画法为： axhline, axvline, axline （水平、垂直、任意方向）使用 grid 可以加灰色网格使用 set_xscale 可以设置坐标轴的规度（指对数坐标等）","code":"fig, ax = plt.subplots(figsize=(4,3))\nax.axhline(0.5,0.2,0.8)\nax.axvline(0.5,0.2,0.8)\nax.axline([0.3,0.3],[0.7,0.7])\nplt.show()fig, ax = plt.subplots(figsize=(4,3))\nax.grid(True)fig, axs = plt.subplots(1, 2, figsize=(10, 4))\nfor j in range(2):\n    axs[j].plot(list('abcd'), [10**i for i in range(4)])\n    if j==0:\n        axs[j].set_yscale('log')\n    else:\n        pass\nfig.tight_layout()"},{"path":"matplotlib.html","id":"思考题-2","chapter":"第7章 matplotlib","heading":"7.14 思考题","text":"墨尔本1981年至1990年的每月温度情况数据集来自github仓库下data/layout_ex1.csv\n请利用数据，画出如下的图：画出数据的散点图和边际分布用 np.random.randn(2, 150) 生成一组二维数据，使用两种非均匀子图的分割方法，做出该数据对应的散点图和边际分布图","code":""},{"path":"matplotlib.html","id":"figure和axes上的文本","chapter":"第7章 matplotlib","heading":"7.15 Figure和Axes上的文本","text":"Matplotlib具有广泛的文本支持，包括对数学表达式的支持、对栅格和矢量输出的TrueType支持、具有任意旋转的换行分隔文本以及Unicode支持。","code":""},{"path":"matplotlib.html","id":"文本api示例","chapter":"第7章 matplotlib","heading":"7.15.1 文本API示例","text":"下面的命令是介绍了通过pyplot API和objected-oriented API分别创建文本的方式。通过一个综合例子，以OO模式展示这些API是如何控制一个图像中各部分的文本，在之后的章节我们再详细分析这些api的使用技巧","code":"fig = plt.figure()\nax = fig.add_subplot()\n\n# 分别为figure和ax设置标题，注意两者的位置是不同的\nfig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')\nax.set_title('axes title')\n\n# 设置x和y轴标签\nax.set_xlabel('xlabel')\nax.set_ylabel('ylabel')\n\n# 设置x和y轴显示范围均为0到10\nax.axis([0, 10, 0, 10])(0.0, 10.0, 0.0, 10.0)# 在子图上添加文本\nax.text(3, 8, 'boxed italics text in data coords', style='italic',\n        bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 10})\n\n# 在画布上添加文本，一般在子图上添加文本是更常见的操作，这种方法很少用\nfig.text(0.4,0.8,'This is text for figure')\n\nax.plot([2], [1], 'o')\n# 添加注解\nax.annotate('annotate', xy=(2, 1), xytext=(3, 4),arrowprops=dict(facecolor='black', shrink=0.05))\nplt.show()"},{"path":"matplotlib.html","id":"text---子图上的文本","chapter":"第7章 matplotlib","heading":"7.15.2 text - 子图上的文本","text":"text的调用方式为Axes.text(x, y, s, fontdict=None, **kwargs)\n其中x,y为文本出现的位置，默认状态下即为当前坐标系下的坐标值，s为文本的内容，fontdict是可选参数，用于覆盖默认的文本属性，**kwargs为关键字参数，也可以用于传入文本样式参数重点解释下fontdict和**kwargs参数，这两种方式都可以用于调整呈现的文本样式，最终效果是一样的，不仅text方法，其他文本方法如set_xlabel,set_title等同样适用这两种方式修改样式。通过一个例子演示这两种方法是如何使用的。matplotlib中所有支持的样式参数请参考官网文档说明，大多数时候需要用到的时候再查询即可。下表列举了一些常用的参数供参考。","code":"fig = plt.figure(figsize=(10,3))\naxes = fig.subplots(1,2)\n\n# 使用关键字参数修改文本样式\naxes[0].text(0.3, 0.8, 'modify by **kwargs', style='italic',\n        bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 10});\n\n# 使用fontdict参数修改文本样式\nfont = {'bbox':{'facecolor': 'red', 'alpha': 0.5, 'pad': 10}, 'style':'italic'}\naxes[1].text(0.3, 0.8, 'modify by fontdict', fontdict=font)\nplt.show()"},{"path":"matplotlib.html","id":"xlabel和ylabel---子图的xy轴标签","chapter":"第7章 matplotlib","heading":"7.15.3 xlabel和ylabel - 子图的x，y轴标签","text":"xlabel的调用方式为Axes.set_xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)\nylabel方式类似，这里不重复写出。\n其中xlabel即为标签内容,fontdict和**kwargs用来修改样式，上一小节已介绍,labelpad为标签和坐标轴的距离，默认为4，loc为标签位置，可选的值为’left’, ‘center’, ’right’之一，默认为居中","code":"# 观察labelpad和loc参数的使用效果\nfig = plt.figure(figsize=(10,3))\naxes = fig.subplots(1,2)\naxes[0].set_xlabel('xlabel',labelpad=20,loc='left')\n\n# loc参数仅能提供粗略的位置调整，如果想要更精确的设置标签的位置，可以使用position参数+horizontalalignment参数来定位\n# position由一个元组过程，第一个元素0.2表示x轴标签在x轴的位置，第二个元素对于xlabel其实是无意义的，随便填一个数都可以\n# horizontalalignment='left'表示左对齐，这样设置后x轴标签就能精确定位在x=0.2的位置处\naxes[1].set_xlabel('xlabel', position=(0.2, _), horizontalalignment='left')\nplt.show()"},{"path":"matplotlib.html","id":"title和suptitle---子图和画布的标题","chapter":"第7章 matplotlib","heading":"7.15.4 title和suptitle - 子图和画布的标题","text":"title的调用方式为Axes.set_title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)\n其中label为子图标签的内容，fontdict,loc,**kwargs和之前小节相同不重复介绍pad是指标题偏离图表顶部的距离，默认为6y是title所在子图垂向的位置。默认值为1，即title位于子图的顶部。suptitle的调用方式为figure.suptitle(t, **kwargs)\n其中t为画布的标题内容","code":"# 观察pad参数的使用效果\nfig = plt.figure(figsize=(10,3))\nfig.suptitle('This is figure title',y=1.2) # 通过参数y设置高度\naxes = fig.subplots(1,2)\naxes[0].set_title('This is title',pad=15)\naxes[1].set_title('This is title',pad=6)\nplt.show()"},{"path":"matplotlib.html","id":"annotate---子图的注解","chapter":"第7章 matplotlib","heading":"7.15.5 annotate - 子图的注解","text":"annotate的调用方式为Axes.annotate(text, xy, *args, **kwargs)\n其中text为注解的内容，xy为注解箭头指向的坐标，\n其他常用的参数包括：xytext为注解文字的坐标，xycoords用来定义xy参数的坐标系，textcoords用来定义xytext参数的坐标系，arrowprops用来定义指向箭头的样式annotate的参数非常复杂，这里仅仅展示一个简单的例子，更多参数可以查看官方文档中的annotate介绍","code":"fig = plt.figure()\nax = fig.add_subplot()\nax.annotate(\"\",\n            xy=(0.2, 0.2), xycoords='data',\n            xytext=(0.8, 0.8), textcoords='data',\n            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=0.2\")\n            )\nplt.show()"},{"path":"matplotlib.html","id":"字体的属性设置","chapter":"第7章 matplotlib","heading":"7.15.6 字体的属性设置","text":"字体设置一般有全局字体设置和自定义局部字体设置两种方法。为方便在图中加入合适的字体，可以尝试了解中文字体的英文名称,该链接告诉了常用中文的英文名称","code":"#该block讲述如何在matplotlib里面，修改字体默认属性，完成全局字体的更改。\nplt.rcParams['font.sans-serif'] = ['SimSun']    # 指定默认字体为新宋体。\nplt.rcParams['axes.unicode_minus'] = False      # 解决保存图像时 负号'-' 显示为方块和报错的问题。#局部字体的修改方法1\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nplt.plot(x, label='小示例图标签')\n\n# 直接用字体的名字\nplt.xlabel('x 轴名称参数', fontproperties='Microsoft YaHei', fontsize=16)         # 设置x轴名称，采用微软雅黑字体\nplt.ylabel('y 轴名称参数', fontproperties='Microsoft YaHei', fontsize=14)         # 设置Y轴名称\nplt.title('坐标系的标题',  fontproperties='Microsoft YaHei', fontsize=20)         # 设置坐标系标题的字体\nplt.legend(loc='lower right', prop={\"family\": 'Microsoft YaHei'}, fontsize=10) \nplt.show()   # 小示例图的字体设置"},{"path":"matplotlib.html","id":"tick上的文本","chapter":"第7章 matplotlib","heading":"7.16 Tick上的文本","text":"设置tick（刻度）和ticklabel（刻度标签）也是可视化中经常需要操作的步骤，matplotlib既提供了自动生成刻度和刻度标签的模式（默认状态），同时也提供了许多让使用者灵活设置的方式。","code":""},{"path":"matplotlib.html","id":"简单模式","chapter":"第7章 matplotlib","heading":"7.16.1 简单模式","text":"可以使用axis的set_ticks方法手动设置标签位置，使用axis的set_ticklabels方法手动设置标签格式","code":"x1 = np.linspace(0.0, 5.0, 100)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)# 使用axis的set_ticks方法手动设置标签位置的例子，该案例中由于tick设置过大，所以会影响绘图美观，不建议用此方式进行设置tick\nfig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\naxs[1].xaxis.set_ticks(np.arange(0., 10.1, 2.))\nplt.show()# 使用axis的set_ticklabels方法手动设置标签格式的例子\nfig, axs = plt.subplots(2, 1, figsize=(5, 3), tight_layout=True)\naxs[0].plot(x1, y1)\naxs[1].plot(x1, y1)\nticks = np.arange(0., 8.1, 2.)\ntickla = [f'{tick:1.2f}' for tick in ticks]\naxs[1].xaxis.set_ticks(ticks)\naxs[1].xaxis.set_ticklabels(tickla)\nplt.show()#一般绘图时会自动创建刻度，而如果通过上面的例子使用set_ticks创建刻度可能会导致tick的范围与所绘制图形的范围不一致的问题。\n#所以在下面的案例中，axs[1]中set_xtick的设置要与数据范围所对应，然后再通过set_xticklabels设置刻度所对应的标签\nimport numpy as np\nimport matplotlib.pyplot as plt\nfig, axs = plt.subplots(2, 1, figsize=(6, 4), tight_layout=True)\nx1 = np.linspace(0.0, 6.0, 100)\ny1 = np.cos(2 * np.pi * x1) * np.exp(-x1)\naxs[0].plot(x1, y1)\naxs[0].set_xticks([0,1,2,3,4,5,6])\n\naxs[1].plot(x1, y1)\naxs[1].set_xticks([0,1,2,3,4,5,6])#要将x轴的刻度放在数据范围中的哪些位置\naxs[1].set_xticklabels(['zero','one', 'two', 'three', 'four', 'five','six'],#设置刻度对应的标签\n                   rotation=30, fontsize='small')#rotation选项设定x刻度标签倾斜30度。\naxs[1].xaxis.set_ticks_position('bottom')#set_ticks_position()方法是用来设置刻度所在的位置，常用的参数有bottom、top、both、none\nprint(axs[1].xaxis.get_ticklines())<a list of 14 Line2D ticklines objects>plt.show()"},{"path":"matplotlib.html","id":"tick-locators-and-formatters","chapter":"第7章 matplotlib","heading":"7.16.2 Tick Locators and Formatters","text":"除了上述的简单模式，还可以使用Tick Locators Formatters完成对于刻度位置和刻度标签的设置。\n其中Axis.set_major_locator和Axis.set_minor_locator方法用来设置标签的位置，Axis.set_major_formatter和Axis.set_minor_formatter方法用来设置标签的格式。这种方式的好处是不用显式地列举出刻度值列表。set_major_formatter和set_minor_formatter这两个formatter格式命令可以接收字符串格式（matplotlib.ticker.StrMethodFormatter）或函数参数（matplotlib.ticker.FuncFormatter）来设置刻度值的格式 。","code":""},{"path":"matplotlib.html","id":"tick-formatters","chapter":"第7章 matplotlib","heading":"7.16.3 Tick Formatters","text":"","code":"# 接收字符串格式的例子\nfig, axs = plt.subplots(2, 2, figsize=(8, 5), tight_layout=True)\nfor n, ax in enumerate(axs.flat):\n    ax.plot(x1*10., y1)\n\nformatter = mpl.ticker.FormatStrFormatter('%1.1f')\naxs[0, 1].xaxis.set_major_formatter(formatter)\n\nformatter = mpl.ticker.FormatStrFormatter('-%1.1f')\naxs[1, 0].xaxis.set_major_formatter(formatter)\n\nformatter = mpl.ticker.FormatStrFormatter('%1.5f')\naxs[1, 1].xaxis.set_major_formatter(formatter)\nplt.show()# 接收函数的例子\ndef formatoddticks(x, pos):\n    \"\"\"Format odd tick positions.\"\"\"\n    if x % 2:\n        return f'{x:1.2f}'\n    else:\n        return ''\n\nfig, ax = plt.subplots(figsize=(5, 3), tight_layout=True)\nax.plot(x1, y1)\nax.xaxis.set_major_formatter(formatoddticks)\nplt.show()"},{"path":"matplotlib.html","id":"tick-locators","chapter":"第7章 matplotlib","heading":"7.16.4 Tick Locators","text":"在普通的绘图中，我们可以直接通过上图的set_ticks进行设置刻度的位置，缺点是需要自己指定或者接受matplotlib默认给定的刻度。当需要更改刻度的位置时，matplotlib给了常用的几种locator的类型。如果要绘制更复杂的图，可以先设置locator的类型，然后通过axs.xaxis.set_major_locator(locator)绘制即可此外matplotlib.dates 模块还提供了特殊的设置日期型刻度格式和位置的方式","code":"locator=plt.MaxNLocator(nbins=7)#自动选择合适的位置，并且刻度之间最多不超过7（nbins）个间隔\nlocator=plt.FixedLocator(locs=[0,0.5,1.5,2.5,3.5,4.5,5.5,6])#直接指定刻度所在的位置  \nlocator=plt.AutoLocator()#自动分配刻度值的位置  \nlocator=plt.IndexLocator(offset=0.5, base=1)#面元间距是1，从0.5开始  \nlocator=plt.MultipleLocator(1.5)#将刻度的标签设置为1.5的倍数  \nlocator=plt.LinearLocator(numticks=5)#线性划分5等分，4个刻度  # 接收各种locator的例子\nfig, axs = plt.subplots(2, 2, figsize=(8, 5), tight_layout=True)\nfor n, ax in enumerate(axs.flat):\n    ax.plot(x1*10., y1)\n\nlocator = mpl.ticker.AutoLocator()\naxs[0, 0].xaxis.set_major_locator(locator)\n\nlocator = mpl.ticker.MaxNLocator(nbins=3)\naxs[0, 1].xaxis.set_major_locator(locator)\n\nlocator = mpl.ticker.MultipleLocator(5)\naxs[1, 0].xaxis.set_major_locator(locator)\n\nlocator = mpl.ticker.FixedLocator([0,7,14,21,28])\naxs[1, 1].xaxis.set_major_locator(locator)\nplt.show()# 特殊的日期型locator和formatter\nlocator = mdates.DayLocator(bymonthday=[1,15,25])\nformatter = mdates.DateFormatter('%b %d')\n\nfig, ax = plt.subplots(figsize=(5, 3), tight_layout=True)\nax.xaxis.set_major_locator(locator)\nax.xaxis.set_major_formatter(formatter)\nbase = datetime.datetime(2017, 1, 1, 0, 0, 1)\ntime = [base + datetime.timedelta(days=x) for x in range(len(x1))]\nax.plot(time, y1)\nax.tick_params(axis='x', rotation=70)\nplt.show()"},{"path":"matplotlib.html","id":"legend图例","chapter":"第7章 matplotlib","heading":"7.17 legend（图例）","text":"在具体学习图例之前，首先解释几个术语：legend entry（图例条目)\n每个图例由一个或多个legend entries组成。一个entry包含一个key和其对应的label。legend key（图例键)\n每个legend label左面的colored/patterned marker（彩色/图案标记）legend label（图例标签)\n描述由key来表示的handle的文本legend handle（图例句柄)\n用于在图例中生成适当图例条目的原始对象以下面这个图为例，右侧的方框中的共有两个legend entry；两个legend key，分别是一个蓝色和一个黄色的legend key；两个legend label，一个名为‘Line ’和一个名为‘Line ’的legend label图例的绘制同样有OO模式和pyplot模式两种方式，写法都是一样的，使用legend()即可调用。\n以下面的代码为例，在使用legend方法时，我们可以手动传入两个变量，句柄和标签，用以指定条目中的特定绘图对象和显示的标签值。\n当然通常更简单的操作是不传入任何参数，此时matplotlib会自动寻找合适的图例条目。legend其他常用的几个参数如下：设置图例位置\nloc参数接收一个字符串或数字表示图例出现的位置\nax.legend(loc=‘upper center’) 等同于ax.legend(loc=9)设置图例边框及背景​设置图例标题","code":"fig, ax = plt.subplots()\nline_up, = ax.plot([1, 2, 3], label='Line 2')\nline_down, = ax.plot([3, 2, 1], label='Line 1')\nax.legend(handles = [line_up, line_down], labels = ['Line Up', 'Line Down'])\nplt.show()fig,axes = plt.subplots(1,4,figsize=(10,4))\nfor i in range(4):\n    axes[i].plot([0.5],[0.5])\n    axes[i].legend(labels='a',loc=i)  # 观察loc参数传入不同值时图例的位置\nfig.tight_layout()fig = plt.figure(figsize=(10,3))\naxes = fig.subplots(1,3)\nfor i, ax in enumerate(axes):\n    ax.plot([1,2,3],label=f'ax {i}')\naxes[0].legend(frameon=False) #去掉图例边框\naxes[1].legend(edgecolor='blue') #设置图例边框颜色\naxes[2].legend(facecolor='gray')\nplt.show() #设置图例背景颜色,若无边框,参数无效fig,ax =plt.subplots()\nax.plot([1,2,3],label='label')\nax.legend(title='legend title')\nplt.show()"},{"path":"matplotlib.html","id":"思考题-3","chapter":"第7章 matplotlib","heading":"7.18 思考题","text":"请尝试使用两种方式模仿画出下面的图表(重点是柱状图上的标签)，本文学习的text方法和matplotlib自带的柱状图标签方法bar_label第五回详细介绍matplotlib中样式和颜色的使用，绘图样式和颜色是丰富可视化图表的重要手段，因此熟练掌握本章可以让可视化图表变得更美观，突出重点和凸显艺术性。\n关于绘图样式，常见的有3种方法，分别是修改预定义样式，自定义样式和rcparams。\n关于颜色使用，本章介绍了常见的5种表示单色颜色的基本方法，以及colormap多色显示的方法。","code":""},{"path":"matplotlib.html","id":"matplotlib的绘图样式style","chapter":"第7章 matplotlib","heading":"7.19 matplotlib的绘图样式（style）","text":"在matplotlib中，要想设置绘制样式，最简单的方法是在绘制元素时单独设置样式。\n但是有时候，当用户在做专题报告时，往往会希望保持整体风格的统一而不用对每张图一张张修改，因此matplotlib库还提供了四种批量修改全局样式的方式","code":""},{"path":"matplotlib.html","id":"matplotlib预先定义样式","chapter":"第7章 matplotlib","heading":"7.19.1 matplotlib预先定义样式","text":"matplotlib贴心地提供了许多内置的样式供用户使用，使用方法很简单，只需在python脚本的最开始输入想使用style的名称即可调用，尝试调用不同内置样式，比较区别那么matplotlib究竟内置了那些样式供使用呢？总共以下26种丰富的样式可供选择。","code":"plt.style.use('default')\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()plt.style.use('ggplot')\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()print(plt.style.available)['Solarize_Light2', '_classic_test_patch', '_mpl-gallery', '_mpl-gallery-nogrid', 'bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-v0_8', 'seaborn-v0_8-bright', 'seaborn-v0_8-colorblind', 'seaborn-v0_8-dark', 'seaborn-v0_8-dark-palette', 'seaborn-v0_8-darkgrid', 'seaborn-v0_8-deep', 'seaborn-v0_8-muted', 'seaborn-v0_8-notebook', 'seaborn-v0_8-paper', 'seaborn-v0_8-pastel', 'seaborn-v0_8-poster', 'seaborn-v0_8-talk', 'seaborn-v0_8-ticks', 'seaborn-v0_8-white', 'seaborn-v0_8-whitegrid', 'tableau-colorblind10']"},{"path":"matplotlib.html","id":"用户自定义stylesheet","chapter":"第7章 matplotlib","heading":"7.19.2 用户自定义stylesheet","text":"在任意路径下创建一个后缀名为mplstyle的样式清单，编辑文件添加以下样式内容axes.titlesize : 24\naxes.labelsize : 20\nlines.linewidth : 3\nlines.markersize : 10\nxtick.labelsize : 16\nytick.labelsize : 16引用自定义stylesheet后观察图表变化。值得特别注意的是，matplotlib支持混合样式的引用，只需在引用时输入一个样式列表，若是几个样式中涉及到同一个参数，右边的样式表会覆盖左边的值。","code":"plt.style.use('static/docs/presentation.mplstyle')\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()plt.style.use(['dark_background', 'file/presentation.mplstyle'])\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()"},{"path":"matplotlib.html","id":"设置rcparams","chapter":"第7章 matplotlib","heading":"7.19.3 设置rcparams","text":"我们还可以通过修改默认rc设置的方式改变样式，所有rc设置都保存在一个叫做 matplotlib.rcParams的变量中。\n修改过后再绘图，可以看到绘图样式发生了变化。另外matplotlib也还提供了一种更便捷的修改样式方式，可以一次性修改多个样式。","code":"plt.style.use('default') # 恢复到默认样式\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()mpl.rcParams['lines.linewidth'] = 2\nmpl.rcParams['lines.linestyle'] = '--'\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()mpl.rc('lines', linewidth=4, linestyle='-.')\nplt.plot([1,2,3,4],[2,3,4,5])\nplt.show()"},{"path":"matplotlib.html","id":"matplotlib的色彩设置color","chapter":"第7章 matplotlib","heading":"7.20 matplotlib的色彩设置（color）","text":"在可视化中，如何选择合适的颜色和搭配组合也是需要仔细考虑的，色彩选择要能够反映出可视化图像的主旨。\n从可视化编码的角度对颜色进行分析，可以将颜色分为色相、亮度和饱和度三个视觉通道。通常来说：色相： 没有明显的顺序性、一般不用来表达数据量的高低，而是用来表达数据列的类别。明度和饱和度： 在视觉上很容易区分出优先级的高低、被用作表达顺序或者表达数据量视觉通道。\n具体关于色彩理论部分的知识，不属于本教程的重点，请参阅有关拓展材料学习。学会这6个可视化配色基本技巧，还原数据本身的意义在matplotlib中，设置颜色有以下几种方式：","code":""},{"path":"matplotlib.html","id":"rgb或rgba","chapter":"第7章 matplotlib","heading":"7.20.1 RGB或RGBA","text":"","code":"plt.style.use('default')# 颜色用[0,1]之间的浮点数表示，四个分量按顺序分别为(red, green, blue, alpha)，其中alpha透明度可省略\nplt.plot([1,2,3],[4,5,6],color=(0.1, 0.2, 0.5))\nplt.plot([4,5,6],[1,2,3],color=(0.1, 0.2, 0.5, 0.5))\nplt.show()"},{"path":"matplotlib.html","id":"hex-rgb-或-rgba","chapter":"第7章 matplotlib","heading":"7.20.2 HEX RGB 或 RGBA","text":"RGB颜色和HEX颜色之间是可以一一对应的，以下网址提供了两种色彩表示方法的转换工具。https://www.colorhexa.com/","code":"# 用十六进制颜色码表示，同样最后两位表示透明度，可省略\nplt.plot([1,2,3],[4,5,6],color='#0f0f0f')\nplt.plot([4,5,6],[1,2,3],color='#0f0f0f80')\nplt.show()"},{"path":"matplotlib.html","id":"灰度色阶","chapter":"第7章 matplotlib","heading":"7.20.3 灰度色阶","text":"","code":"# 当只有一个位于[0,1]的值时，表示灰度色阶\nplt.plot([1,2,3],[4,5,6],color='0.5')\nplt.show()"},{"path":"matplotlib.html","id":"单字符基本颜色","chapter":"第7章 matplotlib","heading":"7.20.4 单字符基本颜色","text":"","code":"# matplotlib有八个基本颜色，可以用单字符串来表示，分别是'b', 'g', 'r', 'c', 'm', 'y', 'k', 'w'，对应的是blue, green, red, cyan, magenta, yellow, black, and white的英文缩写\nplt.plot([1,2,3],[4,5,6],color='m')\nplt.show()"},{"path":"matplotlib.html","id":"颜色名称","chapter":"第7章 matplotlib","heading":"7.20.5 颜色名称","text":"","code":"# matplotlib提供了颜色对照表，可供查询颜色对应的名称\nplt.plot([1,2,3],[4,5,6],color='tan')\nplt.show()"},{"path":"matplotlib.html","id":"使用colormap设置一组颜色","chapter":"第7章 matplotlib","heading":"7.20.6 使用colormap设置一组颜色","text":"有些图表支持使用colormap的方式配置一组颜色，从而在可视化中通过色彩的变化表达更多信息。在matplotlib中，colormap共有五种类型:顺序（Sequential）。通常使用单一色调，逐渐改变亮度和颜色渐渐增加，用于表示有顺序的信息发散（Diverging）。改变两种不同颜色的亮度和饱和度，这些颜色在中间以不饱和的颜色相遇;当绘制的信息具有关键中间值（例如地形）或数据偏离零时，应使用此值。循环（Cyclic）。改变两种不同颜色的亮度，在中间和开始/结束时以不饱和的颜色相遇。用于在端点处环绕的值，例如相角，风向或一天中的时间。定性（Qualitative）。常是杂色，用来表示没有排序或关系的信息。杂色（Miscellaneous）。一些在特定场景使用的杂色组合，如彩虹，海洋，地形等。在以下官网页面可以查询上述五种colormap的字符串表示和颜色图的对应关系https://matplotlib.org/stable/tutorials/colors/colormaps.html","code":"x = np.random.randn(50)\ny = np.random.randn(50)\nplt.scatter(x,y,c=x,cmap='RdPu')\nplt.show()"},{"path":"matplotlib.html","id":"思考题-4","chapter":"第7章 matplotlib","heading":"7.21 思考题","text":"学习如何自定义colormap，并将其应用到任意一个数据集中，绘制一幅图像，注意colormap的类型要和数据集的特性相匹配，并做简单解释","code":""},{"path":"图表实例.html","id":"图表实例","chapter":"第8章 图表实例","heading":"第8章 图表实例","text":"参考作者pythonic生物人","code":"import pandas as pd\nimport numpy as np\nimport matplotlib as mpl\n#mpl.use(\"agg\")\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patches as mpatches\nfrom matplotlib.legend_handler import HandlerLine2D, HandlerTuple \nfrom numpy.random import randn\nimport seaborn as sns\nfrom matplotlib import ticker\nfrom matplotlib.gridspec import GridSpec\nplt.rcParams['font.sans-serif']=['Simhei']; #SimHei黑体 \nplt.rcParams['axes.unicode_minus']=False; #正常显示图中负号\n#teacher = pd.read_csv(\"data/数据/school/1_teacher.csv\")\nstudent = pd.read_csv(\"data/数据/school/2_student_info.csv\")\n#kaoqin = pd.read_csv(\"data/数据/school/3_kaoqin.csv\")\n#kaoqin_type = pd.read_csv(\"data/数据/school/4_kaoqintype.csv\")\nchengji = pd.read_csv(\"data/数据/school/5_chengji.csv\")\n#exam_type = pd.read_csv(\"data/数据/school/6_exam_type.csv\")\n#consumption = pd.read_csv(\"data/数据/school/7_consumption.csv\")\n#teacher.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\nstudent.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))#kaoqin.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n#kaoqin_type.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\nchengji.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))#exam_type.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))\n#consumption.head().pipe(lambda df:print(df.to_markdown(tablefmt=\"github\")))"},{"path":"图表实例.html","id":"绘制流程","chapter":"第8章 图表实例","heading":"8.1 绘制流程","text":"","code":""},{"path":"图表实例.html","id":"参考","chapter":"第8章 图表实例","heading":"8.2 参考","text":"","code":""},{"path":"图表实例.html","id":"axes参数设置","chapter":"第8章 图表实例","heading":"8.3 axes参数设置","text":"","code":""},{"path":"图表实例.html","id":"tick_labels","chapter":"第8章 图表实例","heading":"8.3.1 tick_labels","text":"","code":"#获取label对象\nax.xaxis.get_ticklabels()\n#获取label对象并且设置label\nfor label in ax.xaxis.get_ticklabels():\n    # 调用x轴刻度标签实例，是一个text实例\n    label.set_color('red') # 颜色\n    label.set_rotation(45) # 旋转角度\n    label.set_fontsize(16) # 字体大小\n#更改label和tick值,tick设置为[]，ticks消失\n# ax.xaxis.set_ticklabels()不被鼓励\nax.set_xticks(ticks,labels,minor=False,)\nax.yaxis.set_ticks(ticks,labels,minor=False)"},{"path":"图表实例.html","id":"ticks","chapter":"第8章 图表实例","heading":"8.3.2 ticks","text":"grid被包括在ticks中","code":"#获取ticks在一条轴上的位置\nax.xaxis.get_ticklocs(minor=False)\n\n#设置一条轴的位置 上下左右或者让ticks和轴消失，label不消失\nax.xaxis.set_ticks_position()#{'top', 'bottom', 'both', 'default', 'none'}\n\n# 获取ticks的线条,并且设置格式\nfor line in ax.xaxis.get_ticklines(minor=False):\n    # 调用y轴刻度线条实例, 是一个Line2D实例\n    line.set_markeredgecolor('green')    # 颜色\n    line.set_markersize(25)    # marker大小\n    line.set_markeredgewidth(2)# marker粗细\n\n#设置ticks的参数\nax.xaxis.set_tick_params(which=\"major\",rotation=45)#left,right,labelleft,labelright,gridon\nax.tick_params(axis=,which=,rotation=)\n\n#设置刻度规模\nax.set_yscale()#设置x轴的规模，也就是量级，比如\"linear\", \"log\", \"symlog\", \"logit\"\nax.set_xscale()\nax.autoscale_view()#自动调整比例\n- `matplotlib.scale.LinearScale`\n- `matplotlib.scale.LogScale`\n- `matplotlib.scale.SymmetricalLogScale`\n- `matplotlib.scale.LogitScale`\n- `matplotlib.scale.FuncScale`\n\ndirection : {'in', 'out', 'inout'}\n    Puts ticks inside the Axes, outside the Axes, or both.\nlength : float\n    Tick length in points.\nwidth : float\n    Tick width in points.\ncolor : color\n    Tick color.\npad : float\n    Distance in points between tick and label.\nlabelsize : float or str\n    Tick label font size in points or as a string (e.g., 'large').\nlabelcolor : color\n    Tick label color.\ncolors : color\n    Tick color and label color.\nzorder : float\n    Tick and label zorder.\nbottom, top, left, right : bool\n    Whether to draw the respective ticks.\nlabelbottom, labeltop, labelleft, labelright : bool\n    Whether to draw the respective tick labels.\nlabelrotation : float\n    Tick label rotation\ngrid_color : color\n    Gridline color.\ngrid_alpha : float\n    Transparency of gridlines: 0 (transparent) to 1 (opaque).\ngrid_linewidth : float\n    Width of gridlines in points.\ngrid_linestyle : str\n    Any valid `.Line2D` line style spec."},{"path":"图表实例.html","id":"ticks-formator","chapter":"第8章 图表实例","heading":"8.3.3 ticks-formator","text":"","code":""},{"path":"图表实例.html","id":"ticks-locator","chapter":"第8章 图表实例","heading":"8.3.4 ticks-locator","text":"","code":"locator=plt.MaxNLocator(nbins=7)#自动选择合适的位置，并且刻度之间最多不超过7（nbins）个间隔\nlocator=plt.FixedLocator(locs=[0,0.5,1.5,2.5,3.5,4.5,5.5,6])#直接指定刻度所在的位置  \nlocator=plt.AutoLocator()#自动分配刻度值的位置  \nlocator=plt.IndexLocator(offset=0.5, base=1)#面元间距是1，从0.5开始  \nlocator=plt.MultipleLocator(1.5)#将刻度的标签设置为1.5的倍数  \nlocator=plt.LinearLocator(numticks=5)#线性划分5等分，4个刻度  "},{"path":"图表实例.html","id":"pad","chapter":"第8章 图表实例","heading":"8.3.5 pad","text":"控制ticks与轴标签之间的距离","code":"ax.xaxis.labelpad = 5\nax.yaxis.labelpad = 5"},{"path":"图表实例.html","id":"spines","chapter":"第8章 图表实例","heading":"8.3.6 spines","text":"设置四个轴线","code":"ax.spines['left'].set_position('center')#set_position('center')将 x 和 y 轴放置在相应数据范围之间。 在这种情况下， y 轴上的数据范围是 -1 到 +1，所以中心点是 0，而 x 轴上的数据范围是 0 到 6，所以中心点是3。 因此，交点为(3, 0)。\nax.spines['right'].set_visible(False)#设置轴是否可见\nax.spines['top'].set_color('r')\nax.spines['top'].set_linewidth(1.7)\n#关闭所有轴线\nfor spine in ax.spines.values():\n    spine.set_visible(False)\n    "},{"path":"图表实例.html","id":"轴范围","chapter":"第8章 图表实例","heading":"8.3.7 轴范围","text":"","code":"ax.set_[xy]lim()#设置轴范围\nax.xaxis.get_data_interval()# 获取轴刻度范围"},{"path":"图表实例.html","id":"调整多图间距","chapter":"第8章 图表实例","heading":"8.3.8 调整多图间距","text":"也可以在最后加上fig.tight_layout(),会默认起到优化作用","code":""},{"path":"图表实例.html","id":"图例","chapter":"第8章 图表实例","heading":"8.4 图例","text":"","code":""},{"path":"图表实例.html","id":"图例样式设置","chapter":"第8章 图表实例","heading":"8.4.1 图例样式设置","text":"","code":""},{"path":"图表实例.html","id":"主要参数","chapter":"第8章 图表实例","heading":"8.4.1.1 主要参数","text":"ncols : int, default: 1\nnumber columns legend .","code":"handles : sequence of `.Artist`, optional\nA list of Artists (lines, patches) to be added to the legend.\nUse this together with *labels*, if you need full control on what\nis shown in the legend and the automatic mechanism described above\nis not sufficient.\n\nThe length of handles and labels should be the same in this\ncase. If they are not, they are truncated to the smaller length.\n\nlabels : list of str, optional\nA list of labels to show next to the artists.\nUse this together with *handles*, if you need full control on what\nis shown in the legend and the automatic mechanism described above\nis not sufficient.\n\nbbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats\nBox that is used to position the legend in conjunction with *loc*.\nDefaults to `axes.bbox` (if called as a method to `.Axes.legend`) or\n`figure.bbox` (if `.Figure.legend`).  This argument allows arbitrary\nplacement of the legend.\n\nBbox coordinates are interpreted in the coordinate system given by\n*bbox_transform*, with the default transform\nAxes or Figure coordinates, depending on which ``legend`` is called.\n\nIf a 4-tuple or `.BboxBase` is given, then it specifies the bbox\n``(x, y, width, height)`` that the legend is placed in.\nTo put the legend in the best location in the bottom right\nquadrant of the axes (or figure)::\n\n    loc='best', bbox_to_anchor=(0.5, 0., 0.5, 0.5)\n\nA 2-tuple ``(x, y)`` places the corner of the legend specified by *loc* at\nx, y.  For example, to put the legend's upper right-hand corner in the\ncenter of the axes (or figure) the following keywords can be used::\n\n    loc='upper right', bbox_to_anchor=(0.5, 0.5)"},{"path":"图表实例.html","id":"其他参数","chapter":"第8章 图表实例","heading":"8.4.1.2 其他参数","text":"","code":"For backward compatibility, the spelling *ncol* is also supported\nbut it is discouraged. If both are given, *ncols* takes precedence.\n\nloc : str or pair of floats, default: :rc:`legend.loc`\n  The location of the legend.\n\n  The strings\n  ``'upper left', 'upper right', 'lower left', 'lower right'``\n  place the legend at the corresponding corner of the axes/figure.\n\n  The strings\n  ``'upper center', 'lower center', 'center left', 'center right'``\n  place the legend at the center of the corresponding edge of the\n  axes/figure.\n\n  The string ``'center'`` places the legend at the center of the axes/figure.\n\n  The string ``'best'`` places the legend at the location, among the nine\n  locations defined so far, with the minimum overlap with other drawn\n  artists.  This option can be quite slow for plots with large amounts of\n  data; your plotting speed may benefit from providing a specific location.\n\n  The location can also be a 2-tuple giving the coordinates of the lower-left\n  corner of the legend in axes coordinates (in which case *bbox_to_anchor*\n  will be ignored).\n\n  For back-compatibility, ``'center right'`` (but no other location) can also\n  be spelled ``'right'``, and each \"string\" locations can also be given as a\n  numeric value:\n\n      ===============   =============\n      Location String   Location Code\n      ===============   =============\n      'best'            0\n      'upper right'     1\n      'upper left'      2\n      'lower left'      3\n      'lower right'     4\n      'right'           5\n      'center left'     6\n      'center right'    7\n      'lower center'    8\n      'upper center'    9\n      'center'          10\n      ===============   =============\n\nprop : None or `matplotlib.font_manager.FontProperties` or dict\n  The font properties of the legend. If None (default), the current\n  :data:`matplotlib.rcParams` will be used.\n\nfontsize : int or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}\n  The font size of the legend. If the value is numeric the size will be the\n  absolute font size in points. String values are relative to the current\n  default font size. This argument is only used if *prop* is not specified.\n\nlabelcolor : str or list, default: :rc:`legend.labelcolor`\n  The color of the text in the legend. Either a valid color string\n  (for example, 'red'), or a list of color strings. The labelcolor can\n  also be made to match the color of the line or marker using 'linecolor',\n  'markerfacecolor' (or 'mfc'), or 'markeredgecolor' (or 'mec').\n\n  Labelcolor can be set globally using :rc:`legend.labelcolor`. If None,\n  use :rc:`text.color`.\n\nnumpoints : int, default: :rc:`legend.numpoints`\n  The number of marker points in the legend when creating a legend\n  entry for a `.Line2D` (line).\n\nscatterpoints : int, default: :rc:`legend.scatterpoints`\n  The number of marker points in the legend when creating\n  a legend entry for a `.PathCollection` (scatter plot).\n\nscatteryoffsets : iterable of floats, default: ``[0.375, 0.5, 0.3125]``\n  The vertical offset (relative to the font size) for the markers\n  created for a scatter plot legend entry. 0.0 is at the base the\n  legend text, and 1.0 is at the top. To draw all markers at the\n  same height, set to ``[0.5]``.\n\nmarkerscale : float, default: :rc:`legend.markerscale`\n  The relative size of legend markers compared with the originally\n  drawn ones.\n\nmarkerfirst : bool, default: True\n  If *True*, legend marker is placed to the left of the legend label.\n  If *False*, legend marker is placed to the right of the legend label.\n\nreverse : bool, default: False\n  If *True*, the legend labels are displayed in reverse order from the input.\n  If *False*, the legend labels are displayed in the same order as the input.\n\n  .. versionadded:: 3.7\n\nframeon : bool, default: :rc:`legend.frameon`\n  Whether the legend should be drawn on a patch (frame).\n\nfancybox : bool, default: :rc:`legend.fancybox`\n  Whether round edges should be enabled around the `.FancyBboxPatch` which\n  makes up the legend's background.\n\nshadow : bool, default: :rc:`legend.shadow`\n  Whether to draw a shadow behind the legend.\n\nframealpha : float, default: :rc:`legend.framealpha`\n  The alpha transparency of the legend's background.\n  If *shadow* is activated and *framealpha* is ``None``, the default value is\n  ignored.\n\nfacecolor : \"inherit\" or color, default: :rc:`legend.facecolor`\n  The legend's background color.\n  If ``\"inherit\"``, use :rc:`axes.facecolor`.\n\nedgecolor : \"inherit\" or color, default: :rc:`legend.edgecolor`\n  The legend's background patch edge color.\n  If ``\"inherit\"``, use take :rc:`axes.edgecolor`.\n\nmode : {\"expand\", None}\n  If *mode* is set to ``\"expand\"`` the legend will be horizontally\n  expanded to fill the axes area (or *bbox_to_anchor* if defines\n  the legend's size).\n\nbbox_transform : None or `matplotlib.transforms.Transform`\n  The transform for the bounding box (*bbox_to_anchor*). For a value\n  of ``None`` (default) the Axes'\n  :data:`~matplotlib.axes.Axes.transAxes` transform will be used.\n\ntitle : str or None\n  The legend's title. Default is no title (``None``).\n\ntitle_fontproperties : None or `matplotlib.font_manager.FontProperties` or dict\n  The font properties of the legend's title. If None (default), the\n  *title_fontsize* argument will be used if present; if *title_fontsize* is\n  also None, the current :rc:`legend.title_fontsize` will be used.\n\ntitle_fontsize : int or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'}, default: :rc:`legend.title_fontsize`\n  The font size of the legend's title.\n  Note: This cannot be combined with *title_fontproperties*. If you want\n  to set the fontsize alongside other font properties, use the *size*\n  parameter in *title_fontproperties*.\n\nalignment : {'center', 'left', 'right'}, default: 'center'\n  The alignment of the legend title and the box of entries. The entries\n  are aligned as a single block, so that markers always lined up.\n\nborderpad : float, default: :rc:`legend.borderpad`\n  The fractional whitespace inside the legend border, in font-size units.\n\nlabelspacing : float, default: :rc:`legend.labelspacing`\n  The vertical space between the legend entries, in font-size units.\n\nhandlelength : float, default: :rc:`legend.handlelength`\n  The length of the legend handles, in font-size units.\n\nhandleheight : float, default: :rc:`legend.handleheight`\n  The height of the legend handles, in font-size units.\n\nhandletextpad : float, default: :rc:`legend.handletextpad`\n  The pad between the legend handle and text, in font-size units.\n\nborderaxespad : float, default: :rc:`legend.borderaxespad`\n  The pad between the axes and legend border, in font-size units.\n\ncolumnspacing : float, default: :rc:`legend.columnspacing`\n  The spacing between columns, in font-size units.\n\nhandler_map : dict or None\n  The custom dictionary mapping instances or types to a legend\n  handler. This *handler_map* updates the default handler map\n  found at `matplotlib.legend.Legend.get_legend_handler_map`.\n\ndraggable : bool, default: False\n  Whether the legend can be dragged with the mouse."},{"path":"图表实例.html","id":"双轴或者多图","chapter":"第8章 图表实例","heading":"8.4.2 双轴或者多图","text":"","code":"fig1 = plt.figure()\nax1 = fig1.add_subplot(111)\nax2 = ax1.twinx()\nlegend_1 = ax1.bar(list(\"abc\"),[1,2,3],width=0.6,color=\"red\")\nlegend_2 = ax2.bar(list(\"abc\"),[4,5,6],width=0.5)\nax1.legend(handles=[legend_1,legend_2],labels=[\"a\",\"b\"])\nplt.show()plt.close()"},{"path":"图表实例.html","id":"自定义图例","chapter":"第8章 图表实例","heading":"8.4.3 自定义图例","text":"matplotlib.legend_handler import","code":""},{"path":"图表实例.html","id":"创造","chapter":"第8章 图表实例","heading":"8.4.3.1 创造","text":"自定义用于图例显示的图形import matplotlib.patches mpatches","code":"fig, ax = plt.subplots()\nred_patch = mpatches.Patch(color='red', label='The red data')\nblue_line = mlines.Line2D([], [], color='blue', marker='*',\n                          markersize=15, label='Blue stars')\nax.legend(handles=[red_patch,blue_line])\n\nplt.show()plt.close()"},{"path":"图表实例.html","id":"分组","chapter":"第8章 图表实例","heading":"8.4.3.2 分组","text":"将某几个图例分为一组,同代表某一类,默认一个tuple内的叠加显示。","code":"fig, ax = plt.subplots()\np1, = ax.plot([1, 2.5, 3], 'r-d')\np2, = ax.plot([3, 2, 1], 'k-o')\nl = ax.legend([(p1, p2)], ['Two keys'], numpoints=1,\n              handler_map={tuple: HandlerTuple(ndivide=None)})\nplt.show()plt.close()"},{"path":"图表实例.html","id":"分离","chapter":"第8章 图表实例","heading":"8.4.3.3 分离","text":"即在一个axes上显示多个图例,legend可以多次调用","code":"fig, ax = plt.subplots()\nline1, = ax.plot([1, 2, 3], label=\"Line 1\", linestyle='--')\nline2, = ax.plot([3, 2, 1], label=\"Line 2\", linewidth=4)\n\n# Create a legend for the first line.\nfirst_legend = ax.legend(handles=[line1], loc='upper right')\n\n# Add the legend manually to the Axes.\nax.add_artist(first_legend)\n\n# Create another legend for the second line.\nax.legend(handles=[line2], loc='lower right')\n\nplt.show()plt.close()"},{"path":"图表实例.html","id":"叠加","chapter":"第8章 图表实例","heading":"8.4.3.4 叠加","text":"","code":"z = randn(10)\n\nfig, ax = plt.subplots()\nred_dot, = ax.plot(z, \"ro\", markersize=15)\n# Put a white cross over some of the data.\nwhite_cross, = ax.plot(z[:5], \"w+\", markeredgewidth=3, markersize=15)\n\nax.legend([red_dot, (red_dot, white_cross)], [\"Attr A\", \"Attr A+B\"])\n\nplt.show()plt.close()"},{"path":"图表实例.html","id":"位置","chapter":"第8章 图表实例","heading":"8.4.3.5 位置","text":"用bbox_to_anchor参数用loc","code":"fig,ax = plt.subplots(1,1,figsize=(8,8))\nl1=ax.bar(list(\"abc\"),[1,2,3],label=\"a\")\nl2=ax.bar(list(\"abc\"),[4,5,6],label=\"b\")\nz = ax.legend(handles=[l1,l2],bbox_to_anchor=(1,1.1),ncols=2,loc=\"best\",handleheight=4,handlelength=4)\nfor i in z.get_patches():\n    i.set_height(30)\nplt.show()plt.close()ucl = ['upper', 'center', 'lower']\nlcr = ['left', 'center', 'right']\nfig, ax = plt.subplots(figsize=(6, 4), layout='constrained', facecolor='0.7')\n\nax.plot([1, 2], [1, 2], label='TEST')\n# Place a legend to the right of this smaller subplot.\nfor loc in [\n        'outside upper left',\n        'outside upper center',\n        'outside upper right',\n        'outside lower left',\n        'outside lower center',\n        'outside lower right']:\n    t = fig.legend(loc=loc, title=loc)\n\nfig, ax = plt.subplots(figsize=(6, 4), layout='constrained', facecolor='0.7')\nax.plot([1, 2], [1, 2], label='test')\n\nfor loc in [\n        'outside left upper',\n        'outside right upper',\n        'outside left lower',\n        'outside right lower']:\n    t = fig.legend(loc=loc, title=loc)\nplt.show()plt.close()"},{"path":"图表实例.html","id":"颜色","chapter":"第8章 图表实例","heading":"8.4.4 颜色","text":"","code":""},{"path":"图表实例.html","id":"colormap","chapter":"第8章 图表实例","heading":"8.4.4.1 colormap","text":"可以指定colormap参数，则默认颜色会从该颜色表中选取","code":""},{"path":"图表实例.html","id":"colorscmap","chapter":"第8章 图表实例","heading":"8.4.4.2 colors+cmap","text":"colors指定数值序列，cmap指定颜色表建立颜色关系,cmap=mapl.cm.颜色表名","code":""},{"path":"图表实例.html","id":"plt.cm.表名","chapter":"第8章 图表实例","heading":"8.4.4.3 plt.cm.表名","text":"plt.cm.颜色表名(数值序列),可以直接选定n种颜色使用colors","code":""},{"path":"图表实例.html","id":"柱形图条形图","chapter":"第8章 图表实例","heading":"8.5 柱形图/条形图","text":"","code":""},{"path":"图表实例.html","id":"基本柱形图","chapter":"第8章 图表实例","heading":"8.5.1 基本柱形图","text":"","code":""},{"path":"图表实例.html","id":"简单示例","chapter":"第8章 图表实例","heading":"8.5.1.1 简单示例","text":"可以展示一个种类的各个数值，适用与分类数据","code":"# 展示某一次考试某位学生的各科成绩柱形图\nsub_score = chengji[(chengji.mes_StudentID == 13539) & (chengji.exam_number == 282)][[\"mes_sub_name\",\"mes_Score\"]].query(\"mes_Score>0\")\ncon = plt.bar(\"mes_sub_name\",\"mes_Score\",data=sub_score)\nplt.show()plt.close()"},{"path":"图表实例.html","id":"调优","chapter":"第8章 图表实例","heading":"8.5.1.2 调优","text":"","code":"fig = plt.figure(figsize=(4.8,5))\nax = fig.add_subplot(111)\n#返回barcontainer\nbc = plt.bar(\n    \"mes_sub_name\",\n    \"mes_Score\",\n    width=0.6,\n    data=sub_score\n)\n\n# 轴和刻度设置\nfor spine in ax.spines.values():\n    spine.set_visible(False)\nax.xaxis.set_ticks_position(\"none\")\n#ax.yaxis.grid(True)\n\n# 在正上方添加数值标签\nfor bar in ax.patches:\n    t = ax.text(bar.get_x()+1/2*bar.get_width(),bar.get_height(),bar.get_height(),ha=\"center\",va=\"bottom\")\n\n# 设置第一个bar为红色\nbc.patches[0].set_facecolor(\"red\")\n\nplt.show()plt.close()"},{"path":"图表实例.html","id":"排列柱形图","chapter":"第8章 图表实例","heading":"8.5.2 排列柱形图","text":"比较两位同学同一次考试的各科成绩","code":"two_student_score = chengji.query(\"mes_StudentID == [13539,13548] & exam_number == 284\")[[\"mes_StudentID\",\"mes_sub_name\",\"mes_Score\"]]\ntwo_student_score       mes_StudentID mes_sub_name  mes_Score\n25373          13539           语文       53.0\n25374          13548           语文       81.0\n26481          13539           数学       50.0\n26482          13548           数学       63.0fig,ax = plt.subplots(1,1)\nax1 = two_student_score.pivot(index=\"mes_sub_name\",columns=\"mes_StudentID\",values=\"mes_Score\").plot(kind=\"bar\",ax=ax)\nfor bar in ax.patches:\n    t = ax.text(bar.get_x()+1/2*bar.get_width(),bar.get_height(),bar.get_height(),ha=\"center\",va=\"bottom\")\nax.xaxis.set_tick_params(rotation=0)\nt = ax.set_xlabel('学科')\nt = ax.set_ylabel('成绩')\nt = ax.legend(title=\"学生\")\nplt.show()plt.close()fig,ax = plt.subplots(1,1)\nax1 = sns.barplot(data=two_student_score,x=\"mes_sub_name\",y=\"mes_Score\",hue=\"mes_StudentID\",ax=ax)\nfor bar in ax.patches:\n    t = ax.text(bar.get_x()+1/2*bar.get_width(),bar.get_height(),bar.get_height(),ha=\"center\",va=\"bottom\")\nax.xaxis.set_tick_params(rotation=0)\nt = ax.set_xlabel('学科')\nt = ax.set_ylabel('成绩')\nt = ax.legend(title=\"学生\")\nplt.show()plt.close()"},{"path":"图表实例.html","id":"堆叠条形图","chapter":"第8章 图表实例","heading":"8.5.3 堆叠条形图","text":"","code":"#我们要计算各个学生的总成绩\n#横轴将变为学生，列将变成堆叠形式\nfig,ax=plt.subplots(1,1)\nstudent_sum_grade=two_student_score.pivot(index=\"mes_StudentID\",columns=\"mes_sub_name\",values=\"mes_Score\")\nax1 = student_sum_grade.plot(kind=\"bar\",ax=ax,stacked=True)\n#改成绘制在顶端,这里需要计算cumsum，并且按照列展开，所以需要先转置\ncums = student_sum_grade.apply(np.cumsum,axis=1).values.T.flatten()\nfor bar,height in zip(ax.patches,cums):\n    t = ax.text(bar.get_x()+1/2*bar.get_width(),height,bar.get_height(),ha=\"center\",va=\"top\")\nax.xaxis.set_tick_params(rotation=0)\nplt.show()plt.close()"},{"path":"图表实例.html","id":"双向条形图","chapter":"第8章 图表实例","heading":"8.5.4 双向条形图","text":"主要是bottom和left参数","code":"#设计90分为及格线,绘制出一个班级的学生的数学成绩\nclass_student_math = pd.merge(student.query(\"cla_id == 901\"),chengji.query(\"exam_number == 284 & mes_sub_name == '数学'\" ),\n         how=\"inner\",left_on=\"bf_StudentID\",right_on=\"mes_StudentID\")[[\"bf_Name\",\"mes_Score\"]].set_index(\"bf_Name\")\nfig,ax = plt.subplots(figsize=(5,10))\n#注意这里取序列求平均值\ngrade_mean = round(class_student_math.mes_Score.mean(),0)\nmean_student_math = class_student_math - grade_mean\nax1 = mean_student_math.plot(kind=\"barh\",width=0.5,ax=ax,left=grade_mean)\nax.xaxis.set_ticks_position(\"top\")\nax.get_legend().set_visible(False)\nt = ax.set_ylabel(\"\")\nt= ax.set_xlim(50,105)\nfor bar in ax.patches:\n    tc = ax.text(bar.get_width()+grade_mean,bar.get_y()+bar.get_height()/2,\n                 bar.get_width()+grade_mean,ha=\"right\" if bar.get_width() < 0 else \"left\",va=\"center\")\nplt.show()plt.close()"},{"path":"图表实例.html","id":"组合条形图","chapter":"第8章 图表实例","heading":"8.5.5 组合条形图","text":"","code":"# 绘制多图\nclass_student_three = pd.merge(student.query(\"cla_id == 901\"),chengji.query(\"exam_number == 284 & mes_sub_name == ['数学','英语','语文']\"),\n         how=\"inner\",left_on=\"bf_StudentID\",right_on=\"mes_StudentID\").pivot(index=\"mes_sub_name\",columns=\"bf_StudentID\",values=\"mes_Score\")\n#返回axes的集合\naxs = class_student_three.plot(\n    kind = \"bar\",\n    subplots = True,\n    layout = (5,-1),\n    figsize = (8,6),\n    width = 0.9,\n    xlabel = \"\",\n    ylabel = \"\",\n    legend = False\n)\nplt.subplots_adjust(wspace=0.5,hspace=0.5)\nmean = class_student_three.apply(np.mean,axis=1).values.flatten()\nfor ax in axs.flatten():\n    ax.set_axis_off()  \n    ax.title.set_fontsize(10)\n    #ax.get_legend().set_visible(False)\n    #低于平均分为灰色，其他为黑色\n    for m,patch in zip(mean,ax.patches):\n        patch.set_facecolor(\"grey\" if patch.get_height()<m else \"black\")\ngrey_patch = mpatches.Patch(color=\"grey\")\nblack_patch = mpatches.Patch(color=\"black\")\nplt.legend(handles=[grey_patch,black_patch],labels=[\"低于均分\",\"不低于均分\"],ncols=2,bbox_to_anchor=(1,8))\nplt.show()plt.close()# 要想在某个可调用的fig下绘制,可以指定ax=某个多图的ax集合，但是layout参数就不能使用了\nfig,axc= plt.subplots(5,9,figsize=(8,6))\naxs = class_student_three.plot(\n    kind = \"bar\",\n    subplots = True,\n    #layout = (5,-1),\n    #figsize = (8,6),\n    width = 0.9,\n    xlabel = \"\",\n    ylabel = \"\",\n    legend = False,\n    ax = axc\n)\nfig.subplots_adjust(wspace=0.5,hspace=0.5)\nmean = class_student_three.apply(np.mean,axis=1).values.flatten()\nfor ax in axs.flatten():\n    ax.set_axis_off()  \n    ax.title.set_fontsize(10)\n    #低于平均分为灰色，其他为黑色\n    for m,patch in zip(mean,ax.patches):\n        patch.set_facecolor(\"grey\" if patch.get_height()<m else \"black\")\ngrey_patch = mpatches.Patch(color=\"grey\")\nblack_patch = mpatches.Patch(color=\"black\")\nfig.legend(handles=[grey_patch,black_patch],labels=[\"低于均分\",\"不低于均分\"],ncols=2,bbox_to_anchor=(0.9,1))\nt = fig.suptitle(\"某班学生语数英成绩对比\",x=0.15,y=0.95,va=\"bottom\",ha=\"left\")\nplt.show()plt.close()"},{"path":"图表实例.html","id":"折线图","chapter":"第8章 图表实例","heading":"8.6 折线图","text":"line, = plt.plot() 是为了将返回的列表类型给解包，变成单个对象","code":""},{"path":"图表实例.html","id":"基础折线图","chapter":"第8章 图表实例","heading":"8.6.1 基础折线图","text":"","code":"# 一个学生各科历次考试成绩变化,只取期中，期末和五校的三门主课成绩\na_student_grade = chengji.query(\"mes_StudentID  == 14933 & exam_type == [2,3,6]\").query(\"mes_sub_name == ['语文','数学','英语']\").sort_values([\"exam_number\"]).dropna(subset=[\"mes_Score\"])[[\"exam_number\",\"exam_sdate\",\"mes_sub_name\",\"mes_Score\"]]\na_student_grade[\"exam_sdate\"] = pd.to_datetime(a_student_grade.exam_sdate).dt.date #如果不加后面的提取日期是时间类型，加了则不是\nexam_subject_score = a_student_grade.pivot(index=\"exam_number\",columns=\"mes_sub_name\",values=\"mes_Score\").applymap(int)<string>:1: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.exam_subject_scoremes_sub_name  数学   英语  语文\nexam_number              \n284           53   77  65\n288           78  124  81\n292           63   75  68\n298           67  106  91\n304           78   79  57et_subject_score = a_student_grade.pivot(index=\"exam_sdate\",columns=\"mes_sub_name\",values=\"mes_Score\").applymap(int)<string>:2: FutureWarning: DataFrame.applymap has been deprecated. Use DataFrame.map instead.et_subject_scoremes_sub_name  数学   英语  语文\nexam_sdate               \n2017-11-15    53   77  65\n2018-01-26    78  124  81\n2018-04-23    63   75  68\n2018-06-24    67  106  91\n2018-11-05    78   79  57fig,ax = plt.subplots(1,1)\nls = exam_subject_score.plot(\n# fmt: 该关键字不能写，直接写值。\"[marker][line][color]\" \n# 如果没有marker，有line，则是一条线，无点，\n# 比如直接写\".-r\"，不要写fmt=\".-r\"\n    mec = \"r\",    # markeredgecolor\n    mew = 2,      # markeredgewidth\n    mfc = 'black',#  markerfacecolor='red',#marker填充色\n    ms = 5,       #  markersize='15',#marker大小\n    lw = 2,\n    ls = '--',\n    marker='^',#marker形状\n    fillstyle='top',#marker填充形式，可选{'full', 'left', 'right', 'bottom', 'top', 'none'}\n    markerfacecoloralt='blue',#marker未被填充部分颜色\n    markevery=2,#每隔一个画一个marker\n    # label='',#图例\n    alpha=0.8,#线和marker的透明度   \n    ax = ax\n)\n#如果类别以数值表示的话，它的tick的interval会发生根据数值差发生变化\nax.xaxis.set_major_locator(ticker.FixedLocator(exam_subject_score.index))\n# 添加标签\nfor i,ds in exam_subject_score.iterrows():\n    for d in ds:\n        t = ax.text(i,d,d,va=\"bottom\",ha=\"center\")\nplt.show()plt.close()ax = et_subject_score.plot(subplots=[(\"数学\",\"语文\"),(\"英语\",)],layout=(1,2),figsize=(10,5))\nt = ax[0,0].set_xlabel(\"exam_time\")\nplt.show()plt.close()"},{"path":"图表实例.html","id":"直方图","chapter":"第8章 图表实例","heading":"8.7 直方图","text":"n, bins, patches=plt.hist()plt.xticks(bins)#x轴刻度设置为箱子边界","code":""},{"path":"图表实例.html","id":"基础直方图","chapter":"第8章 图表实例","heading":"8.7.1 基础直方图","text":"","code":"class_student_math.plot(kind=\"hist\",\n##箱子数(bins)设置，以下三种不能同时并存\n#bins=20,#default: 10\n#bins=[4,6,8],#分两个箱子，边界分别为[4,6),[6,8]\n#bins='auto',# 可选'auto', 'fd', 'doane', 'scott', 'stone', 'rice', 'sturges', or 'sqrt'.\n#选择最合适的bin宽，绘制一个最能反映数据频率分布的直方图 \n\n#range=(5,7),#最左边和最右边箱子边界，不指定时，为(x.min(), x.max())\n#density=True, #默认为False，y轴显示频数；为True y轴显示频率，频率统计结果=该区间频数/(x中总样本数*该区间宽度)\n#weights=np.random.rand(len(x)),#对x中每一个样本设置权重，这里随机设置了权重\ncumulative=False,#默认False，是否累加频数或者频率，及后面一个柱子是前面所有柱子的累加\nbottom=0,#设置箱子y轴方向基线，默认为0，箱子高度=bottom to bottom + hist(x, bins)\nhisttype='bar',#直方图的类型默认为bar{'bar', 'barstacked', 'step', 'stepfilled'}\nalign='mid',#箱子边界值的对齐方式，默认为mid{'left', 'mid', 'right'}\norientation='vertical',#箱子水平还是垂直显示，默认垂直显示('vertical')，可选'horizontal'\nrwidth=1.0,#每个箱子宽度，默认为1，此时显示50%\nlog=False,#y轴数据是否取对数，默认不取对数为False\nlabel='sepal length(cm)',#图例\n#normed=0,#功能和density一样，二者不能同时使用\nfacecolor='blue',#箱子颜色 \nedgecolor=\"black\",#箱子边框颜色\nstacked=False,#多组数据是否堆叠\nalpha=0.5#箱子透明度\n)\nplt.show()plt.close()"},{"path":"图表实例.html","id":"组合直方图","chapter":"第8章 图表实例","heading":"8.7.2 组合直方图","text":"","code":" # 某班级三次考试中数学成绩的变化\nclass_three_math = pd.merge(student.query(\"cla_id == 901\"),\n         chengji.query(\"exam_number == [284,289,292] & mes_sub_name == '数学'\" ),\n         how=\"inner\",\n         left_on=\"bf_StudentID\",\n         right_on=\"mes_StudentID\").pivot(index=\"bf_StudentID\",columns=\"exam_number\",values=\"mes_Score\")\n# 绘制图片，axs是axes的array\naxs = class_three_math.plot(\n    kind = \"hist\",\n    bins = 10,\n    subplots = True,\n    layout = (1,3),\n    orientation = \"horizontal\",\n    color = \"grey\",\n    ylim = (50,100),\n    figsize = (10,6),\n    title = \"某班级连续三次考试数学成绩对比\",\n    sharey = True\n)\n\n#参数设置\nfor ax in axs.flatten():\n    ax.get_legend().set_visible(False)\n    for spine in ax.spines.values():\n        spine.set_visible(False)\n    ax.xaxis.set_ticks_position(\"none\")\n    ax.xaxis.set_major_locator(ticker.FixedLocator([10,20]))\n    t = ax.set_xlabel(\"\")\n    for tl in ax.yaxis.get_ticklines():\n        tl.set_visible(False)\n\nxl = axs[0,0].set_xlim(-5,30)\n\n#计算均值并标记\nmean  = round(class_three_math.apply(np.mean),1).values.flatten()\nfor i,m in enumerate(mean):\n    l = axs[0,i].plot([20],[m],'.k')\n    t = axs[0,i].text(20+2,m,m,va=\"center\",ha=\"left\")\n\nplt.show()plt.close()"},{"path":"图表实例.html","id":"箱线图-1","chapter":"第8章 图表实例","heading":"8.8 箱线图","text":"plt.boxplot()返回dict","code":"dict\n  A dictionary mapping each component of the boxplot to a list\n  of the `.Line2D` instances created. That dictionary has the\n  following keys (assuming vertical boxplots):\n\n  - ``boxes``: the main body of the boxplot showing the\n    quartiles and the median's confidence intervals if\n    enabled.\n\n  - ``medians``: horizontal lines at the median of each box.\n\n  - ``whiskers``: the vertical lines extending to the most\n    extreme, non-outlier data points.\n\n  - ``caps``: the horizontal lines at the ends of the\n    whiskers.\n\n  - ``fliers``: points representing data that extend beyond\n    the whiskers (fliers).\n\n  - ``means``: points or lines representing the means."},{"path":"图表实例.html","id":"获取返回数据","chapter":"第8章 图表实例","heading":"8.8.1 获取返回数据","text":"","code":"class_student_grade = pd.merge(student.query(\"cla_id == 901\"),chengji.query(\"exam_number == 284\"),\n         how=\"inner\",left_on=\"bf_StudentID\",right_on=\"mes_StudentID\")[[\"bf_StudentID\",\"mes_sub_name\",\"mes_Score\"]].pivot(index=\"bf_StudentID\",columns=\"mes_sub_name\",values=\"mes_Score\")\n\npoint = plt.boxplot(\n    x = \"数学\",\n    data = class_student_grade[[\"数学\"]]\n)\npoint[\"fliers\"][0].get_ydata()array([ 56.,  63.,  61.,  55., 100.])"},{"path":"图表实例.html","id":"组合箱线图","chapter":"第8章 图表实例","heading":"8.8.2 组合箱线图","text":"","code":"# 一个班某一次考试各科成绩的箱线图\npoint = class_student_grade.boxplot(\n  whis = 1.5, # 指定1.5倍的四分位差\n  widths = 0.7, # 指定箱线图的宽度为0.8\n  patch_artist = True, # 指定需要填充箱体颜色\n  showmeans = True, # 指定需要显示均值\n  boxprops = {'facecolor':'steelblue'}, # 指定箱体的填充色为铁蓝色\n  flierprops = {'markerfacecolor':'red', 'markeredgecolor':'red', 'markersize':4},#  指定异常点的填充色、边框色和大小\n  meanprops = {'marker':'D','markerfacecolor':'black', 'markersize':4},# 指定均值点的标记符号（菱形）、填充色和大小\n  medianprops = {'linestyle':'--','color':'orange'},#指定中位数的标记符号（虚线）和颜色\n  #labels = [''] # 去除箱线图的x轴刻度值\n  vert = True,#默认绘制垂直箱线图\n  return_type = \"dict\",#确定返回类型，“dict，axes，both（ax,lines）”\n)\nplt.show()\nplt.close()\n#获取异常点值\nfor p in point[\"fliers\"]:\n    print(p.get_ydata())"},{"path":"图表实例.html","id":"饼图","chapter":"第8章 图表实例","heading":"8.9 饼图","text":"","code":""},{"path":"图表实例.html","id":"基础饼图","chapter":"第8章 图表实例","heading":"8.9.1 基础饼图","text":"返回每个扇，label和autotext（百分比)","code":"# 一个学生各科成绩的占比\npatches,texts,autotexts = plt.pie(\n    data=sub_score,\n    x = \"mes_Score\",#数值\n    labels = \"mes_sub_name\",#标签名\n    colors=[\"#d5695d\",\"#5d8ca8\",\"#65a479\",\"#72384f\"],#修改饼图颜色，传入颜色list\n    explode=(0.2, 0,0, 0),#某部分突出显示，值越大，距离中心越远，该法可解决饼图字体重叠的问题\n    autopct='%.1f%%',#格式化输出百分比\n    pctdistance=0.8,#百分比标签与圆心的距离\n    labeldistance=1.1,#labels与圈边界的距离，默认为1.1\n    startangle=45,#饼图的开始角度，默认为0度,为数学意义上的象限的0度，根据旋转方向旋转对应角度\n    radius=1.3,#饼图半径，默认为1\n    counterclock=False,#关闭逆时针显示\n    #设置框属性\n    wedgeprops={'edgecolor':'r',#内外框颜色\n                'linestyle':'--',#线型\n                'alpha':0.5,#透明度\n                #更多参考matplotlib.patches.Wedge                   \n               },\n            #饼图中文本的属性\n    textprops={'color':'r',#文本颜色\n               'fontsize':16,#文本大小\n               'fontfamily':'Microsoft JhengHei',#设置微软雅黑字体\n               #更多参考matplotlib.pyplot.text                 \n              }\n)\npatches[0].set_facecolor('red')#设置第一个弧形块的颜色\ntexts[0].set_size(40)#设置第一个标签的大小\nautotexts[0].set_color('white')#修改第一个百分比的颜色\nplt.show()plt.close()"},{"path":"图表实例.html","id":"玫瑰图","chapter":"第8章 图表实例","heading":"8.9.2 玫瑰图","text":"结合极坐标","code":"# 不同长度rad的极坐标柱形图\n#设置theta，rad，width，colors\nfig,ax = plt.subplots(1,1,layout='constrained',subplot_kw={'projection':\"polar\"})\ntheta = np.pi*np.linspace(0,2,len(class_student_math)+1)[:-1]\nline,label = ax.set_thetagrids(theta*180/np.pi,class_student_math.index,ha=\"center\",va=\"top\",fontsize=10) \n#ax.set_rlabel_position()\n#ax.grid(False)\nrad = class_student_math.sort_values(\"mes_Score\",ascending=False).mes_Score\nwidth = 2*np.pi/len(class_student_math)\n#颜色利用数值归一化后传入\nax.bar(theta,rad,width=width, bottom=0.0,alpha=0.8,color=plt.cm.viridis((rad-rad.min())/(rad.max()-rad.min())))\n#color=plt.cm.viridis((rad-rad.min())/(rad.max()-rad.min())*256)\n#,edgecolor=\"white\"\nax.set_theta_zero_location('N')         #设置极轴方向\n#t = ax.set_rticks([])\nax.set_axis_off()\nfor t,v,l in zip(theta,rad,rad.index):\n    nt = ax.text(t,v,str(l)+\"\\n\"+str(v),ha=\"center\",va=\"center\",fontsize=8,rotation=t*180/np.pi,color=\"black\",fontfamily=\"KaiTi\")\nplt.show()plt.close()"},{"path":"图表实例.html","id":"散点图","chapter":"第8章 图表实例","heading":"8.10 散点图","text":"","code":""},{"path":"图表实例.html","id":"基础散点图","chapter":"第8章 图表实例","heading":"8.10.1 基础散点图","text":"","code":"scatter_data = pd.DataFrame(\n    {\n        \"x\":np.random.randint(1,10,36),\n        \"y\":np.random.randint(1,10,36),\n        \"c\":np.random.permutation(['a','b','c','d']*9),\n        \"s\":np.random.permutation([5,10,15,20,25,30]*6),\n        \"m\":np.random.permutation([\"one\",\"two\"]*18)\n    }\n)\nplt.scatter(\n    data = scatter_data,\n    x = \"x\",\n    y = \"y\",\n    s = \"s\",\n    c = scatter_data.c.map({\"a\":\"red\",\"b\":\"blue\",\"c\":\"yellow\",\"d\":\"green\"}),\n    #marker = ,marker形状,如果想要绘制不同的形状，则需要利用循环\n    #marker=matplotlib.markers.MarkerStyle(marker = markers[i],fillstyle='full'),#设置marker的填充\n    alpha=0.8,#marker透明度，范围为0-1\n    facecolors='r',#marker的填充颜色，当上面c参数设置了颜色，优先c\n    edgecolors='none',#marker的边缘线色\n    linewidths=1,#marker边缘线宽度，edgecolors不设置时，改参数不起作用\n    #label = 后面图例的名称取自label\n)\nplt.show()plt.close()"},{"path":"图表实例.html","id":"不同形状的散点","chapter":"第8章 图表实例","heading":"8.10.2 不同形状的散点","text":"","code":"fig,ax = plt.subplots(1,1)\nmark = {\"one\":\".\",\"two\":\"*\"}\n#不要colorbar\n#markersize的比较合适大小在100左右\n#利用cmap将color中的数值映射到颜色\nfor m,md in scatter_data.groupby(\"m\"):\n    p = md.plot(\n    kind=\"scatter\",\n    marker = mark[m],\n    x = \"x\",\n    y = \"y\",\n    s = 10*md.s,\n    c = md.s,\n    cmap = mpl.cm.viridis,\n    #marker = ,marker形状,如果想要绘制不同的形状，则需要利用循环\n    #marker=matplotlib.markers.MarkerStyle(marker = markers[i],fillstyle='full'),#设置marker的填充\n    alpha=0.8,#marker透明度，范围为0-1\n    facecolors='r',#marker的填充颜色，当上面c参数设置了颜色，优先c\n    edgecolors='none',#marker的边缘线色\n    linewidths=1,#marker边缘线宽度，edgecolors不设置时，改参数不起作用\n    #label = 后面图例的名称取自label\n    colorbar = False,\n    ax=ax,\n    )\nplt.show()plt.close()"},{"path":"图表实例.html","id":"极坐标","chapter":"第8章 图表实例","heading":"8.11 极坐标","text":"","code":"#创建极坐标\nfig = plt.figure()\nax = fig.add_subplot(polar=True)\n#创建极坐标\nfig,ax = plt.subplots(subplot_kw={'projection':\"polar\"})"},{"path":"图表实例.html","id":"基础极坐标","chapter":"第8章 图表实例","heading":"8.11.1 基础极坐标","text":"","code":"fig = plt.figure()\nax = fig.add_subplot(polar=True)\nfig.clear()\n#创建极坐标图\nfig,ax = plt.subplots(subplot_kw={'projection':\"polar\"})\n#绘制点图，即雷达图，只需确定几等分，以及label即可\n#获取两位同学的某次考试各科成绩\ntwo_student = chengji.query(\"mes_StudentID == [13543,13544] & exam_number == 288 & mes_Score >0\").pivot(index=\"mes_sub_name\",columns=\"mes_StudentID\",values=\"mes_Score\")\n#这里要多生成一个角度，因为0,2pi是一样的位置\ntheta = np.linspace(0,2*np.pi,len(two_student)+1)[:-1]\nname = two_student.index\ntn = ax.set_thetagrids(theta*180/np.pi,name)         #替换轴线和标签\ns1, = ax.plot(theta,two_student.iloc[:,0],'.m')\ns2, = ax.plot(theta,two_student.iloc[:,1],'.g')\nax.set_rmax(160)\nt = ax.set_rticks([20,40,60,80,100,120,140,160])  # Less radial ticks\nax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line\nax.grid(True)\np1 = ax.fill(theta,two_student.iloc[:,0],'m',alpha = 0.75)           #填充\np2 = ax.fill(theta,two_student.iloc[:,1],color='grey',alpha = 0.75)           #填充\nax.set_theta_zero_location('E')         #设置极轴方向\nt = ax.set_title(\"A plot\", va='bottom')\nl = ax.legend(handles=[s1,s2],labels=list(two_student.columns),bbox_to_anchor=(1.3,1))\nplt.show()plt.close()"},{"path":"图表实例.html","id":"帕累托图","chapter":"第8章 图表实例","heading":"8.12 帕累托图","text":"主要用来绘制顺序数据","code":"# 即要绘制双轴\npdata = pd.DataFrame({\"one\":[1,2,3]},index=[\"a\",\"b\",\"c\"]) \nfig,ax = plt.subplots(1,1,figsize=(8,8))\nb = pdata.plot(kind=\"bar\",ax=ax,legend=False)\nax.set_ylim(0,6)(0.0, 6.0)ax.yaxis.set_major_locator(ticker.LinearLocator(3))\nax2 = ax.twinx()\npdatacum = pdata.apply(lambda x:x.cumsum()/sum(x))\nl = pdatacum.plot(ax=ax2,legend=False,marker=\".\")\nax2.set_ylim(0,1)(0.0, 1.0)ax2.yaxis.set_major_locator(ticker.LinearLocator(6))\nax2.yaxis.set_major_formatter(ticker.PercentFormatter(xmax=1))\nplt.show()plt.close()"},{"path":"图表实例.html","id":"多图","chapter":"第8章 图表实例","heading":"8.13 多图","text":"主要介绍进行任意axes组合的方法matplotlib.gridspec.GridSpec(nrows, ncols, figure=None, left=None, bottom=None, right=None, top=None, wspace=None, hspace=None, width_ratios=None, height_ratios=None)","code":"# 生成任意排列的图形\nfig = plt.figure(dpi=100,\n                 constrained_layout=True,#类似于tight_layout，使得各子图之间的距离自动调整【类似excel中行宽根据内容自适应】\n                )\ngs = GridSpec(3, 3, figure=fig)#GridSpec将fiure分为3行3列，每行三个axes，gs为一个matplotlib.gridspec.GridSpec对象，可灵活的切片figure\nax1 = fig.add_subplot(gs[0, 0:1])\nplt.plot([1,2,3])\nax2 = fig.add_subplot(gs[0, 1:3])#gs[0, 0:3]中0选取figure的第一行，0:3选取figure第二列和第三列\n\n#ax3 = fig.add_subplot(gs[1, 0:2])\nplt.subplot(gs[1, 0:2])#同样可以使用基于pyplot api的方式\nplt.scatter([1,2,3],[4,5,6],marker='*')\n\nax4 = fig.add_subplot(gs[1:3, 2:3])\nplt.bar([1,2,3],[4,5,6])\n\nax5 = fig.add_subplot(gs[2, 0:1])\nax6 = fig.add_subplot(gs[2, 1:2])\n\nfig.suptitle(\"GridSpec\",color='r')\nplt.show()plt.close()"},{"path":"introduction-2.html","id":"introduction-2","chapter":"introduction","heading":"introduction","text":"主要介绍了mysql和hive数据库的软件很多，但是大部分sql语言是同样的，同时也有一些自己特殊的，sql语言总结","code":""},{"path":"mysql速查表.html","id":"mysql速查表","chapter":"第9章 mysql速查表","heading":"第9章 mysql速查表","text":"","code":""},{"path":"mysql速查表.html","id":"数据类型","chapter":"第9章 mysql速查表","heading":"9.1 数据类型","text":"","code":""},{"path":"mysql速查表.html","id":"数值型","chapter":"第9章 mysql速查表","heading":"9.1.1 数值型","text":"","code":""},{"path":"mysql速查表.html","id":"整数型","chapter":"第9章 mysql速查表","heading":"9.1.1.1 整数型","text":"","code":""},{"path":"mysql速查表.html","id":"浮点数","chapter":"第9章 mysql速查表","heading":"9.1.1.2 浮点数","text":"","code":""},{"path":"mysql速查表.html","id":"时间与日期","chapter":"第9章 mysql速查表","heading":"9.1.2 时间与日期","text":"","code":""},{"path":"mysql速查表.html","id":"字符串","chapter":"第9章 mysql速查表","heading":"9.1.3 字符串","text":"","code":""},{"path":"mysql速查表.html","id":"数学运算符","chapter":"第9章 mysql速查表","heading":"9.2 数学运算符","text":"","code":""},{"path":"mysql速查表.html","id":"比较运算符","chapter":"第9章 mysql速查表","heading":"9.3 比较运算符","text":"","code":""},{"path":"mysql速查表.html","id":"逻辑运算符","chapter":"第9章 mysql速查表","heading":"9.4 逻辑运算符","text":"","code":""},{"path":"mysql速查表.html","id":"函数-1","chapter":"第9章 mysql速查表","heading":"9.5 函数","text":"","code":""},{"path":"mysql速查表.html","id":"数学函数","chapter":"第9章 mysql速查表","heading":"9.5.1 数学函数","text":"","code":""},{"path":"mysql速查表.html","id":"字符串函数","chapter":"第9章 mysql速查表","heading":"9.5.2 字符串函数","text":"","code":""},{"path":"mysql速查表.html","id":"聚合函数","chapter":"第9章 mysql速查表","heading":"9.5.3 聚合函数","text":"","code":""},{"path":"mysql速查表.html","id":"时间函数","chapter":"第9章 mysql速查表","heading":"9.5.4 时间函数","text":"","code":""},{"path":"mysql速查表.html","id":"条件函数","chapter":"第9章 mysql速查表","heading":"9.5.5 条件函数","text":"","code":""},{"path":"mysql速查表.html","id":"正则表达式","chapter":"第9章 mysql速查表","heading":"9.6 正则表达式","text":"expr REGXEP 正则表达式","code":""},{"path":"mysql速查表.html","id":"窗口函数-1","chapter":"第9章 mysql速查表","heading":"9.7 窗口函数","text":"原文窗口函数是为了干什么，它并不会将多行查询结果合并为一行，而是将结果放回多行当中。也就是说，窗口函数是不需要GROUP BY的。它在形式上利用partition by来进行分区，然后操作，但是结果行数并没有发生变化.语法窗口函数partition :分区而非分组，对窗口函数和over中的order ，frame起作用,但是对任何聚合函数没有作用，即使是over中的聚合函数。通过partition ，可以在每个分区内通过窗口函数进行排序和求和等操作。若是想整体操作，那其实不是窗口函数的功能，可以在外部通过order ，group by操作实现.order :排序操作，有分区操作则对每个分区内部进行排序frame结构:在分区内进一步细分，比如确定值范围，确定行范围，某一行之前之后的范围。lag和lead可以认为是时间点，rows 可以认为是时间段。rows 1 preceding 2 followingrows current row 2 followingrows unbounded preceding 2 followingrows 1 following 2 following","code":"window_function_name(window_name/expression)\n\nOVER (\n\n[partition_defintion]: partition by\n\n[order_definition] : order by\n\n[frame_definition] : \n)with open(\"./static/docs/window-function.txt\",\"r\") as f:\n  w = f.read()\nprint(w)"},{"path":"pymysql.html","id":"pymysql","chapter":"第10章 PyMysql","heading":"第10章 PyMysql","text":"PyMysql是纯python写的用来操作python的包操作流程如下,原文","code":""},{"path":"pymysql.html","id":"导入包","chapter":"第10章 PyMysql","heading":"10.1 导入包","text":"","code":"import pymysql"},{"path":"pymysql.html","id":"连接数据库","chapter":"第10章 PyMysql","heading":"10.2 连接数据库","text":"","code":"conn = pymysql.connect(\n  host = \"localhost\", #主机\n  port = 3306, #端口,int\n  user = \"root\",\n  database = \"订单录入\", # 选择数据库\n  password = \"990925wcldsg\" #密码\n  # autocommit = True 之后做出的操作会自动提交\n  # cursorclass = pymysql.cursors.DictCursor 让结果以字典形式呈现，默认是嵌套元组\n)"},{"path":"pymysql.html","id":"连接对象方法","chapter":"第10章 PyMysql","heading":"10.2.1 连接对象方法","text":"","code":""},{"path":"pymysql.html","id":"创建游标","chapter":"第10章 PyMysql","heading":"10.3 创建游标","text":"游标是SQL的一种数据访问机制，游标是一种处理数据的方法。使用SQL的select查询操作返回的结果是一个包含一行或者是多行的数据集。如果我们要对查询的结果再进行查询，比如（查看结果的第一行、下一行、最后一行、前十行等等操作）简单的通过select语句无法实现，因为此时索要查询的结果不是数据表，而是已经查询出来的结果集。游标就是针对这种情况而出现的.我们可以将”游标“简单的看成是结果集的一个指针，可以根据需要在结果集上面来回滚动，浏览我们需要的数据。","code":"cursor = conn.cursor()"},{"path":"pymysql.html","id":"游标对象方法","chapter":"第10章 PyMysql","heading":"10.3.1 游标对象方法","text":"","code":""},{"path":"pymysql.html","id":"使用游标执行语句","chapter":"第10章 PyMysql","heading":"10.3.2 使用游标执行语句","text":"","code":"sql = \"SELECT * FROM Customers\"\ncursor.execute(sql)5"},{"path":"pymysql.html","id":"获取结果","chapter":"第10章 PyMysql","heading":"10.3.3 获取结果","text":"","code":"cursor.fetchone()('1000000001', 'Village Toys', '200 Maple Lane', 'Detroit', 'MI', '44444', 'USA', 'John Smith', 'sales@villagetoys.com')"},{"path":"pymysql.html","id":"设置游标所在行","chapter":"第10章 PyMysql","heading":"10.3.4 设置游标所在行","text":"此时再用游标取所有的数，会发现第1行没有被取，因为之前取完第一行后，游标的位置已经到了下一行了，可以通过设置cursor.rownumber=0重新开始取。","code":"cursor.rownumber1cursor.fetchall()(('1000000002', 'Kids Place', '333 South Lake Drive', 'Columbus', 'OH', '43333', 'USA', 'Michelle Green', None), ('1000000003', 'Fun4All', '1 Sunny Place', 'Muncie', 'IN', '42222', 'USA', 'Jim Jones', 'jjones@fun4all.com'), ('1000000004', 'Fun4All', '829 Riverside Drive', 'Phoenix', 'AZ', '88888', 'USA', 'Denise L. Stephens', 'dstephens@fun4all.com'), ('1000000005', 'The Toy Store', '4545 53rd Street', 'Chicago', 'IL', '54545', 'USA', 'Kim Howard', None))cursor.rownumber = 1\n#下面会返回第二行的数据\ncursor.fetchone()('1000000002', 'Kids Place', '333 South Lake Drive', 'Columbus', 'OH', '43333', 'USA', 'Michelle Green', None)"},{"path":"pymysql.html","id":"提交变化","chapter":"第10章 PyMysql","heading":"10.4 提交变化","text":"当涉及对表的改变时，要提交变化，或者在创建conn设置autocommit为True。conn.commit()","code":""},{"path":"pymysql.html","id":"关闭游标","chapter":"第10章 PyMysql","heading":"10.5 关闭游标","text":"","code":"cursor.close()"},{"path":"pymysql.html","id":"关闭连接","chapter":"第10章 PyMysql","heading":"10.6 关闭连接","text":"","code":"conn.close()"},{"path":"pymysql.html","id":"使用with自动关闭","chapter":"第10章 PyMysql","heading":"10.7 使用with自动关闭","text":"先创建连接","code":"with conn:\n  with conn.cursor() as cursor:\n    cursor()\n  with conn.cursor() as cursor:\n    cursor()\n  ..."},{"path":"pymysql.html","id":"总结操作","chapter":"第10章 PyMysql","heading":"10.8 总结操作","text":"","code":"# Connect to the database\nconnection = pymysql.connect(host='localhost',\n                             user='root',\n                             port=3306,\n                             password='990925wcldsg',\n                             database='订单录入'\n                             #charset='utf8mb4'\n                             )\nwith connection:\n    with connection.cursor() as cursor:\n        # Read a single record\n        sql = \"select quantity,item_price from orderitems where quantity>%s\"\n        cursor.execute(sql, (5,))\n        result = cursor.fetchone()\n        print(result)\n    with connection.cursor() as cursor:\n        # 似乎参数不能作为列名\n        sql = \"select cust_id,%s from customers\"\n        cursor.execute(sql, (\"cust_name\",))\n        cursor.fetchone()16\n(100, Decimal('5.49'))\n5\n('1000000001', 'cust_name')"},{"path":"introduction-3.html","id":"introduction-3","chapter":"introduction","heading":"introduction","text":"介绍了机器学习等知识","code":""},{"path":"时间序列模型.html","id":"时间序列模型","chapter":"第11章 时间序列模型","heading":"第11章 时间序列模型","text":"","code":""},{"path":"时间序列模型.html","id":"理论知识","chapter":"第11章 时间序列模型","heading":"11.1 理论知识","text":"平稳时间序列分析: 平稳的，非随机序列(非白噪声序列)","code":""},{"path":"时间序列模型.html","id":"差分","chapter":"第11章 时间序列模型","heading":"11.1.1 差分","text":"一阶差分: \\(\\triangledown{x_t}=x_{t}-x_{t-1}\\)二阶差分: \\(\\triangledown^2{x_t}=\\triangledown{x_t}-\\triangledown{x_{t-1}}\\) 一阶差分的差分三阶差分: \\(\\triangledown^p{x_t}=\\triangledown^{p-1}{x_t}-\\triangledown^{p-1}{x_{t-1}}\\)必须先计算前一阶的差分k步差分：\\(\\triangledown_k{x_t}=x_t-x_{t-k}\\) 直接相隔k步计算差","code":""},{"path":"时间序列模型.html","id":"延迟算子","chapter":"第11章 时间序列模型","heading":"11.1.2 延迟算子","text":"当前序列值乘上一个延迟算子，相当于把当前序列值的序列时间向过去拨了一个时刻记B为延迟算子\\[x_{t-1}=Bx_t\\]\\[x_{t-2}=Bx_{t-2}\\]用延迟算子表示差分运算\\[\\triangledown^p{x_t}=(1-B)^px_t=\\sum^p_{=0}(-1)^pC^i_px_{t-}\\]\\[\\triangledown_kx_t=x_t-x_{t-k}=(1-B^k)x_t\\]","code":""},{"path":"时间序列模型.html","id":"平稳时间序列","chapter":"第11章 时间序列模型","heading":"11.1.3 平稳时间序列","text":"h(t)=AR(p):p阶自回归模型\\(x_t=\\phi_0+\\phi_1x_{t-1}+\\phi_2x_{t-2}+\\dots+\\phi_px_{t-p}+\\epsilon_t\\)\\(\\phi_p\\neq0\\)严宽平稳的联系和区别：\n严平稳：时间序列的任意n个时刻的联合分布保持不变，即序列的所有统计性质都不会因为时间的推移而发生变化\n宽平稳：时间序列任意时刻的均值保持不变，二阶矩存在且二阶矩只与时间有关\n严平稳和宽平稳的关系：\n如果二阶矩存在，严平稳一定是宽平稳\n如果是正态分布，则宽平稳代表严平稳\n\n严宽平稳的联系和区别：严平稳：时间序列的任意n个时刻的联合分布保持不变，即序列的所有统计性质都不会因为时间的推移而发生变化宽平稳：时间序列任意时刻的均值保持不变，二阶矩存在且二阶矩只与时间有关严平稳和宽平稳的关系：\n如果二阶矩存在，严平稳一定是宽平稳\n如果是正态分布，则宽平稳代表严平稳\n如果二阶矩存在，严平稳一定是宽平稳如果是正态分布，则宽平稳代表严平稳平稳性的意义平稳性的意义如果序列不平稳，那么序列就会有很多个随机变量，并且每个变量都只有一个样本，通常是没有办法进行分析的。\n但是如果序列平稳，那么均值为常数，这样意味着含有可列多个随机变量的均值序列变成了一个常数序列，这样样本数也就变成了时间序列的个数，\n这样减少了随机变量数，增加了待估参数的样本容量，降低了时序分析的难度，提高了对均值函数的估计精度平稳时间序列的统计性质\n常数均值:\\(E(X_t)=\\mu\\)\n自协方差函数：\\(\\gamma(t-s)=\\gamma(t,s)=E[(X_t-\\mu_t)(X_s-\\mu_s)]\\)\n自相关函数:\\(\\rho(t,s)=\\frac{\\gamma(t,s)}{\\sqrt{D(X_t)}\\sqrt{D(X_s)}}\\)\n延迟k自协方差函数：\\(\\gamma(k)=\\gamma(t,t+k)\\)\n方差：\\(D(X_t)=\\gamma(0)\\)为常数\n延迟k自相关系数：\\(\\rho(k)=\\frac{\\gamma(t,t+k)}{\\sqrt{\\gamma(0)}\\sqrt{\\gamma(0)}}\\space=\\space\\frac{\\gamma(k)}{\\gamma(0)}\\)\n平稳时间序列的统计性质常数均值:\\(E(X_t)=\\mu\\)自协方差函数：\\(\\gamma(t-s)=\\gamma(t,s)=E[(X_t-\\mu_t)(X_s-\\mu_s)]\\)自相关函数:\\(\\rho(t,s)=\\frac{\\gamma(t,s)}{\\sqrt{D(X_t)}\\sqrt{D(X_s)}}\\)延迟k自协方差函数：\\(\\gamma(k)=\\gamma(t,t+k)\\)方差：\\(D(X_t)=\\gamma(0)\\)为常数延迟k自相关系数：\\(\\rho(k)=\\frac{\\gamma(t,t+k)}{\\sqrt{\\gamma(0)}\\sqrt{\\gamma(0)}}\\space=\\space\\frac{\\gamma(k)}{\\gamma(0)}\\)","code":""},{"path":"时间序列模型.html","id":"wold分解定理","chapter":"第11章 时间序列模型","heading":"11.1.3.1 Wold分解定理","text":"Wold分解定理\n对于任意一个离散平稳时间序列，都可以分解成两个不相关的平稳序列之和，其中一个为确定性的，另一个为随机性的Wold分解定理对于任意一个离散平稳时间序列，都可以分解成两个不相关的平稳序列之和，其中一个为确定性的，另一个为随机性的\\(x_t=V_t+\\xi_t\\)\\(V_t=\\sum_{j=1}^{\\infty}\\phi_jx_{t-j}\\),等价表达为历史序列值的线性函数\\(\\xi_t=\\sum_{j=0}^{\\infty}\\theta_j\\epsilon_{t-j}\\),代表了不能有历史信息表达的部分，其中\\(\\theta_0=1,\\sum_{j=0}^{\\infty}\\theta_j^2 \\leq \\infty,\\epsilon独立，通常假定0均值正态分布\\)对任意平稳时间序列而言，做线性回归\\(y_t=a_0+a_1y_{t-1}+a_2y_{t-2}+\\dots+a_py_{t-p}+v_t\\)前面的是确定性部分，后面的\\(v_t\\)是非确定性部分，它的方差决定了p期历史信息对未来的预测精度如果方差极限趋向0，则\\(y_t\\)为确定性序列\n如果方差极限趋向\\(var(y_t)\\),则\\(y_t\\)为纯随机性序列绝大多数序列结语确定性序列和纯随机性序列中间，即\\(0和var(y_t)\\)之间，序列中既包含部分确定性信息，又包含部分随机信息，这是我们把序列简称为随机序列","code":""},{"path":"时间序列模型.html","id":"平稳序列的特征根","chapter":"第11章 时间序列模型","heading":"11.1.3.2 平稳序列的特征根","text":"p阶线性差分方程：\\(x_t+a_1x_{t-1}+\\dots+a_px_{t-p}=h_t\\)一阶：\n\\[x_t-0.8x_{t-1}=0\\]\n\\[\\lambda^1-0.8\\times \\lambda^0=0,得\\lambda=0.8\\]\n\\[1-0.8B=0,得B=1/0.8\\]方程的根是特征根的倒数二阶:\n\\[x_t-0.6x_{t-1}+0.05x_{t-2}=0\\]\n\\[\\lambda^2-0.6\\lambda+0.05=0,得\\lambda_1=0.5,\\lambda_2=0.1\\]\n\\[1-0.6B+0.05B^2=0 得B_1=2,B_2=10\\]","code":""},{"path":"时间序列模型.html","id":"平稳序列特征根的性质","chapter":"第11章 时间序列模型","heading":"11.1.3.3 平稳序列特征根的性质","text":"平稳序列必须满足特征根的绝对值都小于1*平稳性检验图检验DF检验：当\\(\\tau\\)值小于\\(\\tau_\\alpha时\\)，拒绝原假设，序列平稳，即序列无单位根，即p值较小时。只能检验最高延迟一阶信息\n无漂移项自回归结构：\\(x_t=\\phi_1x_{t-1}+\\xi_t\\)\n有漂移项自回归结构：\\(x_t=\\phi_0+\\phi_1x_{t-1}+\\xi_t\\)\n带趋势回归结构：\\(x_t=\\alpha+\\beta t+\\phi_1x_{t-1}+\\xi_t\\)\n无漂移项自回归结构：\\(x_t=\\phi_1x_{t-1}+\\xi_t\\)有漂移项自回归结构：\\(x_t=\\phi_0+\\phi_1x_{t-1}+\\xi_t\\)带趋势回归结构：\\(x_t=\\alpha+\\beta t+\\phi_1x_{t-1}+\\xi_t\\)ADF检验：可以检验更高的延迟阶数\n只要有一个单位根，则不平稳\n只要有一个单位根，则不平稳纯随机性检验如果序列值彼此之间没有任何相关性，那就意味着该序列是一个没有记忆的序列，过去的行为对将来的发展没有任何影响，这种序列称为纯随机序列，从统计分析的角度，纯随机序列是没有任何分析价值。纯随机序列(白噪声序列)定义：简记为\\(X_t\\sim WN(\\mu,\\sigma^2)\\)\n任取\\(t\\T,有EX_t=\\mu\\)\n任取\\(t，s\\T\\)，有\n\\[\\gamma(t,s)=\\begin{cases}\\sigma^2 & t=s\\\\0 & t\\neq s\\end{cases}\\]\n任取\\(t\\T,有EX_t=\\mu\\)任取\\(t，s\\T\\)，有\n\\[\\gamma(t,s)=\\begin{cases}\\sigma^2 & t=s\\\\0 & t\\neq s\\end{cases}\\]纯随机序列性质\n纯随机性\n方差齐性：序列中每个随机变量的方差相等，如果不满足，则是异方差\n纯随机性方差齐性：序列中每个随机变量的方差相等，如果不满足，则是异方差纯随机性检验\n如果一个时间序列是纯随机的，得到一个观察期数为n的观察序列，那么该序列的延迟非零期的样本自相关系数将近似服从均值为零，方差为序列观察期数倒数的正态分布，即:\n\\[    \\hat{\\rho_k} \\sim N(0,\\frac{1}{n}),\\forall k \\neq0\\]\n原假设：延迟期数小于或等于m期的序列值之间相互独立\n备则假设：延迟期数小于或等于m期的序列值之间有相关性\nQ统计量\n\\[Q_{BP}=n\\sum_{k=1}^m\\hat{\\rho_k}^2\\]\n\\[Q_{LB}=n(n+2)\\sum_{k=1}^{m}(\\frac{\\hat{\\rho_k}^2}{n-k})\\]\nn为观察期数，m为延迟阶数\n这两种Q统计量都服从\\(Q\\sim \\chi^2(m)\\)\n平稳序列的短期相关性，所以一般只需要检验前几期。另一方面，如果一个平稳序列显示出显著的短期相关性，那么该序列就一定不是白噪声序列\n如果一个时间序列是纯随机的，得到一个观察期数为n的观察序列，那么该序列的延迟非零期的样本自相关系数将近似服从均值为零，方差为序列观察期数倒数的正态分布，即:\n\\[    \\hat{\\rho_k} \\sim N(0,\\frac{1}{n}),\\forall k \\neq0\\]原假设：延迟期数小于或等于m期的序列值之间相互独立备则假设：延迟期数小于或等于m期的序列值之间有相关性Q统计量\n\\[Q_{BP}=n\\sum_{k=1}^m\\hat{\\rho_k}^2\\]\n\\[Q_{LB}=n(n+2)\\sum_{k=1}^{m}(\\frac{\\hat{\\rho_k}^2}{n-k})\\]\nn为观察期数，m为延迟阶数\n这两种Q统计量都服从\\(Q\\sim \\chi^2(m)\\)平稳序列的短期相关性，所以一般只需要检验前几期。另一方面，如果一个平稳序列显示出显著的短期相关性，那么该序列就一定不是白噪声序列","code":""},{"path":"时间序列模型.html","id":"ar模型","chapter":"第11章 时间序列模型","heading":"11.1.4 AR模型","text":"函数形式\n\\[X_t=\\phi_1X_{t-1}+\\phi_2X_{t-2}+\\dots+\\phi_pX_{t-p}+\\epsilon_t,或\\Phi(B)X_t=\\epsilon_t\\]统计性质\n均值\\(E(X_t)=\\mu\\)\n方差：\nAR(1）：\\(G_0=1,G_1=\\phi_1G_0,G_2=\\phi_1G_1,方差\\gamma_0=\\frac{\\sigma_\\epsilon^2}{1-\\phi_1^2}\\)\nAR(2) : \\(G_0=1.G_1=\\phi_1G_0,G_2=\\Phi_1G_1+\\phi_2G_0,方差\\gamma_0=\\frac{1-\\phi_2}{(1+\\phi_2)(1+\\phi_1-\\phi_2)(1-\\phi_1-\\phi_2)}\\sigma_\\epsilon^2\\)\n\\[D(X_t)=\\sum_0^\\infty G_i^2\\sigma_\\epsilon^2\\]\n\n自协方差\n公式:\\(\\gamma_k=\\phi_1\\gamma_{k-1}+\\phi_2\\gamma_{k-2}\\)\nAR(1):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0,\\gamma_2=\\phi_1\\gamma_1\\)\nAR(2):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0+\\phi_2\\gamma_1得\\gamma_1=\\frac{\\phi_1}{1-\\phi_2}\\gamma_0\\)\n\n自相关\n自协方差函数除以\\(\\gamma_0\\)\n\n偏自相关\nyule-Walker方程:写自相关函数的方程\nAR(1):\\(\\phi_{11}=\\phi_1,其他为0\\)\nAR(2):\\(\\phi_{11}=\\rho_1=\\frac{\\phi_1}{1-\\phi_2},\\phi_{22}=\\phi_2,其他为0\\)\n\n均值\\(E(X_t)=\\mu\\)方差：\nAR(1）：\\(G_0=1,G_1=\\phi_1G_0,G_2=\\phi_1G_1,方差\\gamma_0=\\frac{\\sigma_\\epsilon^2}{1-\\phi_1^2}\\)\nAR(2) : \\(G_0=1.G_1=\\phi_1G_0,G_2=\\Phi_1G_1+\\phi_2G_0,方差\\gamma_0=\\frac{1-\\phi_2}{(1+\\phi_2)(1+\\phi_1-\\phi_2)(1-\\phi_1-\\phi_2)}\\sigma_\\epsilon^2\\)\n\\[D(X_t)=\\sum_0^\\infty G_i^2\\sigma_\\epsilon^2\\]\nAR(1）：\\(G_0=1,G_1=\\phi_1G_0,G_2=\\phi_1G_1,方差\\gamma_0=\\frac{\\sigma_\\epsilon^2}{1-\\phi_1^2}\\)AR(2) : \\(G_0=1.G_1=\\phi_1G_0,G_2=\\Phi_1G_1+\\phi_2G_0,方差\\gamma_0=\\frac{1-\\phi_2}{(1+\\phi_2)(1+\\phi_1-\\phi_2)(1-\\phi_1-\\phi_2)}\\sigma_\\epsilon^2\\)\n\\[D(X_t)=\\sum_0^\\infty G_i^2\\sigma_\\epsilon^2\\]自协方差\n公式:\\(\\gamma_k=\\phi_1\\gamma_{k-1}+\\phi_2\\gamma_{k-2}\\)\nAR(1):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0,\\gamma_2=\\phi_1\\gamma_1\\)\nAR(2):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0+\\phi_2\\gamma_1得\\gamma_1=\\frac{\\phi_1}{1-\\phi_2}\\gamma_0\\)\n公式:\\(\\gamma_k=\\phi_1\\gamma_{k-1}+\\phi_2\\gamma_{k-2}\\)AR(1):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0,\\gamma_2=\\phi_1\\gamma_1\\)AR(2):\\(\\gamma_0=D(X),\\gamma_1=\\phi_1\\gamma_0+\\phi_2\\gamma_1得\\gamma_1=\\frac{\\phi_1}{1-\\phi_2}\\gamma_0\\)自相关\n自协方差函数除以\\(\\gamma_0\\)\n自协方差函数除以\\(\\gamma_0\\)偏自相关\nyule-Walker方程:写自相关函数的方程\nAR(1):\\(\\phi_{11}=\\phi_1,其他为0\\)\nAR(2):\\(\\phi_{11}=\\rho_1=\\frac{\\phi_1}{1-\\phi_2},\\phi_{22}=\\phi_2,其他为0\\)\nyule-Walker方程:写自相关函数的方程AR(1):\\(\\phi_{11}=\\phi_1,其他为0\\)AR(2):\\(\\phi_{11}=\\rho_1=\\frac{\\phi_1}{1-\\phi_2},\\phi_{22}=\\phi_2,其他为0\\)","code":""},{"path":"时间序列模型.html","id":"ma模型","chapter":"第11章 时间序列模型","heading":"11.1.5 MA模型","text":"均值：\\(E(X_t)=\\mu\\)方差: \\(D(X_t)=(1+\\theta_0+\\dots+\\theta_q)\\sigma_\\epsilon^2\\)协方差\nMA(1)\\(\\begin{cases}(1+\\theta_1^2+\\dots+\\theta_q^2)\\sigma_\\epsilon^2& q = 0\\\\-\\theta_1\\sigma_\\epsilon^2 & q = 1\\end{cases}\\)\nMA(2)\\(\\begin{cases}(1+\\theta_1^2+\\dots+\\theta_q^2)\\sigma_\\epsilon^2& q = 0\\\\(-\\theta_1+\\theta_1\\theta_2)\\sigma_\\epsilon^2 & q = 1\\\\ -\\theta_2\\sigma_\\epsilon^2&q=2\\end{cases}\\)\nMA(1)\\(\\begin{cases}(1+\\theta_1^2+\\dots+\\theta_q^2)\\sigma_\\epsilon^2& q = 0\\\\-\\theta_1\\sigma_\\epsilon^2 & q = 1\\end{cases}\\)MA(2)\\(\\begin{cases}(1+\\theta_1^2+\\dots+\\theta_q^2)\\sigma_\\epsilon^2& q = 0\\\\(-\\theta_1+\\theta_1\\theta_2)\\sigma_\\epsilon^2 & q = 1\\\\ -\\theta_2\\sigma_\\epsilon^2&q=2\\end{cases}\\)自相关\n除以方差\n除以方差偏自相关\nyule-walker方程\nMA(1)\\(\\begin{cases}\\phi_{11}=\\rho_1=\\frac{-\\theta_1}{1+\\theta_1^2}& k = 1\\\\ \\phi_{22}=\\frac{\\theta_1^2}{1+\\theta_1^2+\\theta_1^4} & k= 2\\\\ \\phi_{33}=\\frac{-\\theta_1^3}{1+\\theta_1^2+\\theta_1^4+\\theta_1^6}&k=3\\end{cases}\\)\n\\(\\phi_{kk}=\\frac{-\\theta_1^k}{\\sum_0^\\infty\\theta_1^{2j}}\\)yule-walker方程MA(1)\\(\\begin{cases}\\phi_{11}=\\rho_1=\\frac{-\\theta_1}{1+\\theta_1^2}& k = 1\\\\ \\phi_{22}=\\frac{\\theta_1^2}{1+\\theta_1^2+\\theta_1^4} & k= 2\\\\ \\phi_{33}=\\frac{-\\theta_1^3}{1+\\theta_1^2+\\theta_1^4+\\theta_1^6}&k=3\\end{cases}\\)","code":""},{"path":"时间序列模型.html","id":"arma模型","chapter":"第11章 时间序列模型","heading":"11.1.6 ARMA模型","text":"均值均值方差：\n格林公式：\\(\\begin{cases}G_0=1 & j = 0\\\\G_k=\\sum_{j=1}^k\\phi_j^\\prime G_{k-j}-\\theta_k^\\prime & j > 0\\end{cases}\\)\nARMA(2,2):\\(G_0=1,G_1=\\phi_1G_0-\\theta_1,G_2=\\phi_1G_1+\\phi_2G_0-\\theta_2,G_3=\\phi_1G_2+\\phi_2G_1\\)\n方差：格林公式：\\(\\begin{cases}G_0=1 & j = 0\\\\G_k=\\sum_{j=1}^k\\phi_j^\\prime G_{k-j}-\\theta_k^\\prime & j > 0\\end{cases}\\)ARMA(2,2):\\(G_0=1,G_1=\\phi_1G_0-\\theta_1,G_2=\\phi_1G_1+\\phi_2G_0-\\theta_2,G_3=\\phi_1G_2+\\phi_2G_1\\)自协方差\n\\(y_k=\\sigma_\\epsilon^2\\sum_{=0}^\\infty G_iG_{+k}\\)\n自协方差\\(y_k=\\sigma_\\epsilon^2\\sum_{=0}^\\infty G_iG_{+k}\\)自相关\n\\(\\rho_k=\\frac{\\gamma_k}{\\gamma_0}=\\frac{\\sum_{j=0}^\\infty G_jG_{j+k}}{\\sum_{j=0}^{\\infty}G_j^2}\\)\n自相关\\(\\rho_k=\\frac{\\gamma_k}{\\gamma_0}=\\frac{\\sum_{j=0}^\\infty G_jG_{j+k}}{\\sum_{j=0}^{\\infty}G_j^2}\\)ARMA(1,1)\n\\[G_0=1,G_k=(\\phi_1-\\theta_1)\\phi_1^{k-1}\\]\n\\[\\gamma_0=\\frac{1+\\theta_1^2-2\\theta_1\\phi_1}{1-\\phi_1^2}\\sigma_\\epsilon^2\\]\n\\[\\gamma_1=\\frac{(\\phi_1-\\theta)(1-\\theta_1\\phi_1)}{1-\\phi_1^2}\\sigma_\\epsilon^2\\]\n\\[\\gamma_2=\\phi_1\\gamma_1\\]\n\\[\\rho_1=\\frac{(\\phi_1-\\theta_1)(1-\\theta_1\\phi_1)}{1+\\theta_1^2-2*\\theta_1\\phi_1}\\]\n\\[\\rho_2=\\phi_1\\rho_1\\]ARMA(1,1)\n\\[G_0=1,G_k=(\\phi_1-\\theta_1)\\phi_1^{k-1}\\]\n\\[\\gamma_0=\\frac{1+\\theta_1^2-2\\theta_1\\phi_1}{1-\\phi_1^2}\\sigma_\\epsilon^2\\]\n\\[\\gamma_1=\\frac{(\\phi_1-\\theta)(1-\\theta_1\\phi_1)}{1-\\phi_1^2}\\sigma_\\epsilon^2\\]\n\\[\\gamma_2=\\phi_1\\gamma_1\\]\n\\[\\rho_1=\\frac{(\\phi_1-\\theta_1)(1-\\theta_1\\phi_1)}{1+\\theta_1^2-2*\\theta_1\\phi_1}\\]\n\\[\\rho_2=\\phi_1\\rho_1\\]偏自相关\nyule-walker方程\n偏自相关yule-walker方程","code":""},{"path":"时间序列模型.html","id":"crammer分解定理","chapter":"第11章 时间序列模型","heading":"11.1.7 Crammer分解定理","text":"任何一个时间序列\\({x_t}\\)都可以视为两部分的叠加，其中，一部分是由时间t的多项式决定的确定性成分，另一部分是由白噪声序列决定的随机性成分，即\n\\(x_t=\\mu_t+\\epsilon_t=\\sum_{j=0}^d\\beta_jt^j+\\Psi(B)a_t\\)Crammer分解定理说明任何一个序列的波动都可以视为同时受到确定性影响和随机性影响的作用，平稳序列要求这两方面的影响都是稳定的，而非平稳的产生的激励就在于它所受到的这两方面的影响至少有一方面是不稳定的","code":""},{"path":"时间序列模型.html","id":"arima模型","chapter":"第11章 时间序列模型","heading":"11.1.8 ARIMA模型","text":"\\(\\Phi(B)\\triangledown^dx_t=\\Theta(B)\\epsilon_t\\)广义自回归多项式:\\(\\phi(B)=\\Phi(B)\\triangledown^d\\)ARIMA(p,d,q)模型不平稳，并且序列方差不满足方差齐性\\(x_t=\\epsilon_t+\\Psi_1\\epsilon_{t-1}+\\Psi_2\\epsilon_{t-2}-\\dots\\)广义自相关函数\\(\\Phi^*(B)=\\Phi(B)(1-B)^d=1-\\tilde{\\phi_1}B-\\tilde{\\phi_2}B^2-\\dots\\)\\(\\Psi_1=\\tilde{\\phi_1}-\\theta_1\\)\\(\\Psi_2=\\tilde{\\phi_1}\\Psi_1+\\tilde{\\phi_2}-\\theta_2\\)疏系数模型: \\(ARIMA((p_1,p_2),d,q)\\)","code":""},{"path":"时间序列模型.html","id":"实践操作","chapter":"第11章 时间序列模型","heading":"11.2 实践操作","text":"","code":"import pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\nimport statsmodels.tsa.api as tsa\nimport statsmodels.formula.api as smf\nimport matplotlib.pyplot as plt\nimport statsmodels\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\nfrom statsmodels.graphics.api import qqplot\nfrom scipy import statsimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = 'all'# 导入数据\ndata=pd.read_excel('../习题与案例数据/案例数据/A1_7.xlsx',index_col='year')\ndata.index=pd.date_range('1900','1999',freq='a')#不要以年份做索引，可能会有问题\ndata"},{"path":"时间序列模型.html","id":"绘制时序图","chapter":"第11章 时间序列模型","heading":"11.2.1 绘制时序图","text":"","code":"plt.plot(data)[<matplotlib.lines.Line2D at 0x168d9804d88>]"},{"path":"时间序列模型.html","id":"模型识别","chapter":"第11章 时间序列模型","heading":"11.2.2 模型识别","text":"","code":""},{"path":"时间序列模型.html","id":"序列的描述性统计","chapter":"第11章 时间序列模型","heading":"11.2.2.1 序列的描述性统计","text":"序列的平稳性检验结果adf检验返回adf,p值，回归阶数，样本数，0.01,0.05,0.1分位点的值，aic等信息准则的值，等。从漂移项加自回归，或者漂移项+趋势项+自回归都可以看出，模型是平稳的","code":"tsa.adfuller(data['number'])#array_like, 1d data series\n#help(tsa.adfuller)(-3.183192251191782,\n 0.02097842525600371,\n 2,\n 96,\n {'1%': -3.5003788874873405,\n  '5%': -2.8921519665075235,\n  '10%': -2.5830997960069446},\n 549.0681467660734)\n\nmaxlag：最大滞后阶数，也就是自回归阶数\nregression：自回归项是一定被包括的，maxlag设定了阶数\n'c':只有常数项（漂移项）\n'ct':漂移项和趋势项\n'nc':只有自回归项\n'ctt':constant, and linear and quadratic trend\nautolag：自动选择lag，基于bic，aic等准则，只有设置为None，自己设置的maxlag才会被使用，否则模型会自动选择最好的lag\n其他的见上面tsa.adfuller(data.number,autolag=None,maxlag=1)#自己设置模型的lag为1,maxlag代表差分阶数(-3.9178563779331284,\n 0.001907294129421782,\n 1,\n 97,\n {'1%': -3.4996365338407074,\n  '5%': -2.8918307730370025,\n  '10%': -2.5829283377617176})reg=['nc','c','ct']\nlag=[0,1,2]\nmodel=['自回归','漂移项+自回归','漂移项+趋势项+自回归']\nresults=[]\nfor i in reg:\n    for j in lag:\n        types=model[reg.index(i)]\n        stat,p=tsa.adfuller(data.number,autolag=None,maxlag=j,regression=i)[:2]\n        results.append([types,j,stat,p])\npd.DataFrame(results,columns=['type','lag','统计量值','p值'])dir(tsa.adfuller(data.number,regresults=True)[-1])[:2]+dir(tsa.adfuller(data.number,regresults=True)[-1])[-8:]\ntsa.adfuller(data.number,regresults=True)[-1].adfstat#返回adf值['H0',\n 'HA',\n 'adfstat',\n 'autolag_results',\n 'critvalues',\n 'icbest',\n 'maxlag',\n 'nobs',\n 'resols',\n 'usedlag']\n\n-3.183192251191782"},{"path":"时间序列模型.html","id":"序列的纯随机性检验结果","chapter":"第11章 时间序列模型","heading":"11.2.2.2 序列的纯随机性检验结果","text":"纯随机性检验也就是LB检验，利用Q统计量因为LB统计量（Q统计量的修正）是利用k阶延迟自相关系数来计算的，所以必须获得前k阶的自相关系数。k一般取6或12","code":"# 计算k阶延迟自相关\ntsa.acf(data.number,nlags=12)#从0步到12步,但是实际计算q统计量是从1步开始算的。所以实际计算时应该去掉0步array([ 1.        ,  0.54173285,  0.41888438,  0.39795532,  0.32404731,\n        0.23716419,  0.17179424,  0.19022816,  0.06120181, -0.04850548,\n       -0.10673042, -0.04327143, -0.07230482])#计算k阶延迟偏自相关\ntsa.pacf(data.number,nlags=12)array([ 1.        ,  0.54726074,  0.18276348,  0.17599425,  0.04046234,\n       -0.02925253, -0.04206131,  0.0784646 , -0.14778847, -0.15651177,\n       -0.1296911 ,  0.113972  ,  0.01187113])#计算Q统计量\n\nq_acf=tsa.q_stat(tsa.acf(data.number,nlags=12)[1:],nobs=len(data.number))#用自相关系数计算Q统计量,nobs为总的样本量，而不是自相关的延迟阶数\n#q_pacf=tsa.q_stat(tsa.pacf(data.number,nlags=12)[1:],nobs=len(data.number))\nq_acf\n#q_pacf(array([29.94338136, 48.03065781, 64.52572016, 75.57794735, 81.56105668,\n        84.73420816, 88.66715745, 89.07872742, 89.34012141, 90.61992405,\n        90.83267742, 91.43353531]),\n array([4.44847764e-08, 3.71770714e-11, 6.33585229e-14, 1.50371504e-15,\n        3.95511245e-16, 3.74733217e-16, 2.32297279e-16, 7.15231635e-16,\n        2.20818568e-15, 4.03523693e-15, 1.14482818e-14, 2.60445654e-14]))help(tsa.q_stat)Help on function q_stat in module statsmodels.tsa.stattools:\n\nq_stat(x, nobs, type='ljungbox')\n    Return's Ljung-Box Q Statistic\n    \n    x : array-like\n        Array of autocorrelation coefficients.  Can be obtained from acf.\n    nobs : int\n        Number of observations in the entire sample (ie., not just the length\n        of the autocorrelation function results.\n    \n    Returns\n    -------\n    q-stat : array\n        Ljung-Box Q-statistic for autocorrelation parameters\n    p-value : array\n        P-value of the Q statistic\n    \n    Notes\n    -----\n    Written to be used with acf.#acf,pacf都代表\ndef suiji(data,nobs,lag=12):\n    suiji=pd.DataFrame()\n    suiji['acf']=tsa.acf(data,nlags=lag)[1:]\n    suiji['pacf']=tsa.pacf(data,nlags=lag)[1:]\n    suiji['Q']=tsa.q_stat(tsa.acf(data,nlags=lag)[1:],nobs=nobs)[0]\n    suiji['P']=tsa.q_stat(tsa.acf(data,nlags=lag)[1:],nobs=nobs)[1]\n    return suijisuiji(data.number,lag=12,nobs=len(data.number))"},{"path":"时间序列模型.html","id":"序列的各种自相关图","chapter":"第11章 时间序列模型","heading":"11.2.2.3 序列的各种自相关图","text":"绘制时间序列图形的包在statsmodels中 statsmodels.graphics.tsaplots import plot_acf, plot_pacf从相关图形和q统计量都可以看出，在短期内是存在相关性的，所以这是一个非纯随机时间序列，非白噪声序列。可以进行进一步的分析，也就是建模分析，预测。","code":"from statsmodels.graphics.tsaplots import plot_acf, plot_pacfplot_acf(data.number).show()\nplot_pacf(data.number).show()"},{"path":"时间序列模型.html","id":"模型构建","chapter":"第11章 时间序列模型","heading":"11.2.3 模型构建","text":"从自相关图可以看出是拖尾的，从偏相关图可以看出是截尾的。阶数为2.所以应该应用AR(2)模型我们下面只看ARMA的实现，因为AR模型就相当于与ARMA（p，0）","code":"#导入ar和arma模型的一种方式\nfrom statsmodels.tsa import ar_model\nfrom statsmodels.tsa import arima_model\nar_model.AR\narima_model.ARMAstatsmodels.tsa.ar_model.AR\n\nstatsmodels.tsa.arima_model.ARMA#导入statsmodels.api后，在tsa下可以直接运用模型\nsm.tsa.AR\nsm.tsa.ARMAstatsmodels.tsa.ar_model.AR\n\nstatsmodels.tsa.arima_model.ARMA"},{"path":"时间序列模型.html","id":"模型定阶","chapter":"第11章 时间序列模型","heading":"11.2.3.1 模型定阶","text":"模型的显著性检验先不看,可以看到参数的检验都是通过的，而通过根的大小（都大于1）我们可以判断出这个AR模型是平稳的。其实python中还允许利用函数来判断一个arma模型的平稳性和可逆性，statsmodels.tsa.arima_process import ArmaProcess但是需要事先构建模型获得系数参数见模型定阶的简便方法另外需要注意的是python中的arma模型不允许构建不平稳的模型，否则会报错。所以我们先在利用bic准则，查看5阶内所有的模型的bic量，对于报错的我们把它的bic定为无穷可以看到AR(1,1)模型bic最小，并且模型平稳，我们最终模型定阶为（1，1）","code":"#构建arma模型，首先是创建arma模型实例，给与一个时间序列数据\narma_mod20=sm.tsa.ARMA(data,(2,0))#数据是序列或数据框，索引是时间序列数据,并且设置阶数\narma_mod20fit=arma_mod20.fit(disp=-1,trend='c')#这里面可以选择方法和是否添加常数项等。默认有常数项\narma_mod20fit.summary()from statsmodels.tsa.arima_process import ArmaProcess\nnp.random.seed(1234)\n# include zero-th lag\n#arma（4,1）\narparams = np.array([1, .75, -.65, -.55, .9])#4阶ar，注意需要包含0阶，这实际上就是自回归系数多项式\nmaparams = np.array([1, .65])#1阶ma，注意需要包含0阶，这实际上就是系数多项式\narma_t = ArmaProcess(arparams, maparams)#传递ar和ma的系数参数\narma_t.isinvertible#判断可逆性\narma_t.isstationary#判断平稳性True\n\nFalsefig = plt.figure(figsize=(12,8))\nax = fig.add_subplot(111)\nax.plot(arma_t.generate_sample(nsample=50));p=range(6)\nq=range(6)\nrank=[]\nfor i in p:\n    con=[]\n    for j in q:\n        try:\n            con.append(arima_model.ARMA(data.number,(i,j)).fit(disp=-1).bic)\n        except:\n            con.append(np.Inf)\n    rank.append(con)\nrank=pd.DataFrame(rank,index=['AR'+str(i) for i in p],columns=['MA'+str(j) for j in q])\nrankrank.min()MA0    651.753037\nMA1    650.836763\nMA2    655.356467\nMA3    658.633388\nMA4    662.699747\nMA5    666.007394\ndtype: float64"},{"path":"时间序列模型.html","id":"检验","chapter":"第11章 时间序列模型","heading":"11.2.3.2 检验","text":"包括模型的显著性，也即残差是否是一个白噪声序列残差的相关性检验，DW检验对于arma模型，我们假定残差服从正态分布，所以需要检验残差的正态性","code":""},{"path":"时间序列模型.html","id":"相关性检验","chapter":"第11章 时间序列模型","heading":"11.2.3.3 相关性检验","text":"","code":"sm.stats.durbin_watson(arma_mod11fit.resid.values)1.959664111340092fig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(111)\nax1.plot(arma_mod11fit.resid)[<matplotlib.lines.Line2D at 0x168dc340f88>]"},{"path":"时间序列模型.html","id":"正态性检验","chapter":"第11章 时间序列模型","heading":"11.2.3.4 正态性检验","text":"","code":"from scipy import stats\n#正态检验\nresid = arma_mod11fit.resid\nstats.normaltest(resid)#利用stats包中的正态测试\n#利用qq图\nfrom statsmodels.graphics.api import qqplot\nfig = plt.figure(figsize=(12,8))\nax = fig.add_subplot(111)\nfig = qqplot(resid, line='q', ax=ax, fit=True)NormaltestResult(statistic=5.939742977265384, pvalue=0.051309903814136935)"},{"path":"时间序列模型.html","id":"随机性检验","chapter":"第11章 时间序列模型","heading":"11.2.3.5 随机性检验","text":"即检验模型的显著性从检验看出残差之间相关性很弱，满足假设","code":"#残差的随机性检验\nr,q,p = sm.tsa.acf(resid.values.squeeze(), fft=True, qstat=True)\ndata1 = np.c_[range(1,41), r[1:], q, p]#默认是40期\ntable = pd.DataFrame(data1, columns=['lag', \"AC\", \"Q\", \"Prob(>Q)\"])\nprint(table.set_index('lag'))\n#当残差的随机性检验不通过的时候，可以通过残差的相关图看看还有哪些相关关系未提取干净\nfig = plt.figure(figsize=(12,8))\nax1 = fig.add_subplot(211)\nfig = sm.graphics.tsa.plot_acf(resid.values.squeeze(), lags=40, ax=ax1)\nax2 = fig.add_subplot(212)\nfig = sm.graphics.tsa.plot_pacf(resid, lags=40, ax=ax2)            AC          Q  Prob(>Q)\nlag                                \n1.0   0.010300   0.010825  0.917133\n2.0  -0.063396   0.425117  0.808513\n3.0   0.065777   0.875755  0.831274\n4.0   0.047298   1.111215  0.892489\n5.0  -0.004223   1.113112  0.952937\n6.0  -0.028136   1.198227  0.976972\n7.0   0.144325   3.462101  0.839223\n8.0  -0.002454   3.462763  0.902060\n9.0  -0.113296   4.888849  0.843888\n10.0 -0.157036   7.659406  0.662066\n11.0  0.045036   7.889868  0.723134\n12.0  0.018466   7.929059  0.790649\n13.0 -0.056399   8.298885  0.823598\n14.0 -0.067152   8.829343  0.841825\n15.0 -0.011891   8.846175  0.885422\n16.0 -0.171222  12.377992  0.717576\n17.0 -0.011226  12.393360  0.775755\n18.0 -0.019499  12.440294  0.823693\n19.0  0.147969  15.176856  0.711292\n20.0 -0.014903  15.204967  0.764562\n21.0 -0.023304  15.274586  0.808926\n22.0  0.098692  16.539408  0.788244\n23.0 -0.148043  19.422915  0.676424\n24.0 -0.092072  20.553106  0.664927\n25.0  0.050855  20.902567  0.698030\n26.0  0.171934  24.951672  0.521712\n27.0 -0.003867  24.953749  0.577054\n28.0  0.003667  24.955643  0.630249\n29.0 -0.088285  26.068993  0.621801\n30.0  0.042425  26.329814  0.658196\n31.0 -0.039924  26.564193  0.693876\n32.0  0.075991  27.425989  0.697433\n33.0  0.091602  28.697210  0.681352\n34.0  0.053442  29.136551  0.704902\n35.0 -0.034872  29.326542  0.738179\n36.0 -0.068495  30.071156  0.745837\n37.0  0.060894  30.669183  0.759259\n38.0 -0.057669  31.214327  0.774112\n39.0  0.030721  31.371606  0.802514\n40.0  0.020507  31.442874  0.831202"},{"path":"时间序列模型.html","id":"预测","chapter":"第11章 时间序列模型","heading":"11.2.3.6 预测","text":"利用模型的predict函数和predict_plot函数，可以预测值，以及绘制预测值的图","code":"arma_mod11fit.predict('1980','2005')1980-12-31    17.465377\n1981-12-31    18.049009\n1982-12-31    16.729012\n1983-12-31    14.577349\n1984-12-31    15.606044\n1985-12-31    13.299255\n1986-12-31    15.047666\n1987-12-31    12.267820\n1988-12-31    13.022072\n1989-12-31    12.170360\n1990-12-31    11.404516\n1991-12-31    13.432397\n1992-12-31    13.137112\n1993-12-31    18.126782\n1994-12-31    17.550478\n1995-12-31    16.904956\n1996-12-31    20.560380\n1997-12-31    20.976142\n1998-12-31    20.370293\n1999-12-31    18.530631\n2000-12-31    18.723334\n2001-12-31    18.883399\n2002-12-31    19.016353\n2003-12-31    19.126788\n2004-12-31    19.218519\n2005-12-31    19.294713\nFreq: A-DEC, dtype: float64fig, ax = plt.subplots(figsize=(12, 4))\nax.plot(data)\n#arma_mod11fit.plot_predict('2000', '2006',)有问题\nax.plot(arma_mod11fit.predict())[<matplotlib.lines.Line2D at 0x168dd0b0fc8>]\n\n[<matplotlib.lines.Line2D at 0x168dd0b9b88>]arma_mod11fit.fittedvalues1900-12-31    19.668380\n1901-12-31    16.071618\n1902-12-31    15.810983\n1903-12-31    13.350267\n1904-12-31    13.098084\n                ...    \n1994-12-31    17.550478\n1995-12-31    16.904956\n1996-12-31    20.560380\n1997-12-31    20.976142\n1998-12-31    20.370293\nFreq: A-DEC, Length: 99, dtype: float64arma_mod11fit.forecast(5)(array([18.5306311 , 18.72333411, 18.8833986 , 19.01635263, 19.12678795]),\n array([5.88763837, 6.32759403, 6.61409924, 6.80474257, 6.93322013]),\n array([[ 6.99107194, 30.07019026],\n        [ 6.32147771, 31.12519051],\n        [ 5.92000229, 31.84679491],\n        [ 5.67930228, 32.35340298],\n        [ 5.5379262 , 32.7156497 ]]))arma_mod11fit.predict('1999','2005')1999-12-31    18.530631\n2000-12-31    18.723334\n2001-12-31    18.883399\n2002-12-31    19.016353\n2003-12-31    19.126788\n2004-12-31    19.218519\n2005-12-31    19.294713\nFreq: A-DEC, dtype: float64fig,ax=plt.subplots(figsize=(12,8))\nax.plot(data,color='black')\nax.plot(arma_mod11fit.predict(),ls='--',color='green',label='in-sample')\nax.plot(arma_mod11fit.predict('1999','2019'),ls='-.',color='red',label='out-sample')\nl,r=arma_mod11fit.forecast(20,alpha=0.8)[2][:,0],arma_mod11fit.forecast(20,alpha=0.8)[2][:,1]\nax.fill_between(pd.date_range('1999','2019',freq='a'),l,r)\nax.legend()[<matplotlib.lines.Line2D at 0x168dcd2dac8>]\n\n[<matplotlib.lines.Line2D at 0x168dcd4c1c8>]\n\n[<matplotlib.lines.Line2D at 0x168dcd4cb48>]\n\n<matplotlib.collections.PolyCollection at 0x168dcd51ec8>\n\n<matplotlib.legend.Legend at 0x168dcd51f88>help(arma_mod11fit.forecast)Help on method forecast in module statsmodels.tsa.arima_model:\n\nforecast(steps=1, exog=None, alpha=0.05) method of statsmodels.tsa.arima_model.ARMAResults instance\n    Out-of-sample forecasts\n    \n    Parameters\n    ----------\n    steps : int\n        The number of out of sample forecasts from the end of the\n        sample.\n    exog : array\n        If the model is an ARMAX, you must provide out of sample\n        values for the exogenous variables. This should not include\n        the constant.\n    alpha : float\n        The confidence intervals for the forecasts are (1 - alpha) %\n    \n    Returns\n    -------\n    forecast : array\n        Array of out of sample forecasts\n    stderr : array\n        Array of the standard error of the forecasts.\n    conf_int : array\n        2d array of the confidence interval for the forecasthelp(arma_mod11fit.predict)Help on method predict in module statsmodels.tsa.arima_model:\n\npredict(start=None, end=None, exog=None, dynamic=False) method of statsmodels.tsa.arima_model.ARMAResultsWrapper instance\n    predict(self, start=None, end=None, exog=None, dynamic=False)\n    \n    ARMA model in-sample and out-of-sample prediction\n    \n    Parameters\n    ----------\n    \n    start : int, str, or datetime\n        Zero-indexed observation number at which to start forecasting, ie.,\n        the first forecast is start. Can also be a date string to\n        parse or a datetime type.\n    end : int, str, or datetime\n        Zero-indexed observation number at which to end forecasting, ie.,\n        the first forecast is start. Can also be a date string to\n        parse or a datetime type. However, if the dates index does not\n        have a fixed frequency, end must be an integer index if you\n        want out of sample prediction.\n    exog : array-like, optional\n        If the model is an ARMAX and out-of-sample forecasting is\n        requested, exog must be given. Note that you'll need to pass\n        `k_ar` additional lags for any exogenous variables. E.g., if you\n        fit an ARMAX(2, q) model and want to predict 5 steps, you need 7\n        observations to do this.\n    dynamic : bool, optional\n        The `dynamic` keyword affects in-sample prediction. If dynamic\n        is False, then the in-sample lagged values are used for\n        prediction. If `dynamic` is True, then in-sample forecasts are\n        used in place of lagged dependent variables. The first forecasted\n        value is `start`.\n\n    Returns\n    -------\n    predict : array\n        The predicted values.\n\n    Notes\n    -----\n    It is recommended to use dates with the time-series models, as the\n    below will probably make clear. However, if ARIMA is used without\n    dates and/or `start` and `end` are given as indices, then these\n    indices are in terms of the *original*, undifferenced series. Ie.,\n    given some undifferenced observations::\n    \n     1970Q1, 1\n     1970Q2, 1.5\n     1970Q3, 1.25\n     1970Q4, 2.25\n     1971Q1, 1.2\n     1971Q2, 4.1\n    \n    1970Q1 is observation 0 in the original series. However, if we fit an\n    ARIMA(p,1,q) model then we lose this first observation through\n    differencing. Therefore, the first observation we can forecast (if\n    using exact MLE) is index 1. In the differenced series this is index\n    0, but we refer to it as 1 from the original series."},{"path":"时间序列模型.html","id":"生成相应系数的arma模型以及样本","chapter":"第11章 时间序列模型","heading":"11.2.3.7 生成相应系数的arma模型以及样本","text":"生成相应模型后，可以计算模型的自相关，偏自相关，自协方差函数等","code":"## 利用from statsmodels.tsa.arima_process import ArmaProcess\n\narpar=np.r_[1,-arma_mod11fit.arparams]#注意负号\nmaapr=np.r_[1,arma_mod11fit.maparams]\narma_t=ArmaProcess(arpar,maapr)\narma_t.generate_sample(50)#生成样本数array([ 0.84100879, -1.11466772, -1.69619658, -0.89732715, -1.24949787,\n       -0.9429691 , -0.36605419, -0.49423353,  0.17072922,  1.44030944,\n       -0.45314823, -0.0211145 ,  0.32116309, -0.07627831,  1.06153154,\n       -1.97036659,  1.44268116, -0.83143763,  0.02046505,  0.62915108,\n       -0.57072571,  0.33114286,  0.77741837,  0.86158753, -0.43930777,\n        2.04760704,  1.05056826, -0.37918406,  0.82059652,  0.44502154,\n        0.81677717, -3.08796419,  0.31299866, -0.16455348, -0.03883496,\n       -0.53423336,  0.5115214 ,  1.07455292,  0.73309407,  1.88259081,\n        1.0354387 ,  0.42521786, -0.49991477, -0.55091025,  0.61444634,\n        0.07167267, -0.24943137,  0.47172613, -0.90796036, -0.79903477])dir(arma_t)['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__mul__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'acf',\n 'acovf',\n 'ar',\n 'arcoefs',\n 'arma2ar',\n 'arma2ma',\n 'arpoly',\n 'arroots',\n 'from_coeffs',\n 'from_estimation',\n 'generate_sample',\n 'impulse_response',\n 'invertroots',\n 'isinvertible',\n 'isstationary',\n 'ma',\n 'macoefs',\n 'mapoly',\n 'maroots',\n 'nobs',\n 'pacf',\n 'periodogram']arma_t.acf(12)\narma_t.pacf(12)\narma_t.acovf(12)array([1.        , 0.53937576, 0.44802054, 0.37213835, 0.30910848,\n       0.25675412, 0.21326713, 0.17714562, 0.14714209, 0.12222032,\n       0.1015196 , 0.08432501])\n\narray([1.00000000e+00, 5.39375760e-01, 2.21548631e-01, 9.56983544e-02,\n       4.17191583e-02, 1.82189418e-02, 7.95893463e-03, 3.47707644e-03,\n       1.51907351e-03, 6.63658016e-04, 2.89941305e-04, 1.26670613e-04])\n\narray([1.50001883, 0.8090738 , 0.67203925, 0.55821453, 0.46366854,\n       0.38513601, 0.31990471, 0.26572176, 0.2207159 , 0.18333278,\n       0.15228132, 0.12648911])## 利用arma_generate_sample()\n\nsm.tsa.arma_generate_sample(arpar,maapr,50)array([ 0.29120536,  0.68119412,  0.82190127,  0.74797878,  0.98093912,\n        1.96669932,  0.25680721,  0.08654568,  1.50093088, -0.56938977,\n        0.96221975, -1.29394972, -0.77817225,  0.29972415, -0.28227105,\n       -0.32754268,  0.48817939, -1.71037106, -0.57913776, -0.10676858,\n       -0.509618  , -0.93247366, -1.18755667, -0.25181921, -2.10277464,\n       -0.60889419, -1.15709421, -1.05072217, -0.0480205 ,  0.33550013,\n        0.22174955,  0.23075989,  0.94173438,  2.31921265,  1.73878118,\n        0.20280618, -1.49651451,  1.59821857, -1.25111724,  0.9293164 ,\n        1.04055467,  0.13611643,  0.98155745, -0.34197525,  1.26426066,\n        0.01166392,  0.93966998,  1.45848901,  0.65975754,  2.96696278])#验证一下确实是模型的自相关，偏自相关\n# 生成一个平稳arma(1,0)模型\nar1=np.array([1,0.8])\nma1=np.array([1])\narma20=ArmaProcess(ar1,ma1)\narma20.acf(12)#ar（1）模型的k阶自相关应该是系数的k次方\narma20.pacf(12)#除了1阶为系数，其他皆为0\nnp.array([0.8**i for i in range(12)])\n#验证是通过的array([ 1.        , -0.8       ,  0.64      , -0.512     ,  0.4096    ,\n       -0.32768   ,  0.262144  , -0.2097152 ,  0.16777216, -0.13421773,\n        0.10737418, -0.08589935])\n\narray([ 1.00000000e+00, -8.00000000e-01, -3.45402719e-16, -6.16790569e-17,\n        4.31753398e-17, -3.25171988e-17, -1.04854397e-16,  7.70988212e-17,\n        1.23358114e-17, -4.62592927e-17, -1.38777878e-17,  1.07938350e-17])\n\narray([1.        , 0.8       , 0.64      , 0.512     , 0.4096    ,\n       0.32768   , 0.262144  , 0.2097152 , 0.16777216, 0.13421773,\n       0.10737418, 0.08589935])"},{"path":"时间序列模型.html","id":"模型定阶的简便方法","chapter":"第11章 时间序列模型","heading":"11.2.3.8 模型定阶的简便方法","text":"设置最大和最小AR、MA阶数，给与data和信息准则，信息准则可以是一个字符串或一个列表，同时可以选择是否中心化。检测后，可以利用.aic_min_order或.bic_min_order等你选择的最小准则选择最佳的模型，并且模型一定是平稳和可逆的。不满足的无值","code":"help(sm.tsa.arma_order_select_ic)Help on function arma_order_select_ic in module statsmodels.tsa.stattools:\n\narma_order_select_ic(y, max_ar=4, max_ma=2, ic='bic', trend='c', model_kw=None, fit_kw=None)\n    Returns information criteria for many ARMA models\n    \n    Parameters\n    ----------\n    y : array-like\n        Time-series data\n    max_ar : int\n        Maximum number of AR lags to use. Default 4.\n    max_ma : int\n        Maximum number of MA lags to use. Default 2.\n    ic : str, list\n        Information criteria to report. Either a single string or a list\n        of different criteria is possible.\n    trend : str\n        The trend to use when fitting the ARMA models.\n    model_kw : dict\n        Keyword arguments to be passed to the ``ARMA`` model\n    fit_kw : dict\n        Keyword arguments to be passed to ``ARMA.fit``.\n    \n    Returns\n    -------\n    obj : Results object\n        Each ic is an attribute with a DataFrame for the results. The AR order\n        used is the row index. The ma order used is the column index. The\n        minimum orders are available as ``ic_min_order``.\n    \n    Examples\n    --------\n    \n    >>> from statsmodels.tsa.arima_process import arma_generate_sample\n    >>> import statsmodels.api as sm\n    >>> import numpy as np\n    \n    >>> arparams = np.array([.75, -.25])\n    >>> maparams = np.array([.65, .35])\n    >>> arparams = np.r_[1, -arparams]\n    >>> maparam = np.r_[1, maparams]\n    >>> nobs = 250\n    >>> np.random.seed(2014)\n    >>> y = arma_generate_sample(arparams, maparams, nobs)\n    >>> res = sm.tsa.arma_order_select_ic(y, ic=['aic', 'bic'], trend='nc')\n    >>> res.aic_min_order\n    >>> res.bic_min_order\n    \n    Notes\n    -----\n    This method can be used to tentatively identify the order of an ARMA\n    process, provided that the time series is stationary and invertible. This\n    function computes the full exact MLE estimate of each model and can be,\n    therefore a little slow. An implementation using approximate estimates\n    will be provided in the future. In the meantime, consider passing\n    {method : 'css'} to fit_kw.mod_ch=sm.tsa.arma_order_select_ic(data,4,4,['aic','bic'],trend='nc')\nmod_ch{'aic':             0           1           2           3           4\n 0         NaN  799.674173  761.067479  738.361676  715.759799\n 1  666.645525  647.132300  648.738566  649.986452  651.941850\n 2  656.028374  648.842840  648.850644  650.846599  652.699837\n 3  649.748166  650.009945  652.004944         NaN  654.552222\n 4  650.228277  652.004611         NaN  651.799867  654.256041,\n 'bic':             0           1           2           3           4\n 0         NaN  804.864412  768.852838  748.742155  728.735398\n 1  671.835765  654.917660  659.119046  662.962051  667.512569\n 2  663.813734  659.223319  661.826244  666.417318  670.865676\n 3  660.128646  662.985544  667.575663         NaN  675.313181\n 4  663.203877  667.575330         NaN  672.560826  677.612119,\n 'aic_min_order': (1, 1),\n 'bic_min_order': (1, 1)}dir(mod_ch)['__class__',\n '__contains__',\n '__delattr__',\n '__delitem__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__getitem__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__iter__',\n '__le__',\n '__len__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__setitem__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'aic',\n 'aic_min_order',\n 'bic',\n 'bic_min_order',\n 'clear',\n 'copy',\n 'fromkeys',\n 'get',\n 'items',\n 'keys',\n 'pop',\n 'popitem',\n 'setdefault',\n 'update',\n 'values']mod_ch.keys()dict_keys(['aic', 'bic', 'aic_min_order', 'bic_min_order'])"},{"path":"时间序列模型.html","id":"模型总结","chapter":"第11章 时间序列模型","heading":"11.2.4 模型总结","text":"sm.tsa=tsa","code":""},{"path":"时间序列模型.html","id":"非平稳时间序列","chapter":"第11章 时间序列模型","heading":"11.2.5 非平稳时间序列","text":"cramer分解定理证明任何一个序列都可以视为同时受到确定性影响和随机性影响的作用，对于非平稳时间序列，这两方面至少有一个方面是不平稳的。","code":""},{"path":"时间序列模型.html","id":"arima-非平稳无季节效应时间序列","chapter":"第11章 时间序列模型","heading":"11.2.6 ARIMA 非平稳无季节效应时间序列","text":"当时间序列非平稳但是不存在其他诸如季节效应的随机影响时，一般只需要做差分就可以获得平稳序列。可能是一阶，二阶，并且可以证明d阶差分后一定是平稳的，但是差分阶数越高，方差越大，所以我们要选择合适的差分阶数。避免出现过差分现象其实差分就是自回归，一个差分可以写成自回归的形式，就是用自回归来提取序列中蕴含的确定性信息对蕴含固定周期的序列进行步长为周期长度的差分运算，(k步差分)通常可以可以很好的提取周期信息，这和有季节因素的非平稳序列比较有关系ARIMA（p，d，q）p，q和ARMA模型一致，d代表做几阶差分。当p=q=0，d=0时，\\(x_t=x_{t-1}+\\epsilon\\),称为随机游走模型或醉汉模型","code":"arima_mod=tsa.SARIMAX(data,order=(p,d,q))\narima_modpdq=arima_modpdq.fit(disp=-1)"},{"path":"时间序列模型.html","id":"数据是否平稳","chapter":"第11章 时间序列模型","heading":"11.2.6.1 数据是否平稳","text":"\n124 rows × 3 columns\n可以判断大致应该是做一阶差分","code":"import requests\nfrom io import BytesIO\nwpi1 = requests.get('https://www.stata-press.com/data/r12/wpi1.dta').content\ndata = pd.read_stata(BytesIO(wpi1))\ndata.index = data.tdataplt.plot(data.wpi)[<matplotlib.lines.Line2D at 0x168dd8d7848>]"},{"path":"时间序列模型.html","id":"差分并做单位根检验","chapter":"第11章 时间序列模型","heading":"11.2.6.2 差分并做单位根检验","text":"这里其实全部都没有通过0.05的检验，那我们就取0.1为标准，所以一阶差分就可","code":"def select_arima_orderd_adf(data,maxlag):\n    results=[tsa.adfuller(data.diff(i).dropna())[1] for i in range(1,maxlag+1)]\n    results=pd.DataFrame(results,index=range(1,maxlag+1),columns=['p值'])\n    results._set_axis_name('差分阶数',inplace=True)\n    return resultsselect_arima_orderd_adf(data.wpi,5)"},{"path":"时间序列模型.html","id":"构建arima模型","chapter":"第11章 时间序列模型","heading":"11.2.6.3 构建ARIMA模型","text":"根据自相关图和偏相关图，我们也可以判断是否适合用疏系数模型使用bic准则我们p=1，q=1","code":"#首先获取差分数据\ndata['d1wpi']=data['wpi'].diff()\n#绘制相关图。判断p，q\nfig=plt.figure(figsize=(10,8))\nax1=plt.subplot(211);plot_acf(data.d1wpi.dropna(),ax=ax1).show()\nax2=plt.subplot(212);plot_pacf(data.d1wpi.dropna(),ax=ax2).show()#使用模型定阶的函数\ntsa.arma_order_select_ic(data.d1wpi.dropna(),4,4,['aic','bic'],trend='c'){'aic':             0           1           2           3           4\n 0  347.072562  307.552197  299.357225  293.948300  285.064261\n 1  283.806987  278.702628  280.105905  280.726991  281.041604\n 2  281.855956  280.368858  281.696667  279.304674  280.894012\n 3  278.371786  280.281285         NaN  304.722568  279.878126\n 4  280.205568  279.706951  279.272632  280.581639  281.139270,\n 'bic':             0           1           2           3           4\n 0  352.696930  315.988750  310.605962  308.009222  301.937367\n 1  292.243540  289.951365  294.166827  297.600097  300.726894\n 2  293.104694  294.429780  298.569774  298.989965  303.391487\n 3  292.432708  297.154391         NaN  327.220043  305.187785\n 4  297.078674  299.392241  301.770106  305.891298  309.261113,\n 'aic_min_order': (3, 0),\n 'bic_min_order': (1, 1)}#构建模型\narima_mod111=tsa.SARIMAX(data['wpi'],order=(1,1,1),trend='c')\narima_mod111fit=arima_mod111.fit(disp=-1)\narima_mod111fit.summary()"},{"path":"时间序列模型.html","id":"检验-1","chapter":"第11章 时间序列模型","heading":"11.2.6.4 检验","text":"","code":""},{"path":"时间序列模型.html","id":"预测-1","chapter":"第11章 时间序列模型","heading":"11.2.6.5 预测","text":"\n124 rows × 2 columns\n","code":"arima_mod111fit.predict('1960-01-01','1991-01-01')1960-01-01      0.749786\n1960-04-01     31.449807\n1960-07-01     31.122188\n1960-10-01     30.867851\n1961-01-01     30.862600\n                 ...    \n1990-01-01    109.912121\n1990-04-01    112.044809\n1990-07-01    111.232380\n1990-10-01    113.996828\n1991-01-01    118.358861\nFreq: QS-OCT, Length: 125, dtype: float64arima_mod111fit.get_prediction()\narima_mod111fit.get_prediction().conf_int()<statsmodels.tsa.statespace.mlemodel.PredictionResultsWrapper at 0x168debe0c48>fig,ax=plt.subplots(figsize=(12,8))\nax.plot(data.wpi,'k',label='raw')\nax.plot(arima_mod111fit.predict(),'r--',label='predict')\nci=arima_mod111fit.get_prediction().conf_int().iloc[1:,]\nl,r=ci.iloc[:,0],ci.iloc[:,1]\nax.fill_between(ci.index,l,r,alpha=0.1)\nax.legend()\nplt.show()[<matplotlib.lines.Line2D at 0x168de9d5c88>]\n\n[<matplotlib.lines.Line2D at 0x168de9f0508>]\n\n<matplotlib.collections.PolyCollection at 0x168debee508>\n\n<matplotlib.legend.Legend at 0x168de9f59c8>"},{"path":"时间序列模型.html","id":"有季节效应的非平稳模型","chapter":"第11章 时间序列模型","heading":"11.2.7 有季节效应的非平稳模型","text":"直接差分，先消掉趋势。再按照周期来构建疏系数模型，季度数据，月度数据周期是一年arima加法和乘法模型x11季节调节模型指数平滑模型","code":"# Dataset\ndata = pd.read_stata(BytesIO(wpi1))\ndata.index = data.t\ndata['ln_wpi'] = np.log(data['wpi'])\ndata['D.ln_wpi'] = data['ln_wpi'].diff()#注意这里的时间之间差值是三个月，也就是季度数据，那我们在构建时只需构建滞后四期fig=plt.figure(figsize=(8,10))\nax1=plt.subplot(211);ax1.plot(data.ln_wpi)\nax2=plt.subplot(212);ax2.plot(data['D.ln_wpi'])[<matplotlib.lines.Line2D at 0x168dee1dc88>]\n\n[<matplotlib.lines.Line2D at 0x168dee32c88>]"},{"path":"时间序列模型.html","id":"第一种模型构建","chapter":"第11章 时间序列模型","heading":"11.2.7.1 第一种模型构建","text":"\n408 rows × 1 columns\n","code":"ar = 1          # this is the maximum degree specification\nma = (1,0,0,1)  # this is the lag polynomial specification\nmod = tsa.SARIMAX(data['wpi'], trend='c', order=(ar,1,ma))#这里把关于时间t的函数就设置为常数c\nmodfit=mod.fit(disp=-1)\nmodfit.summary()#应为该序列并没有季节效应，四阶滞后参数检验不通过data=pd.read_excel('./习题与案例数据/案例数据/A1_21.xlsx',index_col='time')\ndataplt.plot(data)[<matplotlib.lines.Line2D at 0x168deaa9448>]select_arima_orderd_adf(data.x,3)ar=1#就设置为1\nma=[0]*12\nma[0]=1\nma[11]=1\nmod=tsa.SARIMAX(data,order=(ar,1,ma))\nmodfit=mod.fit(disp=-1)\nmodfit.summary()"},{"path":"时间序列模型.html","id":"arima加法模型","chapter":"第11章 时间序列模型","heading":"11.2.7.2 ARIMA加法模型","text":"加法模型其实就是先获得平稳的模型，将不稳定因素减去，对剩下的因素构建适当的ARMA模型\n120 rows × 1 columns\n结合自相关图和偏自相关图，可以看到除了一阶和四阶，其他的都在两倍标准差内。所以可以尝试拟合疏系数模型，并且根据拖尾和截尾性质，使用ar模型.加法模型\\(ARIMA((1,4),(1,4),0)\\)=\\(ARIMA(1,1,0)\\times(0,1,0)_4\\)季节的加法模型和上面一个模型相比就是多了一个季节参数，也就是一个季节的k步差分模型检验都是通过的略","code":"#导入数据\ndata=pd.read_excel('./习题与案例数据/案例数据/A1_20.xlsx',index_col='time')\ndataplt.plot(data)[<matplotlib.lines.Line2D at 0x168de935808>]#做一阶差分和4步差分，得到数据,因为这是季度数据\ndx=data['x'].diff().dropna()\ndx12=pd.Series([n-dx[::-1][i+4] for i,n in enumerate(dx[::-1]) if i+4<len(dx)])#检验平稳性和随机性\ntsa.adfuller(dx12)\nr,q,p=tsa.acf(dx12,fft=True,qstat=True)\nnp.c_[r[1:],q,p](-6.15621309726213,\n 7.357953744299023e-08,\n 3,\n 111,\n {'1%': -3.490683082754047,\n  '5%': -2.8879516565798817,\n  '10%': -2.5808574442009578},\n 57.66176611874175)\n\narray([[ 4.22066251e-01,  2.10251984e+01,  4.53282432e-06],\n       [ 1.88976812e-01,  2.52774828e+01,  3.24387684e-06],\n       [ 7.24845218e-02,  2.59086671e+01,  9.96671089e-06],\n       [-2.38843592e-01,  3.28235991e+01,  1.29804479e-06],\n       [-2.38793298e-01,  3.97984557e+01,  1.63984012e-07],\n       [-1.80874879e-01,  4.38368964e+01,  7.96352503e-08],\n       [-1.94932404e-01,  4.85708939e+01,  2.75329616e-08],\n       [-8.88521849e-02,  4.95636354e+01,  4.95665651e-08],\n       [-5.97374814e-02,  5.00166077e+01,  1.06952006e-07],\n       [ 2.17768244e-02,  5.00773769e+01,  2.58303768e-07],\n       [ 2.17725542e-02,  5.01387063e+01,  5.91003399e-07],\n       [-1.09621764e-01,  5.17084909e+01,  6.98214396e-07],\n       [-2.03836243e-02,  5.17632992e+01,  1.48118422e-06],\n       [-2.72508298e-02,  5.18622277e+01,  2.96709626e-06],\n       [-1.20310925e-01,  5.38098011e+01,  2.82621187e-06],\n       [ 1.71314533e-02,  5.38496887e+01,  5.48699630e-06],\n       [ 5.63344292e-02,  5.42854066e+01,  8.91900867e-06],\n       [-3.70409246e-02,  5.44757227e+01,  1.54678157e-05],\n       [ 3.34272080e-02,  5.46323302e+01,  2.64565501e-05],\n       [-5.67773727e-02,  5.50889037e+01,  3.98239366e-05],\n       [-4.87304255e-02,  5.54288077e+01,  6.12018160e-05],\n       [-7.49039463e-03,  5.54369250e+01,  1.02921942e-04],\n       [-1.15397953e-01,  5.73844905e+01,  9.04122266e-05],\n       [-1.17972793e-01,  5.94423041e+01,  7.65404775e-05],\n       [-4.28970359e-02,  5.97174074e+01,  1.14349898e-04],\n       [-6.39266238e-02,  6.03352207e+01,  1.51143632e-04],\n       [ 5.67403641e-02,  6.08274702e+01,  2.05279762e-04],\n       [ 1.22109796e-01,  6.31335029e+01,  1.59611818e-04],\n       [ 8.42926928e-02,  6.42451453e+01,  1.77948161e-04],\n       [ 1.39901237e-01,  6.73433341e+01,  1.09119067e-04],\n       [ 2.38312186e-01,  7.64403073e+01,  1.03975215e-05],\n       [ 2.14123950e-01,  8.38728276e+01,  1.56253569e-06],\n       [ 1.36469084e-01,  8.69287224e+01,  9.62407575e-07],\n       [ 7.75446317e-03,  8.69387110e+01,  1.59550939e-06],\n       [-1.75615070e-01,  9.21257233e+01,  4.93164324e-07],\n       [-1.93746705e-01,  9.85190259e+01,  1.01272609e-07],\n       [-2.27914085e-01,  1.07479509e+02,  8.53842148e-09],\n       [-9.94686998e-02,  1.09208393e+02,  8.27441070e-09],\n       [ 1.02066788e-02,  1.09226836e+02,  1.42176837e-08],\n       [-1.57033533e-02,  1.09271076e+02,  2.39135167e-08]])#检验通过，在绘制自相关图加上order选择，判断最终定阶\nplot_acf(dx12).show()\nplot_pacf(dx12).show()\ntsa.arma_order_select_ic(dx12,3,3,ic='bic'){'bic':            0          1          2          3\n 0  96.453316  80.919882  84.974043  80.342909\n 1  78.398369  83.123195  87.789872  84.874616\n 2  83.121046  87.865584  80.724535  83.286027\n 3  87.847277  81.027281  85.840942  92.948794, 'bic_min_order': (1, 0)}ar=[1,0,0,1]\nmod=tsa.SARIMAX(data,order=(ar,1,0),seasonal_order=(0,1,0,4))\nmodfit=mod.fit(disp=-1)\nmodfit.summary()modfit.predict(0,120)1962-01-01    0.000000\n1962-04-01    1.100000\n1962-07-01    0.500000\n1962-10-01    0.400000\n1963-01-01    1.250000\n                ...   \n1991-01-01    6.949265\n1991-04-01    5.612139\n1991-07-01    5.916173\n1991-10-01    6.186753\n1992-01-01    6.615064\nFreq: QS-OCT, Length: 121, dtype: float64ax=plt.subplot(111)\nax.plot(data['x'])\nax.plot(modfit.predict(0,120))[<matplotlib.lines.Line2D at 0x168dc191608>]\n\n[<matplotlib.lines.Line2D at 0x168de924208>]"},{"path":"时间序列模型.html","id":"arima乘法模型","chapter":"第11章 时间序列模型","heading":"11.2.7.3 ARIMA乘法模型","text":"\n408 rows × 1 columns\n可以看到残差序列都是相关的，单纯的加法模型并不适合。再次回到之前的自相关图，因为均不截尾，所以构建ARMA(1,1)模型在考虑季节自相关特征，考虑季节效应周期（这里是一年，12阶延迟）倍数的相关系数，也就是12,24等可以看到自相关系数延迟12阶显著非0，但是延迟24阶落入两倍标准差内。而偏相关系数延迟12阶和24阶都显著非0，认为自相关1阶截尾，偏自相关拖尾，所以是\\(ARIMA(1,1,1)\\times(0,1,1)_{12}\\)显著性检验通过，系数检验也通过","code":"data=pd.read_excel('./习题与案例数据/案例数据/A1_21.xlsx',index_col='time')\nplt.plot(data)\ndata[<matplotlib.lines.Line2D at 0x168dba2ca88>]#先将趋势项和季节效应提取，检验序列是否是平稳非白噪声序列\n#刚刚做一阶差分后已经提取了趋势效应\n#再做12步差分，提取季节效应\ndx=data['x'].diff().dropna()\ndx12=pd.Series([n-dx[::-1][i+12] for i,n in enumerate(dx[::-1]) if i+12<len(dx)])#然后再确定是否是白噪声序列\nr,q,p=tsa.acf(data['x'].diff().dropna(),fft=True,qstat=True,nlags=12)\nnp.c_[r[1:],q,p]array([[-1.85749784e-01,  1.41464777e+01,  1.69113428e-04],\n       [ 2.98935223e-03,  1.41501507e+01,  8.45928814e-04],\n       [-2.60302718e-01,  4.20687586e+01,  3.87956739e-09],\n       [-7.06041807e-02,  4.41278399e+01,  6.03523844e-09],\n       [ 2.35100467e-01,  6.70153553e+01,  4.27733608e-13],\n       [-1.54958260e-02,  6.71150341e+01,  1.59431485e-12],\n       [ 2.03394043e-01,  8.43311106e+01,  1.79654981e-15],\n       [-8.43815734e-02,  8.73016825e+01,  1.63938501e-15],\n       [-2.42222914e-01,  1.11841148e+02,  6.20008961e-20],\n       [-7.56589124e-02,  1.14241348e+02,  7.42517345e-20],\n       [-1.13345720e-01,  1.19641833e+02,  2.14011551e-20],\n       [ 6.13800469e-01,  2.78414249e+02,  1.57763769e-52]])#可以判断不是白噪声，为模型定阶\n\ntsa.arma_order_select_ic(dx12,3,3,'bic')\nplot_acf(dx12).show()\nplot_pacf(dx12).show(){'bic':              0            1            2            3\n 0  4860.959171  4861.392903  4852.740094  4858.431293\n 1  4859.319573  4859.251978  4857.639464  4863.045988\n 2  4853.259759  4856.594373  4862.554521  4868.222488\n 3  4857.194729  4862.560040  4856.715196  4860.269284,\n 'bic_min_order': (0, 2)}# 模型尝试\nar=[0]*12\nar[0]=1\nar[-1]=1\nma=[0]*12\nma[0]=1\nma[1]=1\nma[-1]=1\n## AR(1,12)\nr,q,p=tsa.acf(tsa.SARIMAX(data,order=(ar,1,0),seasonal_order=(0,1,0,12)).fit(disp=-1).resid,fft=True,qstat=True,nlags=12)\nnp.c_[r[1:],q,p]\n##MA(1,2,12)\nr,q,p=tsa.acf(tsa.SARIMAX(data,order=(0,1,ma),seasonal_order=(0,1,0,12)).fit(disp=-1).resid,fft=True,qstat=True,nlags=12)\nnp.c_[r[1:],q,p]\n##ARMA((1,12),(1,12))\nr,q,p=tsa.acf(tsa.SARIMAX(data,order=(ar,1,ar),seasonal_order=(0,1,0,12)).fit(disp=-1).resid,fft=True,qstat=True,nlags=12)\nnp.c_[r[1:],q,p]array([[ 2.62090931e-04,  2.82327771e-05,  9.95760498e-01],\n       [ 1.59764475e-01,  1.05167024e+01,  5.20387781e-03],\n       [ 6.39902758e-04,  1.05168715e+01,  1.46468835e-02],\n       [ 6.61403669e-02,  1.23281943e+01,  1.50705147e-02],\n       [ 2.91205772e-02,  1.26801913e+01,  2.65673310e-02],\n       [ 5.60074868e-02,  1.39854907e+01,  2.97986615e-02],\n       [-7.44858289e-02,  1.62999362e+01,  2.25130010e-02],\n       [ 4.75763942e-02,  1.72465374e+01,  2.76418710e-02],\n       [ 1.67598772e-03,  1.72477151e+01,  4.49751787e-02],\n       [-8.53212637e-02,  2.03073916e+01,  2.64757342e-02],\n       [ 4.68050874e-02,  2.12304722e+01,  3.10604125e-02],\n       [-1.90425816e-01,  3.65484165e+01,  2.64346585e-04]])\n\narray([[-4.38793784e-03,  7.91353530e-03,  9.29115246e-01],\n       [ 1.08908145e-01,  4.89487265e+00,  8.65150990e-02],\n       [-5.37913540e-02,  6.08999935e+00,  1.07312723e-01],\n       [ 4.17548207e-02,  6.81189745e+00,  1.46168807e-01],\n       [ 4.29923830e-02,  7.57912115e+00,  1.81007414e-01],\n       [ 6.39358198e-02,  9.28012949e+00,  1.58425867e-01],\n       [-6.26090674e-02,  1.09153417e+01,  1.42354643e-01],\n       [ 2.17990649e-02,  1.11140700e+01,  1.95319236e-01],\n       [-4.07478530e-02,  1.18101844e+01,  2.24222982e-01],\n       [-5.96051715e-02,  1.33034217e+01,  2.07198464e-01],\n       [ 1.16491739e-02,  1.33606016e+01,  2.70411346e-01],\n       [-5.09339524e-02,  1.44564831e+01,  2.72512353e-01]])\n\narray([[ 3.15982571e-01,  4.10370250e+01,  1.49372521e-10],\n       [-5.88083875e-02,  4.24619648e+01,  6.01868337e-10],\n       [-1.74572953e-01,  5.50495642e+01,  6.70101585e-12],\n       [-8.21849192e-02,  5.78462709e+01,  8.21956756e-12],\n       [ 1.09130349e-01,  6.27897199e+01,  3.21823058e-12],\n       [ 1.49917833e-01,  7.21421520e+01,  1.48554920e-13],\n       [ 1.77317263e-02,  7.22733120e+01,  5.12360612e-13],\n       [-9.50309310e-02,  7.60500252e+01,  3.03874327e-13],\n       [-1.88881390e-01,  9.10071964e+01,  1.02210118e-15],\n       [-1.51868051e-01,  1.00700990e+02,  3.94492110e-17],\n       [ 3.62650860e-01,  1.56116450e+02,  8.36001979e-28],\n       [ 3.64378402e-01,  2.12202401e+02,  9.79513166e-39]])plot_acf(dx12,lags=[i for i in range(12,48,12)]).show()\nplot_pacf(dx12,lags=[i for i in range(12,48,12)]).show()#模型构建\nmod=tsa.SARIMAX(data,order=(1,1,1),seasonal_order=(0,1,1,12)).fit(disp=-1)\nmod.summary()# 模型显著性检验\nr,q,p=tsa.acf(mod.resid,fft=True,qstat=True,nlags=12)\nnp.c_[r[1:],q,p]array([[ 4.21220154e-02,  7.29235657e-01,  3.93131054e-01],\n       [ 3.45447505e-02,  1.22091516e+00,  5.43102298e-01],\n       [ 5.26569785e-03,  1.23236768e+00,  7.45252129e-01],\n       [-5.54856194e-03,  1.24511513e+00,  8.70616308e-01],\n       [ 8.40985550e-02,  4.18084466e+00,  5.23683554e-01],\n       [ 4.87304329e-02,  5.16898472e+00,  5.22329615e-01],\n       [-4.78427525e-02,  6.12382771e+00,  5.25367445e-01],\n       [ 1.45962355e-02,  6.21292525e+00,  6.23394560e-01],\n       [-3.75830490e-02,  6.80510717e+00,  6.57402303e-01],\n       [-6.54153133e-02,  8.60364592e+00,  5.70085780e-01],\n       [ 2.80827570e-02,  8.93594796e+00,  6.27804691e-01],\n       [-4.38198976e-02,  9.74707998e+00,  6.38138285e-01]])fig,axes=plt.subplots(figsize=(12,4))\naxes.plot(data,label='raw')\naxes.plot(mod.predict(0,480),label='predict')\nplt.legend()[<matplotlib.lines.Line2D at 0x168deed5f08>]\n\n[<matplotlib.lines.Line2D at 0x168deeb15c8>]\n\n<matplotlib.legend.Legend at 0x168db920f88>"},{"path":"时间序列模型.html","id":"季节调整模型","chapter":"第11章 时间序列模型","heading":"11.2.7.4 季节调整模型","text":"","code":"data=pd.read_excel('./习题与案例数据/案例数据/A1_17.xlsx',index_col='time')\n#tsa.x13_arima_select_order(data,maxorder=(2,2),maxdiff=(2,1))# x12a and x13as not found on path. Give the path, put them on PATH, or set the X12PATH or X13PATH environmental variable."},{"path":"时间序列模型.html","id":"指数平滑模型","chapter":"第11章 时间序列模型","heading":"11.2.7.5 指数平滑模型","text":"Holt线性趋势模型Holt 在1957年把简单的指数平滑模型进行了延伸，能够预测包含趋势的数据，该方法包含一个预测方程和两个平滑方程（一个用于水平，另一个用于趋势）\\[\\begin{align*}\n\\text{Forecast equation}&& \\hat{y}_{t+h|t} &= \\ell_{t} + hb_{t} \\\\\n\\text{Level equation}&& \\ell_{t} &= \\alpha y_{t} + (1 - \\alpha)(\\ell_{t-1} + b_{t-1})\\\\\n\\text{Trend equation}&& b_{t} &= \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 -\\beta^*)b_{t-1}\n\\end{align*}\\]其中 ltlt代表时刻t的预估水平， btbt代表时刻t的预测趋势（或坡度）， αα是水平的平滑参数， β∗β∗是趋势的平滑参数。\n这时候，预测函数不再是平的，而是具有趋势的。指数趋势模型另外一种Holt 线性模型的变体是指数趋势模型，这时水平和趋势不是相加的，而是相乘\\[\\begin{align*}\n\\hat {y}_{t+h|t} &= \\ell_{t} b_{t}^h\\\\ \\ell_{t} &= \\alpha\ny_{t} + (1 - \\alpha)(\\ell_{t-1} b_{t-1})\\\\ b_{t} &=\n\\beta^*\\frac{\\ell_{t}}{ \\ell_{t-1}} + (1 -\\beta^*)b_{t-1}\n\\end{align*}\\]其中 btbt代表预估的增长率（以相对的形式而不是绝对的形式）。这时候的趋势不是线性的，而是指数的。阻尼趋势模型经验表明，Holt的线性模型和指数模型倾向于对未来预测值过高，特别是对于长期预测。Gardner 和 McKenzie (1985)引入了一种阻尼效应，倾向于在未来保持一个水平的线。包含阻尼的趋势被证明是一种非常有效的预测方法。除了Holt的方法中的α和\\(\\beta^*\\)，该方法还包含阻尼参数0<ϕ<1:\\[\\begin{align*}\n\\hat {y}_{t+h|t} &= \\ell_{t} + (\\phi+\\phi^2 + \\dots + \\phi^{h}) b_{t} \\\\\n\\ell_{t} &= \\alpha y_{t} + (1 - \\alpha)(\\ell_{t-1} + \\phi b_{t-1})\\\\\nb_{t}  &= \\beta^*(\\ell_{t} - \\ell_{t-1}) + (1 -\\beta^*)\\phi b_{t-1}.\n\\end{align*}\\]如果 ϕ=1，这种方法与Holt的线性模型相同。对于在0到1的值， ϕ对趋势产生阻尼效应。实际上， 当 h→∞时对于任何的 0<ϕ<1预测值收敛于 lT+ϕbT/(1−ϕ)。\n误差校正形式是：\\[\\begin{align*}\n\\ell_{t} &= \\ell_{t-1} + \\phi b_{t-1} + \\alpha e_{t} \\\\\nb_{t} &= \\phi b_{t-1}+ \\alpha \\beta^*e_{t}.\n\\end{align*}\\]乘法阻尼趋势Taylor(2003)引入了一种阻尼参数，建立了乘法阻尼趋势模型：\\[\\begin{align*} \\hat {y}_{t+h|t} &=\n\\ell_{t}b_{t}^{(\\phi+\\phi^2 + \\dots + \\phi^{h})} \\\\\n\\ell_{t} &= \\alpha y_{t} + (1 - \\alpha)\\ell_{t-1}\nb^\\phi_{t-1}\\\\ b_{t} &= \\beta^*\\frac{\\ell_{t}}{\n\\ell_{t-1}} + (1 -\\beta^*)b_{t-1}^{\\phi}.\n\\end{align*}\\]这种方法的预测结果不像加法阻尼那么保守，误差校正形式是：\\[\\begin{align*}\n\\ell_{t} &= \\ell_{t-1} b^\\phi_{t-1}+\\alpha e_{t}\\\\ b_{t} &=\nb^\\phi_{t-1}+ \\alpha \\beta^*\\frac{e_{t}}{\\ell_{t-1}}.\n\\end{align*}\\]holt三参数模型三次指数平滑在二次指数平滑的基础上保留了季节性的信息，使得其可以预测带有季节性的时间序列。三次指数平滑添加了一个新的参数p来表示平滑后的趋势。三次指数平滑有累加和累乘两种方法。季节加法模型：\\(a_0截距，b为斜率,\\epsilon_t随机波动,服从N(0,\\sigma^2)分布,c_t为t时刻有时间效应造成的序列偏差\\)\\[x_t=a_0+bt+c_t+\\epsilon_t\\]假设每个季节的周期长度为m期，每一期的季节指数为\\(S_1,S_2,\\dots,S_m\\),不放假设t时刻为季节周期的第j期,则\\(c_t\\)可以表示为:\\(c_t=S_j+e_t e_t \\sim N(0,\\sigma^2_e)\\),则模型可以写成如下递推公式:\\[x_t=a_0+b(t-1)+b+c_t+\\epsilon_t=(x_{t-1}-c_{t-1}-\\epsilon_{t-1})+b+\\epsilon_t+(S_j+e_t)\\]不妨记：\\((t-1)=x_{t-1}-c_{t-1}-\\epsilon_{t-1}\\)\\(b(t)=b+\\epsilon_t\\)\\(c(t)=S_j+e_t\\)显然，\\((t-1)\\)是t-1时刻消除季节效应的序列截距项的无偏估计值，\\(b(t)\\)是t时刻斜率b的无偏估计值,c(t)是t时刻季节指数S_j的无偏估计值.则：\\(x_t=(t-1)+b(t)+c(t)\\)Holt-Winters三参数指数模型就是分别使用指数平滑的方法，迭代递推参数\\(\\hat{}(t),\\hat{b}(t)和\\hat{c}_t\\)的值，递推公式如下:\\(\\hat{}(t)=\\alpha[x_t-c(t-m)]+(1-\\alpha)[\\hat()(t-1)+\\hat(b)(t-1)]\\)\\(\\hat{b}(t)=\\beta[\\hat{}(t)-\\hat{}(t-1)]+(1-\\beta)\\hat{b}(t-1)\\)\\(\\hat{c}(t)=\\gamma[x_t-\\hat{}(t)]+(1-\\gamma)c(t-m)\\)式中，\\(x_t\\)为序列在t时刻得到的最新观察值；m是季节效应的周期长度；\\(\\alpha,\\beta,\\gamma\\)均为平滑系数,满足\\(0<\\alpha,\\beta,\\gamma<1\\)使用holt-Winters三参数指数平滑加法公式，向前k期的预测值为:\\(\\hat{x}_{t+k}=\\hat{}(t)+\\hat{b}(t)k+\\hat{c}(t+k),\\forall k \\geq 1\\)假设t+k期为季节周期的第j期,则\\(\\hat{c}(t+k)=\\hat{S}_k(j=1,2,3,\\dots,m)\\)季节乘法模型对于乘法模型，序列通常可以表达为如下模型结构:\\(x_t=(a_0+bt+\\epsilon_t)c_t\\)式中，\\(a_0\\)为截距；b为斜率.\\(\\epsilon_t\\)为随机波动且\\(\\epsilon_t\\sim N(0,sigma^2)\\);c_t为t时刻的季节效应；假设每个季节的周期长度为m期，每一期的季节指数为\\(S_1,S_2,\\dots,S_m\\),不放假设t时刻为季节周期的第j期,则\\(c_t\\)可以表示为:\\(c_t=S_j+e_t e_t \\sim N(0,\\sigma^2_e)\\),则模型可以写成如下递推公式:\\[x_t=[a_0+b(t-1)+b+\\epsilon_t]c_t=[(x_{t-1}/c_{t-1}-\\epsilon_{t-1})+b+\\epsilon_t](S_j+e_t)\\]不妨记：\\((t-1)=x_{t-1}/c_{t-1}-\\epsilon_{t-1}\\)\\(b(t)=b+\\epsilon_t\\)\\(c(t)=S_j+e_t\\)显然，(t-1)是t-1时刻消除季节效应的序列截距的无偏估计值，b(t)是t时刻序列斜率b的无偏估计值，c（t）是t时刻序列季节指数\\(S_j\\)的无偏估计值则模型可以表示为：\\[x_t=[(t-1)+b(t)]c(t)\\]式中三个参数的地推公式是:\\(\\hat{}(t)=\\alpha[x_t/c(t-m)]+(1-\\alpha)[\\hat()(t-1)+\\hat(b)(t-1)]\\)\\(\\hat{b}(t)=\\beta[\\hat{}(t)-\\hat{}(t-1)]+(1-\\beta)\\hat{b}(t-1)\\)\\(\\hat{c}(t)=\\gamma[x_t/\\hat{}(t)]+(1-\\gamma)c(t-m)\\)式中，\\(x_t\\)为序列在t时刻得到的最新观察值；m是季节效应的周期长度；\\(\\alpha,\\beta,\\gamma\\)均为平滑系数,满足\\(0<\\alpha,\\beta,\\gamma<1\\)使用holt-Winters三参数指数平滑加法公式，向前k期的预测值为:\\(\\hat{x}_{t+k}=[\\hat{}(t)+\\hat{b}(t)k]\\hat{c}(t+k),\\forall k \\geq 1\\)假设t+k期为季节周期的第j期,则\\(\\hat{c}(t+k)=\\hat{S}_k(j=1,2,3,\\dots,m)\\)","code":""},{"path":"时间序列模型.html","id":"简单指数平滑模型","chapter":"第11章 时间序列模型","heading":"11.2.7.6 简单指数平滑模型","text":"模型没有长期趋势和季节效应","code":"#Here we run three variants of simple exponential smoothing:\n\n#In fit1 we do not use the auto optimization but instead choose to explicitly provide the model with the  α=0.2  parameter\n#In fit2 as above we choose an  α=0.6 \n#In fit3 we allow statsmodels to automatically find an optimized  α  value for us. This is the recommended approach.\n\ndata=pd.read_excel('./习题与案例数据/案例数据/A1_18.xlsx')\ndata.index=pd.date_range('1949','1999',freq='a')\ndata.index\ndel data['year']\ndataDatetimeIndex(['1949-12-31', '1950-12-31', '1951-12-31', '1952-12-31',\n               '1953-12-31', '1954-12-31', '1955-12-31', '1956-12-31',\n               '1957-12-31', '1958-12-31', '1959-12-31', '1960-12-31',\n               '1961-12-31', '1962-12-31', '1963-12-31', '1964-12-31',\n               '1965-12-31', '1966-12-31', '1967-12-31', '1968-12-31',\n               '1969-12-31', '1970-12-31', '1971-12-31', '1972-12-31',\n               '1973-12-31', '1974-12-31', '1975-12-31', '1976-12-31',\n               '1977-12-31', '1978-12-31', '1979-12-31', '1980-12-31',\n               '1981-12-31', '1982-12-31', '1983-12-31', '1984-12-31',\n               '1985-12-31', '1986-12-31', '1987-12-31', '1988-12-31',\n               '1989-12-31', '1990-12-31', '1991-12-31', '1992-12-31',\n               '1993-12-31', '1994-12-31', '1995-12-31', '1996-12-31',\n               '1997-12-31', '1998-12-31'],\n              dtype='datetime64[ns]', freq='A-DEC')fit1 = tsa.SimpleExpSmoothing(data).fit(smoothing_level=0.2,optimized=False)\nfcast1 = fit1.predict(0,50)\nfit2 = tsa.SimpleExpSmoothing(data).fit(smoothing_level=0.6,optimized=False)\nfcast2 = fit2.predict(0,50)\nfit3 = tsa.SimpleExpSmoothing(data).fit()\nfcast3 = fit3.predict(0,50)\n\nfig,ax=plt.subplots(figsize=(12,8))\nax.plot(data,marker='o', color='black')\nax.plot(fcast1,marker='o',  color='blue', label=r'$\\alpha=0.2$')\nax.plot(fcast2,marker='o',  color='red', label=r'$\\alpha=0.6$')\nax.plot(fcast3,marker='o',  color='green', label=r'$\\alpha=%s$'%fit3.model.params['smoothing_level'])\nax.legend()\nplt.show()[<matplotlib.lines.Line2D at 0x168dbff8308>]\n\n[<matplotlib.lines.Line2D at 0x168dbfdf188>]\n\n[<matplotlib.lines.Line2D at 0x168dbfce788>]\n\n[<matplotlib.lines.Line2D at 0x168dbfdf488>]\n\n<matplotlib.legend.Legend at 0x168dbfce808>"},{"path":"时间序列模型.html","id":"指数平滑-holt两参数","chapter":"第11章 时间序列模型","heading":"11.2.7.7 指数平滑-holt两参数","text":"对于含有线性趋势的序列进行预测\n71 rows × 1 columns\nSeasonally adjusted dataLets look seasonally adjusted livestock data. fit five Holt’s models. table allows us compare results use exponential versus additive damped versus non-damped.Note: fit4 allow parameter ϕ optimized providing fixed value ϕ=0.98Plots Seasonally Adjusted Data\nfollowing plots allow us evaluate level slope/trend components table’s fits.Comparison¶plot comparison Simple Exponential Smoothing Holt’s Methods various additive, exponential damped combinations. models parameters optimized statsmodels.","code":"data=pd.read_excel('./习题与案例数据/案例数据/A1_19.xlsx')\ndata.index=pd.date_range('1898','1969',freq='a')\ndel data['year']\ndataplt.plot(data)[<matplotlib.lines.Line2D at 0x168dcfc6d08>]Holt's Method\nLets take a look at another example. This time we use air pollution data and the Holt's Method. We will fit three examples again.\n\nIn fit1 we again choose not to use the optimizer and provide explicit values for  α=0.8  and  β=0.2 \nIn fit2 we do the same as in fit1 but choose to use an exponential model rather than a Holt's additive model.\nIn fit3 we used a damped versions of the Holt's additive model but allow the dampening parameter  ϕ  to be optimized while fixing the values for  α=0.8  and  β=0.2fit1 = tsa.Holt(data).fit(smoothing_level=0.8, smoothing_slope=0.2, optimized=False)\nfcast1 = fit1.forecast(5)\nfit2 = tsa.Holt(data, exponential=True).fit(smoothing_level=0.8, smoothing_slope=0.2, optimized=False)\nfcast2 = fit2.forecast(5)\nfit3 = tsa.Holt(data, damped=True).fit(smoothing_level=0.8, smoothing_slope=0.2)\nfcast3 = fit3.forecast(5)\n\nfig,ax=plt.subplots(figsize=(12,8))\nax.plot(data,color=\"black\", marker=\"o\")\nax.plot(fit1.fittedvalues, color='blue')\nax.plot(fcast1, color='blue', marker=\"o\")\nax.plot(fit2.fittedvalues,color='red')\nax.plot(fcast2, color='red', marker=\"o\")\nax.plot(fit3.fittedvalues, color='green')\nax.plot(fcast3, color='green', marker=\"o\")\nplt.show()[<matplotlib.lines.Line2D at 0x168dc001d48>]\n\n[<matplotlib.lines.Line2D at 0x168dd00a088>]\n\n[<matplotlib.lines.Line2D at 0x168dd00a288>]\n\n[<matplotlib.lines.Line2D at 0x168dd011088>]\n\n[<matplotlib.lines.Line2D at 0x168dd00aa48>]\n\n[<matplotlib.lines.Line2D at 0x168dd011b48>]\n\n[<matplotlib.lines.Line2D at 0x168dd011d88>]data = [263.9177,  268.3072,  260.6626,  266.6394,  277.5158,  283.834 , 290.309 ,  292.4742,  300.8307,  309.2867,  318.3311,  329.3724, 338.884 ,  339.2441,  328.6006,  314.2554,  314.4597,  321.4138, 329.7893,  346.3852,  352.2979,  348.3705,  417.5629,  417.1236, 417.7495,  412.2339,  411.9468,  394.6971,  401.4993,  408.2705, 414.2428]\nindex= pd.date_range(start='1970', end='2001', freq='A')\nlivestock2 = pd.Series(data, index)\ndata = [407.9979 ,  403.4608,  413.8249,  428.105 ,  445.3387,  452.9942, 455.7402]\nindex= pd.date_range(start='2001', end='2008', freq='A')\nlivestock3 = pd.Series(data, index)\nfit1 = tsa.SimpleExpSmoothing(livestock2).fit()\nfit2 = tsa.Holt(livestock2).fit()\nfit3 = tsa.Holt(livestock2,exponential=True).fit()\nfit4 = tsa.Holt(livestock2,damped=True).fit(damping_slope=0.98)\nfit5 = tsa.Holt(livestock2,exponential=True,damped=True).fit()\nparams = ['smoothing_level', 'smoothing_slope', 'damping_slope', 'initial_level', 'initial_slope']\nresults=pd.DataFrame(np.zeros((6,5)),index=[r\"$\\alpha$\",r\"$\\beta$\",r\"$\\phi$\",r\"$l_0$\",\"$b_0$\",\"SSE\"] ,columns=['SES', \"Holt's\",\"Exponential\", \"Additive\", \"Multiplicative\"])\nresults[\"SES\"] =            [fit1.params[p] for p in params] + [fit1.sse]\nresults[\"Holt's\"] =         [fit2.params[p] for p in params] + [fit2.sse]\nresults[\"Exponential\"] =    [fit3.params[p] for p in params] + [fit3.sse]\nresults[\"Additive\"] =       [fit4.params[p] for p in params] + [fit4.sse]\nresults[\"Multiplicative\"] = [fit5.params[p] for p in params] + [fit5.sse]\nresultsfor fit in [fit2,fit4]:\n    plt.plot(pd.DataFrame(np.c_[fit.level,fit.slope]).rename(columns={0:'level',1:'slope'}))\n    plt.show()\nprint('Figure 7.4: Level and slope components for Holt’s linear trend method and the additive damped trend method.')[<matplotlib.lines.Line2D at 0x168dec4d308>,\n <matplotlib.lines.Line2D at 0x168dec4d4c8>][<matplotlib.lines.Line2D at 0x168deca9908>,\n <matplotlib.lines.Line2D at 0x168deca9ac8>]Figure 7.4: Level and slope components for Holt’s linear trend method and the additive damped trend method.fit1 = tsa.SimpleExpSmoothing(livestock2).fit()\nfcast1 = fit1.forecast(9)\nfit2 = tsa.Holt(livestock2).fit()\nfcast2 = fit2.forecast(9)\nfit3 = tsa.Holt(livestock2, exponential=True).fit()\nfcast3 = fit3.forecast(9)\nfit4 = tsa.Holt(livestock2, damped=True).fit(damping_slope=0.98)\nfcast4 = fit4.forecast(9)\nfit5 = tsa.Holt(livestock2, exponential=True, damped=True).fit()\nfcast5 = fit5.forecast(9)\nfig,ax=plt.subplots(figsize=(12,8))\nax .plot(livestock2,color=\"black\", marker=\"o\")\nax.plot(livestock3 ,color=\"black\", marker=\"o\")\nax.plot(fcast1, color='red',label='SES')\nax.plot(fcast2, color='green',label=\"holt's\")\nax.plot( fcast3,color='blue',label=\"Exponential\")\nax.plot( fcast4,color='cyan',label=\"Additive Damped\")\nax.plot( fcast5,color='magenta',label='Multiplicated Damped')\nax.set_ylabel('Livestock, sheep in Asia (millions)')\nplt.legend()\nplt.show()\nprint('Figure 7.5: Forecasting livestock, sheep in Asia: comparing forecasting performance of non-seasonal methods.')[<matplotlib.lines.Line2D at 0x168e1383948>]\n\n[<matplotlib.lines.Line2D at 0x168e13a88c8>]\n\n[<matplotlib.lines.Line2D at 0x168e13afc08>]\n\n[<matplotlib.lines.Line2D at 0x168e13afbc8>]\n\n[<matplotlib.lines.Line2D at 0x168e13b2408>]\n\n[<matplotlib.lines.Line2D at 0x168e13b2b48>]\n\n[<matplotlib.lines.Line2D at 0x168e13b2308>]\n\nText(0, 0.5, 'Livestock, sheep in Asia (millions)')\n\n<matplotlib.legend.Legend at 0x168e13b77c8>Figure 7.5: Forecasting livestock, sheep in Asia: comparing forecasting performance of non-seasonal methods."},{"path":"时间序列模型.html","id":"holt-winters三参数季节加法和乘法模型","chapter":"第11章 时间序列模型","heading":"11.2.7.8 holt-winters三参数季节加法和乘法模型","text":"tsa.ExponentialSmoothing(data,seasonal_periods,trend='add'或'mul',seasonal='add'或'mut')#seasonal选项决定了加法还是乘法模型The Internals\npossible get internals Exponential Smoothing models.show tables allow view side side original values \\(y_t\\) , level \\(l_t\\) , trend \\(b_t\\) , season \\(s_t\\) fitted values \\(\\hat{y}_t\\) .Finally lets look levels, slopes/trends seasonal components models.","code":"data = [41.7275,  24.0418,  32.3281,  37.3287,  46.2132,  29.3463, 36.4829,  42.9777,  48.9015,  31.1802,  37.7179,  40.4202, 51.2069,  31.8872,  40.9783,  43.7725,  55.5586,  33.8509, 42.0764,  45.6423,  59.7668,  35.1919,  44.3197,  47.9137]\nindex= pd.date_range(start='2005', end='2010-Q4', freq='QS-OCT')\naust = pd.Series(data, index)fit1 = tsa.ExponentialSmoothing(aust, seasonal_periods=4, trend='add', seasonal='add').fit(use_boxcox=True)\nfit2 = tsa.ExponentialSmoothing(aust, seasonal_periods=4, trend='add', seasonal='mul').fit(use_boxcox=True)\nfit3 = tsa.ExponentialSmoothing(aust, seasonal_periods=4, trend='add', seasonal='add', damped=True).fit(use_boxcox=True)\nfit4 = tsa.ExponentialSmoothing(aust, seasonal_periods=4, trend='add', seasonal='mul', damped=True).fit(use_boxcox=True)\nresults=pd.DataFrame(np.zeros((7,4)),index=[r\"$\\alpha$\",r\"$\\beta$\",r\"$\\phi$\",r\"$\\gamma$\",r\"$l_0$\",\"$b_0$\",\"SSE\"],columns=[\"Additive\",\"Multiplicative\",\"Additive Dam\",\"Multiplica Dam\"])\nparams = ['smoothing_level', 'smoothing_slope', 'damping_slope', 'smoothing_seasonal', 'initial_level', 'initial_slope']\nresults[\"Additive\"]       = [fit1.params[p] for p in params] + [fit1.sse]\nresults[\"Multiplicative\"] = [fit2.params[p] for p in params] + [fit2.sse]\nresults[\"Additive Dam\"]   = [fit3.params[p] for p in params] + [fit3.sse]\nresults[\"Multiplica Dam\"] = [fit4.params[p] for p in params] + [fit4.sse]\n\nfig,ax=plt.subplots(figsize=(10,6))\nax .plot(aust,marker='o', color='black' )\nax.set_ylabel(\"International visitor night in Australia (millions)\")\nax.set_xlabel(\"Year\")\nax.set_title(\"Forecasts from Holt-Winters' multiplicative method\")\nax.plot(fit1.fittedvalues, ls='--', color='red')\nax.plot(fit2.fittedvalues, ls='--', color='green')\nax.plot(fit1.forecast(8), ls='--', marker='o', color='red', label='Holt-Winters (add-add-seasonal)')\nax.plot(fit2.forecast(8), ls='--', marker='o', color='green',label='Holt-Winters (add-mul-seasonal)')\nplt.legend()\nplt.show()\nprint(\"Figure 7.6: Forecasting international visitor nights in Australia using Holt-Winters method with both additive and multiplicative seasonality.\")\n\nresults[<matplotlib.lines.Line2D at 0x168dd087b08>]\n\nText(0, 0.5, 'International visitor night in Australia (millions)')\n\nText(0.5, 0, 'Year')\n\nText(0.5, 1.0, \"Forecasts from Holt-Winters' multiplicative method\")\n\n[<matplotlib.lines.Line2D at 0x168dec3f988>]\n\n[<matplotlib.lines.Line2D at 0x168dec5c348>]\n\n[<matplotlib.lines.Line2D at 0x168dc093a88>]\n\n[<matplotlib.lines.Line2D at 0x168dececa88>]\n\n<matplotlib.legend.Legend at 0x168dec08588>Figure 7.6: Forecasting international visitor nights in Australia using Holt-Winters method with both additive and multiplicative seasonality.df = pd.DataFrame(np.c_[aust, fit1.level, fit1.slope, fit1.season, fit1.fittedvalues],\n                  columns=[r'$y_t$',r'$l_t$',r'$b_t$',r'$s_t$',r'$\\hat{y}_t$'],index=aust.index)\ndf.append(fit1.forecast(8).rename(r'$\\hat{y}_t$').to_frame(), sort=True)df = pd.DataFrame(np.c_[aust, fit2.level, fit2.slope, fit2.season, fit2.fittedvalues], \n                  columns=[r'$y_t$',r'$l_t$',r'$b_t$',r'$s_t$',r'$\\hat{y}_t$'],index=aust.index)\ndf.append(fit2.forecast(8).rename(r'$\\hat{y}_t$').to_frame(), sort=True)states1 = pd.DataFrame(np.c_[fit1.level, fit1.slope, fit1.season], columns=['level','slope','seasonal'], index=aust.index)\nstates2 = pd.DataFrame(np.c_[fit2.level, fit2.slope, fit2.season], columns=['level','slope','seasonal'], index=aust.index)\nfig, [[ax1, ax4],[ax2, ax5], [ax3, ax6]] = plt.subplots(3, 2, figsize=(12,8))\nax1.plot(states1[['level']],label='level')\nax1.legend()\nax2.plot(states1[['slope']],label='slope')\nax2.legend()\nax3.plot(states1[['seasonal']],label='seasonal')\nax3.legend()\nax4.plot(states2[['level']],label='level')\nax4.legend()\nax5.plot(states2[['slope']],label='slope')\nax5.legend()\nax6.plot(states2[['seasonal']],label='seasonal')\nax6.legend()\nplt.show()[<matplotlib.lines.Line2D at 0x168dbceab08>]\n\n<matplotlib.legend.Legend at 0x168db928648>\n\n[<matplotlib.lines.Line2D at 0x168dcf41bc8>]\n\n<matplotlib.legend.Legend at 0x168db9ab9c8>\n\n[<matplotlib.lines.Line2D at 0x168dc101cc8>]\n\n<matplotlib.legend.Legend at 0x168dba4f3c8>\n\n[<matplotlib.lines.Line2D at 0x168dcf46c08>]\n\n<matplotlib.legend.Legend at 0x168dc0f6fc8>\n\n[<matplotlib.lines.Line2D at 0x168dcf6cdc8>]\n\n<matplotlib.legend.Legend at 0x168dc12e708>\n\n[<matplotlib.lines.Line2D at 0x168db9ef548>]\n\n<matplotlib.legend.Legend at 0x168db9c3208>"},{"path":"时间序列模型.html","id":"examples参考","chapter":"第11章 时间序列模型","heading":"11.2.8 examples参考","text":"ARMA模型，讲了平稳性检验，随机性检验，相关图绘制，模型定阶和构建，假设的检验，预测ARIMA模型,讲了只有趋势项的情形，以及疏系数构建，以及ARIMA加法和乘法模型指数平滑的例子,包括简单指数平滑，holt两参数平滑（无季节效应），holt三参数季节加法和乘法模型ARIMA Example 4: ARMAX (Friedman)model demonstrates use explanatory variables (X part ARMAX). exogenous regressors included, SARIMAX module uses concept “regression SARIMA errors” (see http://robjhyndman.com/hyndsight/arimax/ details regression ARIMA errors versus alternative specifications), model specified :\\[y_t = \\beta_t x_t + u_t \\\\\n        \\phi_p (L) \\tilde \\phi_P (L^s) \\Delta^d \\Delta_s^D u_t = (t) +\n            \\theta_q (L) \\tilde \\theta_Q (L^s) \\epsilon_t\\]Notice first equation just linear regression, second equation just describes process followed error component SARIMA (described example 3). One reason specification estimated parameters natural interpretations.specification nests many simpler specifications. example, regression AR(2) errors :\\[y_t = \\beta_t x_t + u_t \\\\\n(1 - \\phi_1 L - \\phi_2 L^2) u_t = (t) + \\epsilon_t\\]model considered example regression ARMA(1,1) errors. process written:\\[\\text{consump}_t = \\beta_0 + \\beta_1 \\text{m2}_t + u_t \\\\\n(1 - \\phi_1 L) u_t = (1 - \\theta_1 L) \\epsilon_t\\]Notice β0 , described example 1 , thing intercept specified trend=‘c’. Whereas examples estimated intercept model via trend polynomial, , demonstrate estimate β0 adding constant exogenous dataset. output, beta0 called const, whereas intercept c called intercept output.Next, want get results full dataset using estimated parameters (subset data).predict command first applied get -sample predictions. use full_results=True argument allow us calculate confidence intervals (default output predict just predicted values).可以使用full_results=True使predict预测返回估计值置信区间With arguments, predict returns one-step-ahead -sample predictions entire sample.#使用样本的真实值一步一步预测We can also get dynamic predictions. One-step-ahead prediction uses true values endogenous values step predict next -sample value. Dynamic predictions use one-step-ahead prediction point dataset (specified dynamic argument); , previous predicted endogenous values used place true endogenous values new predicted element.dynamic argument specified offset relative start argument. start specified, assumed 0.perform dynamic prediction starting first quarter 1978.我们也可以设置一个动态时间点，在该时间点之前，使用样本观察值预测，之后的预测使用之前样本的预测值预测。can graph one-step-ahead dynamic predictions (corresponding confidence intervals) see relative performance. Notice point dynamic prediction begins (1978:Q1), two .Finally, graph prediction error. obvious , one suspect, one-step-ahead prediction considerably better.","code":"# Dataset\nfriedman2 = requests.get('https://www.stata-press.com/data/r12/friedman2.dta').content\ndata = pd.read_stata(BytesIO(friedman2))\ndata.index = data.time\n\n# Variables\nendog = data.loc['1959':'1981', 'consump']\nexog = sm.add_constant(data.loc['1959':'1981', 'm2'])\n\n# Fit the model\nmod = sm.tsa.statespace.SARIMAX(endog, exog, order=(1,0,1))\nres = mod.fit(disp=False)\nprint(res.summary())                           Statespace Model Results                           \n==============================================================================\nDep. Variable:                consump   No. Observations:                   92\nModel:               SARIMAX(1, 0, 1)   Log Likelihood                -340.508\nDate:                Sat, 10 Apr 2021   AIC                            691.015\nTime:                        21:25:14   BIC                            703.624\nSample:                    01-01-1959   HQIC                           696.105\n                         - 10-01-1981                                         \nCovariance Type:                  opg                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nconst        -36.0620     56.639     -0.637      0.524    -147.073      74.949\nm2             1.1220      0.036     30.826      0.000       1.051       1.193\nar.L1          0.9348      0.041     22.717      0.000       0.854       1.015\nma.L1          0.3091      0.089      3.488      0.000       0.135       0.483\nsigma2        93.2558     10.889      8.565      0.000      71.915     114.597\n===================================================================================\nLjung-Box (Q):                       38.72   Jarque-Bera (JB):                23.49\nProb(Q):                              0.53   Prob(JB):                         0.00\nHeteroskedasticity (H):              22.51   Skew:                             0.17\nProb(H) (two-sided):                  0.00   Kurtosis:                         5.45\n===================================================================================\n\nWarnings:\n[1] Covariance matrix calculated using the outer product of gradients (complex-step).\n\nARIMA Postestimation: Example 1 - Dynamic Forecasting\nHere we describe some of the post-estimation capabilities of Statsmodels' SARIMAX.\n\nFirst, using the model from example, we estimate the parameters using data that excludes the last few observations (this is a little artificial as an example, but it allows considering performance of out-of-sample forecasting and facilitates comparison to Stata's documentation).# Dataset\nraw = pd.read_stata(BytesIO(friedman2))\nraw.index = raw.time\ndata = raw.loc[:'1981']\n\n# Variables\nendog = data.loc['1959':, 'consump']\nexog = sm.add_constant(data.loc['1959':, 'm2'])\nnobs = endog.shape[0]\n\n# Fit the model\nmod = sm.tsa.statespace.SARIMAX(endog.loc[:'1978-01-01'], exog=exog.loc[:'1978-01-01'], order=(1,0,1))\nfit_res = mod.fit(disp=False)\nprint(fit_res.summary())                           Statespace Model Results                           \n==============================================================================\nDep. Variable:                consump   No. Observations:                   77\nModel:               SARIMAX(1, 0, 1)   Log Likelihood                -243.316\nDate:                Sat, 10 Apr 2021   AIC                            496.633\nTime:                        21:25:18   BIC                            508.352\nSample:                    01-01-1959   HQIC                           501.320\n                         - 01-01-1978                                         \nCovariance Type:                  opg                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nconst          0.6780     18.492      0.037      0.971     -35.565      36.921\nm2             1.0379      0.021     50.329      0.000       0.997       1.078\nar.L1          0.8775      0.059     14.859      0.000       0.762       0.993\nma.L1          0.2771      0.108      2.572      0.010       0.066       0.488\nsigma2        31.6978      4.683      6.769      0.000      22.520      40.876\n===================================================================================\nLjung-Box (Q):                       46.78   Jarque-Bera (JB):                 6.05\nProb(Q):                              0.21   Prob(JB):                         0.05\nHeteroskedasticity (H):               6.09   Skew:                             0.57\nProb(H) (two-sided):                  0.00   Kurtosis:                         3.76\n===================================================================================\n\nWarnings:\n[1] Covariance matrix calculated using the outer product of gradients (complex-step).mod = sm.tsa.statespace.SARIMAX(endog, exog=exog, order=(1,0,1))\nres = mod.filter(fit_res.params)#直接利用参数生成模型res.predict()\nres.predict(full_results=True)#似乎没有什么不同1959-01-01     300.780573\n1959-04-01     314.699703\n1959-07-01     318.333788\n1959-10-01     322.140570\n1960-01-01     324.148871\n                 ...     \n1980-10-01    1792.130868\n1981-01-01    1866.122212\n1981-04-01    1907.567799\n1981-07-01    1944.034222\n1981-10-01    1999.784229\nFreq: QS-OCT, Length: 92, dtype: float64\n\n1959-01-01     300.780573\n1959-04-01     314.699703\n1959-07-01     318.333788\n1959-10-01     322.140570\n1960-01-01     324.148871\n                 ...     \n1980-10-01    1792.130868\n1981-01-01    1866.122212\n1981-04-01    1907.567799\n1981-07-01    1944.034222\n1981-10-01    1999.784229\nFreq: QS-OCT, Length: 92, dtype: float64# In-sample one-step-ahead predictions\npredict = res.get_prediction()\npredict_ci = predict.conf_int()# Dynamic predictions\npredict_dy = res.get_prediction(dynamic='1978-01-01')\npredict_dy_ci = predict_dy.conf_int()# Graph\nfig, ax = plt.subplots(figsize=(9,4))\nnpre = 4\nax.set(title='Personal consumption', xlabel='Date', ylabel='Billions of dollars')\n\n# Plot data points\nax.plot(data.loc['1977-07-01':, 'consump'], color='orange', label='Observed')\n\n# Plot predictions\nax.plot(predict.predicted_mean.loc['1977-07-01':], ls='--',color='r', label='One-step-ahead forecast')\nci = predict_ci.loc['1977-07-01':]\nax.fill_between(ci.index, ci.iloc[:,0], ci.iloc[:,1], color='red', alpha=0.1)\nax.plot(predict_dy.predicted_mean.loc['1977-07-01':], color='green', label='Dynamic forecast (1978)')\nci = predict_dy_ci.loc['1977-07-01':]\nax.fill_between(ci.index, ci.iloc[:,0], ci.iloc[:,1], color='green', alpha=0.1)\nlegend = ax.legend(loc='lower right')\nplt.show()[Text(0, 0.5, 'Billions of dollars'),\n Text(0.5, 0, 'Date'),\n Text(0.5, 1.0, 'Personal consumption')]\n\n[<matplotlib.lines.Line2D at 0x168e340c548>]\n\n[<matplotlib.lines.Line2D at 0x168e143dac8>]\n\n<matplotlib.collections.PolyCollection at 0x168de9f5988>\n\n[<matplotlib.lines.Line2D at 0x168de9f5b48>]\n\n<matplotlib.collections.PolyCollection at 0x168dbd47848># Prediction error\n\n# Graph\nfig, ax = plt.subplots(figsize=(9,4))\nnpre = 4\nax.set(title='Forecast error', xlabel='Date', ylabel='Forecast - Actual')\n\n# In-sample one-step-ahead predictions and 95% confidence intervals\npredict_error = predict.predicted_mean - endog\nax.plot(predict_error.loc['1977-10-01':], label='One-step-ahead forecast')\nci = predict_ci.loc['1977-10-01':].copy()\nci.iloc[:,0] -= endog.loc['1977-10-01':]\nci.iloc[:,1] -= endog.loc['1977-10-01':]\nax.fill_between(ci.index, ci.iloc[:,0], ci.iloc[:,1], alpha=0.1)\n\n# Dynamic predictions and 95% confidence intervals\npredict_dy_error = predict_dy.predicted_mean - endog\nax.plot(predict_dy_error.loc['1977-10-01':], color='r', label='Dynamic forecast (1978)')\nci = predict_dy_ci.loc['1977-10-01':].copy()\nci.iloc[:,0] -= endog.loc['1977-10-01':]#这是在减去常数，算error的置信区间\nci.iloc[:,1] -= endog.loc['1977-10-01':]\nax.fill_between(ci.index, ci.iloc[:,0], ci.iloc[:,1], color='r', alpha=0.1)\n\nlegend = ax.legend(loc='lower left');\nlegend.get_frame().set_facecolor('w')[Text(0, 0.5, 'Forecast - Actual'),\n Text(0.5, 0, 'Date'),\n Text(0.5, 1.0, 'Forecast error')]\n\n[<matplotlib.lines.Line2D at 0x168e3417a48>]\n\n<matplotlib.collections.PolyCollection at 0x168dbdba808>\n\n[<matplotlib.lines.Line2D at 0x168dbdba4c8>]\n\n<matplotlib.collections.PolyCollection at 0x168dbdc4888>"}]
